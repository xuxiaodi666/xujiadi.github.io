<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>9.29被面 | 徐嘉迪的个人网站</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="一、作用域    概念：作用域就是一个独立的地盘，让变量不会外泄、暴露出去。也就是说作用域最大的用处就是隔离变量，不同作用域下同名变量 不会有冲突。        ES6 之前 JavaScript 没有块级作用域,只有全局作用域和函数作用域。ES6 的到来，为我们提供了‘块级作用域’,可通过新增命令 let 和 const 来体现。    扩展：    var ——ES5 变量声明方式">
<meta property="og:type" content="article">
<meta property="og:title" content="9.29被面">
<meta property="og:url" content="http://example.com/2022/11/01/9-29%E8%A2%AB%E9%9D%A2/index.html">
<meta property="og:site_name" content="徐嘉迪的个人网站">
<meta property="og:description" content="一、作用域    概念：作用域就是一个独立的地盘，让变量不会外泄、暴露出去。也就是说作用域最大的用处就是隔离变量，不同作用域下同名变量 不会有冲突。        ES6 之前 JavaScript 没有块级作用域,只有全局作用域和函数作用域。ES6 的到来，为我们提供了‘块级作用域’,可通过新增命令 let 和 const 来体现。    扩展：    var ——ES5 变量声明方式">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-11-01T01:14:40.000Z">
<meta property="article:modified_time" content="2022-11-01T01:14:54.715Z">
<meta property="article:author" content="XuJiaDi">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="徐嘉迪的个人网站" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">徐嘉迪的个人网站</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">没有永远的失败者，只有努力的成功者</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS 订阅"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-9-29被面" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/11/01/9-29%E8%A2%AB%E9%9D%A2/" class="article-date">
  <time class="dt-published" datetime="2022-11-01T01:14:40.000Z" itemprop="datePublished">2022-11-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      9.29被面
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>一、作用域<br>    概念：作用域就是一个独立的地盘，让变量不会外泄、暴露出去。也就是说作用域最大的用处就是隔离变量，不同作用域下同名变量 不会有冲突。<br>        ES6 之前 JavaScript 没有块级作用域,只有全局作用域和函数作用域。ES6 的到来，为我们提供了‘块级作用域’,可通过新增命令 let 和 const 来体现。<br>    扩展：<br>    var ——ES5 变量声明方式<br>        在变量未赋值时，变量undefined（为使用声明变量时也为undefined）<br>        作用域——var的作用域为方法作用域；只要在方法内定义了，整个方法内的定义变量后的代码都可以使用<br>    let——ES6变量声明方式<br>        在变量为声明前直接使用会报错<br>        作用域——let为块作用域——通常let比var 范围要小<br>        let禁止重复声明变量，否则会报错；var可以重复声明<br>    const——ES6变量声明方式<br>        const为常量声明方式；声明变量时必须初始化，在后面出现的代码中不能再修改该常量的值<br>        const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动<br>二、javascript中arguments相关的问题 （忘函数里面传参的时候，传一大堆，函数里面 arguments 接收 ）<br>    arguments<br>    在js中，我们在调用有参数的函数时，当往这个调用的有参函数传参时，js会把所传的参数全部存到一个叫arguments的对象里面。它是一个类数组数据<br>    由来<br>    Javascrip中每个函数都会有一个Arguments对象实例arguments，引用着函数的实参。它是寄生在js函数当中的，不能显式创建，arguments对象只有函数开始时才可用<br>    作用<br>    有了arguments这个对象之后，我们可以不用给函数预先设定形参了，可以动态地通过arguments为函数加入参数<br>三、代码解析题（偏）<br>    题目一：<br>        var min &#x3D; Math.min();<br>        max &#x3D; Math.max();<br>        console.log(min &lt; max);<br>        &#x2F;&#x2F; 写出执行结果，并解释原因<br>        答案：false<br>        解析：按常规的思路，这段代码应该输出 true，毕竟最小值小于最大值。但是却输出 false<br>        MDN 相关文档是这样解释的<br>            Math.min 的参数是 0 个或者多个，如果多个参数很容易理解，返回参数中最小的。如果没有参数，则返回 Infinity，无穷大。而 Math.max 没有传递参数时返回的是-Infinity.所以输出 false<br>    题目二：<br>        var company &#x3D; {<br>        address: ‘beijing’<br>        }<br>        var yiDeng &#x3D; Object.create(company);<br>        delete yiDeng.address<br>        console.log(yiDeng.address);<br>        &#x2F;&#x2F; 写出执行结果，并解释原因<br>        答案：beijing<br>        解析：这里的 yiDeng 通过 prototype 继承了 company的 address 。 yiDeng 自己并没有address属性。所以delete操作符的作用是无效的。<br>        扩展：<br>        1.delete使用原则：delete 操作符用来删除一个对象的属性。<br>        2.delete在删除一个不可配置的属性时在严格模式和非严格模式下的区别:<br>            （1）在严格模式中，如果属性是一个不可配置（non-configurable）属性，删除时会抛出异常;<br>            （2）非严格模式下返回 false。<br>        3.delete能删除隐式声明的全局变量：这个全局变量其实是global对象(window)的属性<br>        4.1、delete能删除的：<br>        （1）可配置对象的属性（2）隐式声明的全局变量 （3）用户定义的属性 （4）在ECMAScript 6中，通过 const 或 let 声明指定的 “temporal dead zone” (TDZ) 对 delete 操作符也会起作用<br>        4.2、delete不能删除的：<br>        （2）显式声明的全局变量 （2）内置对象的内置属性 （3）一个对象从原型继承而来的属性<br>        5.delete删除数组元素：<br>            （1）当你删除一个数组元素时，数组的 length 属性并不会变小，数组元素变成undefined<br>            （2）当用 delete 操作符删除一个数组元素时，被删除的元素已经完全不属于该数组。<br>            （3）如果你想让一个数组元素的值变为 undefined 而不是删除它，可以使用 undefined 给其赋值而不是使用 delete 操作符。此时数组元素是在数组中的<br>        6.delete 操作符与直接释放内存（只能通过解除引用来间接释放）没有关系。<br>四、Promise 使用：<br>    <a target="_blank" rel="noopener" href="https://www.nowcoder.com/tutorial/96/33fec0f911f34bccbb8215d41814f70c">https://www.nowcoder.com/tutorial/96/33fec0f911f34bccbb8215d41814f70c</a><br>五、改变函数内部的this指向（再看看）<br>    call apply bind的用法和区别<br>    1、call方法<br>    改变函数内部this指向<br>    call()方法调用一个对象。简单理解为调用函数的方式，但是它可以改变函数的this指向。<br>    写法：fun.call(thisArg, arg1, arg3, …) &#x2F;&#x2F; thisArg为想要指向的对象，arg1,arg3为参数<br>    call 的主要作用也可以实现继承<br>        function Person(uname, age) {<br>            this.uname &#x3D; uname;<br>            this.age &#x3D; age;<br>        }<br>        function Son(uname, age) {<br>            Person.call(this, uname, age);<br>        }<br>        var son &#x3D; new Son(“张三”, 12);<br>        console.log(son); &#x2F;&#x2F;Son {uname: ‘张三’, age: 12}<br>    2、apply方法<br>        apply()方法调用一个函数。简单理解为调用函数的方式，但是它可以改变函数的this指向。<br>        写法：fun.apply(thisArg, [argsArray])<br>            thisArg:在fun函数运行时指定的this值<br>            argsArray:传递的值，必须包含在数组里面<br>            返回值就是函数的返回值，因为他就是调用函数<br>        apply的主要应用，比如可以利用apply可以求得数组中最大值<br>            const arr &#x3D; [1, 22, 3, 44, 5, 66, 7, 88, 9];<br>            const max &#x3D; Math.max.apply(Math, arr);<br>            console.log(max);<br>    3、bind方法<br>        bind()方法不会调用函数，但是能改变函数内部this指向<br>        写法：fun.bind(thisArg, arg1, arg2, …)<br>            thisArg:在fun函数运行时指定的this值<br>            arg1,arg2:传递的其他参数<br>            返回由指定的this值和初始化参数改造的原函数拷贝<br>            var o &#x3D; {<br>                name: “张三”<br>            };<br>            function fn() {<br>                console.log(this);<br>            }<br>            var f &#x3D; fn.bind(o);<br>            f();<br>        bind应用<br>        如果有的函数我们不需要立即调用，但是又需要改变这个函数的this指向，此时用bind再合适不过了<br>            const btns &#x3D; document.querySelectorAll(“button”);<br>            for (let i &#x3D; 0; i &lt; btns.length; i++) {<br>                btns[i].onclick &#x3D; function() {<br>                this.disabled &#x3D; true;<br>                setTimeout(<br>                    function() {<br>                    this.disabled &#x3D; false;<br>                    }.bind(this),<br>                    2000<br>                );<br>                };<br>            }<br>六、new会发生什么（）看<br>    1、创建空对象；<br>    var obj &#x3D; {};<br>    2、设置新对象的constructor属性为构造函数的名称，设置新对象的proto属性指向构造函数的prototype对象；<br>    obj.proto &#x3D; ClassA.prototype;<br>    扩展了新对象的原型链。</p>
<pre><code>3、使用新对象调用函数，函数中的this被指向新实例对象：
ClassA.call(obj);　　//&#123;&#125;.构造函数();

4、返回this指针。当存在显示的返回时，返回return后面的内容。新建的空对象作废。
    function test() &#123;
        this.name = &quot;test&quot;;
    &#125;
    test.prototype = &#123;
        a:&#123;&#125;,
        b:&#123;&#125;
    &#125;
    var  c = new test();
</code></pre>
<p>七、暂时性死区<br>    暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。<br>    扩展：<br>    let 、const与暂时性死区<br>    let或const声明的变量拥有暂时性死区（TDZ）：当进入它的作用域，它不能被访问（获取或设置）直到执行到达声明。<br>    首先看看不具有暂时性死区的var：<br>        当进入var变量的作用域（包围它的函数），立即为它创建（绑定）存储空间。变量会立即被初始化并赋值为undefined。<br>        当执行到变量声明的时候，如果变量定义了值则会被赋值。<br>    通过let声明的变量拥有暂时性死区，生命周期如下：<br>        当进入let变量的作用域（包围它的语法块），立即为它创建（绑定）存储空间。此时变量仍是未初始化的。<br>        获取或设置未初始化的变量将抛出异常ReferenceError。<br>        当执行到变量声明的时候，如果变量定义了值则会被赋值。如果没有定义值，则赋值为undefined。<br>    const工作方式与let类似，但是定义的时候必须赋值并且不能改变。<br>八、防抖和节流的原理和使用场景<br>    函数防抖和函数节流：优化高频率执行js代码的一种手段，js中的一些事件如浏览器的resize、scroll，鼠标的mousemove、mouseover，input输入框的keypress等事件在触发时，会不断地调用绑定在事件上的回调函数，极大地浪费资源，降低前端性能。为了优化体验，需要对这类事件进行调用次数的限制。<br>    1、防抖：<br>        在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。<br>            var timer; &#x2F;&#x2F; 维护同一个timer<br>            function debounce(fn, delay) {<br>                clearTimeout(timer);<br>                timer &#x3D; setTimeout(function(){<br>                    fn();<br>                }, delay);<br>            }<br>        在上面的代码中，会出现一个问题，var timer只能在setTimeout的父级作用域中，这样才是同一个timer，并且为了方便防抖函数的调用和回调函数fn的传参问题，我们应该用闭包来解决这些问题。<br>        优化后的代码：<br>        function debounce(fn, delay) {<br>            var timer; &#x2F;&#x2F; 维护一个 timer<br>            return function () {<br>                var _this &#x3D; this; &#x2F;&#x2F; 取debounce执行作用域的this<br>                var args &#x3D; arguments;<br>                if (timer) {<br>                    clearTimeout(timer);<br>                }<br>                timer &#x3D; setTimeout(function () {<br>                    fn.apply(_this, args); &#x2F;&#x2F; 用apply指向调用debounce的对象，相当于_this.fn(args);<br>                }, delay);<br>            };<br>        }<br>        使用闭包后，解决传参和封装防抖函数的问题，这样就可以在其他地方随便将需要防抖的函数传入debounce了。<br>    2、节流：<br>        每隔一段时间，只执行一次函数。<br>    3、异同比较<br>        相同点：<br>            都可以通过使用 setTimeout 实现。<br>            目的都是，降低回调执行频率。节省计算资源。<br>        不同点：<br>            函数防抖，在一段连续操作结束后，处理回调，利用clearTimeout 和 setTimeout实现。函数节流，在一段连续操作中，每一段时间只执行一次，频率较高的事件中使用来提高性能。<br>            函数防抖关注一定时间连续触发的事件只在最后执行一次，而函数节流侧重于一段时间内只执行一次。<br>    4、常见应用场景<br>        函数防抖的应用场景:<br>            连续的事件，只需触发一次回调的场景有：<br>            搜索框搜索输入。只需用户最后一次输入完，再发送请求<br>            手机号、邮箱验证输入检测<br>            窗口大小Resize。只需窗口调整完成后，计算窗口大小。防止重复渲染。</p>
<pre><code>    函数节流的应用场景:
        间隔一段时间执行一次回调的场景有：
        滚动加载，加载更多或滚到底部监听
        谷歌搜索框，搜索联想功能
        高频点击提交，表单重复提交
        轮播图的下一页（等这一页滚动完再进行下一页的滚动）
</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/11/01/9-29%E8%A2%AB%E9%9D%A2/" data-id="claxeer9n0009v8w185bs24b3" data-title="9.29被面" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2022/11/01/9-26%E8%A2%AB%E9%9D%A2/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">前一篇</strong>
      <div class="article-nav-title">
        
          9.26被面
        
      </div>
    </a>
  
  
    <a href="/2022/11/01/vue3%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">后一篇</strong>
      <div class="article-nav-title">vue3快速上手</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/11/">十一月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">十月 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/11/26/%E4%B8%BA%E4%BB%80%E4%B9%88React16%E8%A6%81%E6%9B%B4%E6%94%B9%E7%BB%84%E4%BB%B6%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-%EF%BC%88%E4%B8%8B%EF%BC%89/">为什么React16要更改组件的生命周期?（下）</a>
          </li>
        
          <li>
            <a href="/2022/11/26/%E8%A6%81%E6%9B%B4%E6%94%B9%E7%BB%84%E4%BB%B6%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%9F%EF%BC%88%E4%B8%8A%EF%BC%89/">(no title)</a>
          </li>
        
          <li>
            <a href="/2022/11/26/%E4%BB%A3%E7%A0%81%E8%BD%ACdom/">代码转dom</a>
          </li>
        
          <li>
            <a href="/2022/11/26/React%E7%9F%A5%E8%AF%86%E9%93%BE/">React知识链</a>
          </li>
        
          <li>
            <a href="/2022/11/02/%E6%8E%92%E5%BA%8F%E2%80%9C/">排序“</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 XuJiaDi<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>