<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>徐嘉迪的个人网站</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="没有永远的失败者，只有努力的成功者">
<meta property="og:type" content="website">
<meta property="og:title" content="徐嘉迪的个人网站">
<meta property="og:url" content="http://example.com/page/6/index.html">
<meta property="og:site_name" content="徐嘉迪的个人网站">
<meta property="og:description" content="没有永远的失败者，只有努力的成功者">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="XuJiaDi">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="徐嘉迪的个人网站" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">徐嘉迪的个人网站</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">没有永远的失败者，只有努力的成功者</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS 订阅"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-9-29被面" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/11/01/9-29%E8%A2%AB%E9%9D%A2/" class="article-date">
  <time class="dt-published" datetime="2022-11-01T01:14:40.000Z" itemprop="datePublished">2022-11-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/11/01/9-29%E8%A2%AB%E9%9D%A2/">9.29被面</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>一、作用域<br>    概念：作用域就是一个独立的地盘，让变量不会外泄、暴露出去。也就是说作用域最大的用处就是隔离变量，不同作用域下同名变量 不会有冲突。<br>        ES6 之前 JavaScript 没有块级作用域,只有全局作用域和函数作用域。ES6 的到来，为我们提供了‘块级作用域’,可通过新增命令 let 和 const 来体现。<br>    扩展：<br>    var ——ES5 变量声明方式<br>        在变量未赋值时，变量undefined（为使用声明变量时也为undefined）<br>        作用域——var的作用域为方法作用域；只要在方法内定义了，整个方法内的定义变量后的代码都可以使用<br>    let——ES6变量声明方式<br>        在变量为声明前直接使用会报错<br>        作用域——let为块作用域——通常let比var 范围要小<br>        let禁止重复声明变量，否则会报错；var可以重复声明<br>    const——ES6变量声明方式<br>        const为常量声明方式；声明变量时必须初始化，在后面出现的代码中不能再修改该常量的值<br>        const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动<br>二、javascript中arguments相关的问题 （忘函数里面传参的时候，传一大堆，函数里面 arguments 接收 ）<br>    arguments<br>    在js中，我们在调用有参数的函数时，当往这个调用的有参函数传参时，js会把所传的参数全部存到一个叫arguments的对象里面。它是一个类数组数据<br>    由来<br>    Javascrip中每个函数都会有一个Arguments对象实例arguments，引用着函数的实参。它是寄生在js函数当中的，不能显式创建，arguments对象只有函数开始时才可用<br>    作用<br>    有了arguments这个对象之后，我们可以不用给函数预先设定形参了，可以动态地通过arguments为函数加入参数<br>三、代码解析题（偏）<br>    题目一：<br>        var min &#x3D; Math.min();<br>        max &#x3D; Math.max();<br>        console.log(min &lt; max);<br>        &#x2F;&#x2F; 写出执行结果，并解释原因<br>        答案：false<br>        解析：按常规的思路，这段代码应该输出 true，毕竟最小值小于最大值。但是却输出 false<br>        MDN 相关文档是这样解释的<br>            Math.min 的参数是 0 个或者多个，如果多个参数很容易理解，返回参数中最小的。如果没有参数，则返回 Infinity，无穷大。而 Math.max 没有传递参数时返回的是-Infinity.所以输出 false<br>    题目二：<br>        var company &#x3D; {<br>        address: ‘beijing’<br>        }<br>        var yiDeng &#x3D; Object.create(company);<br>        delete yiDeng.address<br>        console.log(yiDeng.address);<br>        &#x2F;&#x2F; 写出执行结果，并解释原因<br>        答案：beijing<br>        解析：这里的 yiDeng 通过 prototype 继承了 company的 address 。 yiDeng 自己并没有address属性。所以delete操作符的作用是无效的。<br>        扩展：<br>        1.delete使用原则：delete 操作符用来删除一个对象的属性。<br>        2.delete在删除一个不可配置的属性时在严格模式和非严格模式下的区别:<br>            （1）在严格模式中，如果属性是一个不可配置（non-configurable）属性，删除时会抛出异常;<br>            （2）非严格模式下返回 false。<br>        3.delete能删除隐式声明的全局变量：这个全局变量其实是global对象(window)的属性<br>        4.1、delete能删除的：<br>        （1）可配置对象的属性（2）隐式声明的全局变量 （3）用户定义的属性 （4）在ECMAScript 6中，通过 const 或 let 声明指定的 “temporal dead zone” (TDZ) 对 delete 操作符也会起作用<br>        4.2、delete不能删除的：<br>        （2）显式声明的全局变量 （2）内置对象的内置属性 （3）一个对象从原型继承而来的属性<br>        5.delete删除数组元素：<br>            （1）当你删除一个数组元素时，数组的 length 属性并不会变小，数组元素变成undefined<br>            （2）当用 delete 操作符删除一个数组元素时，被删除的元素已经完全不属于该数组。<br>            （3）如果你想让一个数组元素的值变为 undefined 而不是删除它，可以使用 undefined 给其赋值而不是使用 delete 操作符。此时数组元素是在数组中的<br>        6.delete 操作符与直接释放内存（只能通过解除引用来间接释放）没有关系。<br>四、Promise 使用：<br>    <a target="_blank" rel="noopener" href="https://www.nowcoder.com/tutorial/96/33fec0f911f34bccbb8215d41814f70c">https://www.nowcoder.com/tutorial/96/33fec0f911f34bccbb8215d41814f70c</a><br>五、改变函数内部的this指向（再看看）<br>    call apply bind的用法和区别<br>    1、call方法<br>    改变函数内部this指向<br>    call()方法调用一个对象。简单理解为调用函数的方式，但是它可以改变函数的this指向。<br>    写法：fun.call(thisArg, arg1, arg3, …) &#x2F;&#x2F; thisArg为想要指向的对象，arg1,arg3为参数<br>    call 的主要作用也可以实现继承<br>        function Person(uname, age) {<br>            this.uname &#x3D; uname;<br>            this.age &#x3D; age;<br>        }<br>        function Son(uname, age) {<br>            Person.call(this, uname, age);<br>        }<br>        var son &#x3D; new Son(“张三”, 12);<br>        console.log(son); &#x2F;&#x2F;Son {uname: ‘张三’, age: 12}<br>    2、apply方法<br>        apply()方法调用一个函数。简单理解为调用函数的方式，但是它可以改变函数的this指向。<br>        写法：fun.apply(thisArg, [argsArray])<br>            thisArg:在fun函数运行时指定的this值<br>            argsArray:传递的值，必须包含在数组里面<br>            返回值就是函数的返回值，因为他就是调用函数<br>        apply的主要应用，比如可以利用apply可以求得数组中最大值<br>            const arr &#x3D; [1, 22, 3, 44, 5, 66, 7, 88, 9];<br>            const max &#x3D; Math.max.apply(Math, arr);<br>            console.log(max);<br>    3、bind方法<br>        bind()方法不会调用函数，但是能改变函数内部this指向<br>        写法：fun.bind(thisArg, arg1, arg2, …)<br>            thisArg:在fun函数运行时指定的this值<br>            arg1,arg2:传递的其他参数<br>            返回由指定的this值和初始化参数改造的原函数拷贝<br>            var o &#x3D; {<br>                name: “张三”<br>            };<br>            function fn() {<br>                console.log(this);<br>            }<br>            var f &#x3D; fn.bind(o);<br>            f();<br>        bind应用<br>        如果有的函数我们不需要立即调用，但是又需要改变这个函数的this指向，此时用bind再合适不过了<br>            const btns &#x3D; document.querySelectorAll(“button”);<br>            for (let i &#x3D; 0; i &lt; btns.length; i++) {<br>                btns[i].onclick &#x3D; function() {<br>                this.disabled &#x3D; true;<br>                setTimeout(<br>                    function() {<br>                    this.disabled &#x3D; false;<br>                    }.bind(this),<br>                    2000<br>                );<br>                };<br>            }<br>六、new会发生什么（）看<br>    1、创建空对象；<br>    var obj &#x3D; {};<br>    2、设置新对象的constructor属性为构造函数的名称，设置新对象的proto属性指向构造函数的prototype对象；<br>    obj.proto &#x3D; ClassA.prototype;<br>    扩展了新对象的原型链。</p>
<pre><code>3、使用新对象调用函数，函数中的this被指向新实例对象：
ClassA.call(obj);　　//&#123;&#125;.构造函数();

4、返回this指针。当存在显示的返回时，返回return后面的内容。新建的空对象作废。
    function test() &#123;
        this.name = &quot;test&quot;;
    &#125;
    test.prototype = &#123;
        a:&#123;&#125;,
        b:&#123;&#125;
    &#125;
    var  c = new test();
</code></pre>
<p>七、暂时性死区<br>    暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。<br>    扩展：<br>    let 、const与暂时性死区<br>    let或const声明的变量拥有暂时性死区（TDZ）：当进入它的作用域，它不能被访问（获取或设置）直到执行到达声明。<br>    首先看看不具有暂时性死区的var：<br>        当进入var变量的作用域（包围它的函数），立即为它创建（绑定）存储空间。变量会立即被初始化并赋值为undefined。<br>        当执行到变量声明的时候，如果变量定义了值则会被赋值。<br>    通过let声明的变量拥有暂时性死区，生命周期如下：<br>        当进入let变量的作用域（包围它的语法块），立即为它创建（绑定）存储空间。此时变量仍是未初始化的。<br>        获取或设置未初始化的变量将抛出异常ReferenceError。<br>        当执行到变量声明的时候，如果变量定义了值则会被赋值。如果没有定义值，则赋值为undefined。<br>    const工作方式与let类似，但是定义的时候必须赋值并且不能改变。<br>八、防抖和节流的原理和使用场景<br>    函数防抖和函数节流：优化高频率执行js代码的一种手段，js中的一些事件如浏览器的resize、scroll，鼠标的mousemove、mouseover，input输入框的keypress等事件在触发时，会不断地调用绑定在事件上的回调函数，极大地浪费资源，降低前端性能。为了优化体验，需要对这类事件进行调用次数的限制。<br>    1、防抖：<br>        在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。<br>            var timer; &#x2F;&#x2F; 维护同一个timer<br>            function debounce(fn, delay) {<br>                clearTimeout(timer);<br>                timer &#x3D; setTimeout(function(){<br>                    fn();<br>                }, delay);<br>            }<br>        在上面的代码中，会出现一个问题，var timer只能在setTimeout的父级作用域中，这样才是同一个timer，并且为了方便防抖函数的调用和回调函数fn的传参问题，我们应该用闭包来解决这些问题。<br>        优化后的代码：<br>        function debounce(fn, delay) {<br>            var timer; &#x2F;&#x2F; 维护一个 timer<br>            return function () {<br>                var _this &#x3D; this; &#x2F;&#x2F; 取debounce执行作用域的this<br>                var args &#x3D; arguments;<br>                if (timer) {<br>                    clearTimeout(timer);<br>                }<br>                timer &#x3D; setTimeout(function () {<br>                    fn.apply(_this, args); &#x2F;&#x2F; 用apply指向调用debounce的对象，相当于_this.fn(args);<br>                }, delay);<br>            };<br>        }<br>        使用闭包后，解决传参和封装防抖函数的问题，这样就可以在其他地方随便将需要防抖的函数传入debounce了。<br>    2、节流：<br>        每隔一段时间，只执行一次函数。<br>    3、异同比较<br>        相同点：<br>            都可以通过使用 setTimeout 实现。<br>            目的都是，降低回调执行频率。节省计算资源。<br>        不同点：<br>            函数防抖，在一段连续操作结束后，处理回调，利用clearTimeout 和 setTimeout实现。函数节流，在一段连续操作中，每一段时间只执行一次，频率较高的事件中使用来提高性能。<br>            函数防抖关注一定时间连续触发的事件只在最后执行一次，而函数节流侧重于一段时间内只执行一次。<br>    4、常见应用场景<br>        函数防抖的应用场景:<br>            连续的事件，只需触发一次回调的场景有：<br>            搜索框搜索输入。只需用户最后一次输入完，再发送请求<br>            手机号、邮箱验证输入检测<br>            窗口大小Resize。只需窗口调整完成后，计算窗口大小。防止重复渲染。</p>
<pre><code>    函数节流的应用场景:
        间隔一段时间执行一次回调的场景有：
        滚动加载，加载更多或滚到底部监听
        谷歌搜索框，搜索联想功能
        高频点击提交，表单重复提交
        轮播图的下一页（等这一页滚动完再进行下一页的滚动）
</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/11/01/9-29%E8%A2%AB%E9%9D%A2/" data-id="claxeer9n0009v8w185bs24b3" data-title="9.29被面" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-vue3快速上手" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/11/01/vue3%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/" class="article-date">
  <time class="dt-published" datetime="2022-11-01T01:11:39.000Z" itemprop="datePublished">2022-11-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/11/01/vue3%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/">vue3快速上手</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Vue3快速上手"><a href="#Vue3快速上手" class="headerlink" title="Vue3快速上手"></a>Vue3快速上手</h1><img src="https://user-images.githubusercontent.com/499550/93624428-53932780-f9ae-11ea-8d16-af949e16a09f.png" style="width:200px" />





<h2 id="1-Vue3简介"><a href="#1-Vue3简介" class="headerlink" title="1.Vue3简介"></a>1.Vue3简介</h2><ul>
<li>2020年9月18日，Vue.js发布3.0版本，代号：One Piece（海贼王）</li>
<li>耗时2年多、<a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-next/graphs/commit-activity">2600+次提交</a>、<a target="_blank" rel="noopener" href="https://github.com/vuejs/rfcs/tree/master/active-rfcs">30+个RFC</a>、<a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-next/pulls?q=is:pr+is:merged+-author:app/dependabot-preview+">600+次PR</a>、<a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-next/graphs/contributors">99位贡献者</a> </li>
<li>github上的tags地址：<a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-next/releases/tag/v3.0.0">https://github.com/vuejs/vue-next/releases/tag/v3.0.0</a></li>
</ul>
<h2 id="2-Vue3带来了什么"><a href="#2-Vue3带来了什么" class="headerlink" title="2.Vue3带来了什么"></a>2.Vue3带来了什么</h2><h3 id="1-性能的提升"><a href="#1-性能的提升" class="headerlink" title="1.性能的提升"></a>1.性能的提升</h3><ul>
<li><p>打包大小减少41%</p>
</li>
<li><p>初次渲染快55%, 更新渲染快133%</p>
</li>
<li><p>内存减少54%</p>
<p>……</p>
</li>
</ul>
<h3 id="2-源码的升级"><a href="#2-源码的升级" class="headerlink" title="2.源码的升级"></a>2.源码的升级</h3><ul>
<li><p>使用Proxy代替defineProperty实现响应式</p>
</li>
<li><p>重写虚拟DOM的实现和Tree-Shaking</p>
<p>……</p>
</li>
</ul>
<h3 id="3-拥抱TypeScript"><a href="#3-拥抱TypeScript" class="headerlink" title="3.拥抱TypeScript"></a>3.拥抱TypeScript</h3><ul>
<li>Vue3可以更好的支持TypeScript</li>
</ul>
<h3 id="4-新的特性"><a href="#4-新的特性" class="headerlink" title="4.新的特性"></a>4.新的特性</h3><ol>
<li><p>Composition API（组合API）</p>
<ul>
<li>setup配置</li>
<li>ref与reactive</li>
<li>watch与watchEffect</li>
<li>provide与inject</li>
<li>……</li>
</ul>
</li>
<li><p>新的内置组件</p>
<ul>
<li>Fragment </li>
<li>Teleport</li>
<li>Suspense</li>
</ul>
</li>
<li><p>其他改变</p>
<ul>
<li>新的生命周期钩子</li>
<li>data 选项应始终被声明为一个函数</li>
<li>移除keyCode支持作为 v-on 的修饰符</li>
<li>……</li>
</ul>
</li>
</ol>
<h1 id="一、创建Vue3-0工程"><a href="#一、创建Vue3-0工程" class="headerlink" title="一、创建Vue3.0工程"></a>一、创建Vue3.0工程</h1><h2 id="1-使用-vue-cli-创建"><a href="#1-使用-vue-cli-创建" class="headerlink" title="1.使用 vue-cli 创建"></a>1.使用 vue-cli 创建</h2><p>官方文档：<a target="_blank" rel="noopener" href="https://cli.vuejs.org/zh/guide/creating-a-project.html#vue-create">https://cli.vuejs.org/zh/guide/creating-a-project.html#vue-create</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 查看@vue/cli版本，确保@vue/cli版本在4.5.0以上</span></span><br><span class="line">vue --version</span><br><span class="line"><span class="comment">## 安装或者升级你的@vue/cli</span></span><br><span class="line">npm install -g @vue/cli</span><br><span class="line"><span class="comment">## 创建</span></span><br><span class="line">vue create vue_test</span><br><span class="line"><span class="comment">## 启动</span></span><br><span class="line"><span class="built_in">cd</span> vue_test</span><br><span class="line">npm run serve</span><br></pre></td></tr></table></figure>

<h2 id="2-使用-vite-创建"><a href="#2-使用-vite-创建" class="headerlink" title="2.使用 vite 创建"></a>2.使用 vite 创建</h2><p>官方文档：<a target="_blank" rel="noopener" href="https://v3.cn.vuejs.org/guide/installation.html#vite">https://v3.cn.vuejs.org/guide/installation.html#vite</a></p>
<p>vite官网：<a target="_blank" rel="noopener" href="https://vitejs.cn/">https://vitejs.cn</a></p>
<ul>
<li>什么是vite？—— 新一代前端构建工具。</li>
<li>优势如下：<ul>
<li>开发环境中，无需打包操作，可快速的冷启动。</li>
<li>轻量快速的热重载（HMR）。</li>
<li>真正的按需编译，不再等待整个应用编译完成。</li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 创建工程</span></span><br><span class="line">npm init vite-app &lt;project-name&gt;</span><br><span class="line"><span class="comment">## 进入工程目录</span></span><br><span class="line"><span class="built_in">cd</span> &lt;project-name&gt;</span><br><span class="line"><span class="comment">## 安装依赖</span></span><br><span class="line">npm install</span><br><span class="line"><span class="comment">## 运行</span></span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure>

<h1 id="二、常用-Composition-API"><a href="#二、常用-Composition-API" class="headerlink" title="二、常用 Composition API"></a>二、常用 Composition API</h1><p>官方文档: <a target="_blank" rel="noopener" href="https://v3.cn.vuejs.org/guide/composition-api-introduction.html">https://v3.cn.vuejs.org/guide/composition-api-introduction.html</a></p>
<h2 id="1-拉开序幕的setup"><a href="#1-拉开序幕的setup" class="headerlink" title="1.拉开序幕的setup"></a>1.拉开序幕的setup</h2><ol>
<li>理解：Vue3.0中一个新的配置项，值为一个函数。</li>
<li>setup是所有<strong style="color:#DD5145">Composition API（组合API）</strong><i style="color:gray;font-weight:bold">“ 表演的舞台 ”</i>。</li>
<li>组件中所用到的：数据、方法等等，均要配置在setup中。</li>
<li>setup函数的两种返回值：<ol>
<li>若返回一个对象，则对象中的属性、方法, 在模板中均可以直接使用。（重点关注！）</li>
<li><span style="color:#aad">若返回一个渲染函数：则可以自定义渲染内容。（了解）</span></li>
</ol>
</li>
<li>注意点：<ol>
<li>尽量不要与Vue2.x配置混用<ul>
<li>Vue2.x配置（data、methos、computed…）中<strong style="color:#DD5145">可以访问到</strong>setup中的属性、方法。</li>
<li>但在setup中<strong style="color:#DD5145">不能访问到</strong>Vue2.x配置（data、methos、computed…）。</li>
<li>如果有重名, setup优先。</li>
</ul>
</li>
<li>setup不能是一个async函数，因为返回值不再是return的对象, 而是promise, 模板看不到return对象中的属性。（后期也可以返回一个Promise实例，但需要Suspense和异步组件的配合）</li>
</ol>
</li>
</ol>
<h2 id="2-ref函数"><a href="#2-ref函数" class="headerlink" title="2.ref函数"></a>2.ref函数</h2><ul>
<li>作用: 定义一个响应式的数据</li>
<li>语法: <code>const xxx = ref(initValue)</code> <ul>
<li>创建一个包含响应式数据的<strong style="color:#DD5145">引用对象（reference对象，简称ref对象）</strong>。</li>
<li>JS中操作数据： <code>xxx.value</code></li>
<li>模板中读取数据: 不需要.value，直接：<code>&lt;div&gt;&#123;&#123;xxx&#125;&#125;&lt;/div&gt;</code></li>
</ul>
</li>
<li>备注：<ul>
<li>接收的数据可以是：基本类型、也可以是对象类型。</li>
<li>基本类型的数据：响应式依然是靠<code>Object.defineProperty()</code>的<code>get</code>与<code>set</code>完成的。</li>
<li>对象类型的数据：内部 <i style="color:gray;font-weight:bold">“ 求助 ”</i> 了Vue3.0中的一个新函数—— <code>reactive</code>函数。</li>
</ul>
</li>
</ul>
<h2 id="3-reactive函数"><a href="#3-reactive函数" class="headerlink" title="3.reactive函数"></a>3.reactive函数</h2><ul>
<li>作用: 定义一个<strong style="color:#DD5145">对象类型</strong>的响应式数据（基本类型不要用它，要用<code>ref</code>函数）</li>
<li>语法：<code>const 代理对象= reactive(源对象)</code>接收一个对象（或数组），返回一个<strong style="color:#DD5145">代理对象（Proxy的实例对象，简称proxy对象）</strong></li>
<li>reactive定义的响应式数据是“深层次的”。</li>
<li>内部基于 ES6 的 Proxy 实现，通过代理对象操作源对象内部数据进行操作。</li>
</ul>
<h2 id="4-Vue3-0中的响应式原理"><a href="#4-Vue3-0中的响应式原理" class="headerlink" title="4.Vue3.0中的响应式原理"></a>4.Vue3.0中的响应式原理</h2><h3 id="vue2-x的响应式"><a href="#vue2-x的响应式" class="headerlink" title="vue2.x的响应式"></a>vue2.x的响应式</h3><ul>
<li><p>实现原理：</p>
<ul>
<li><p>对象类型：通过<code>Object.defineProperty()</code>对属性的读取、修改进行拦截（数据劫持）。</p>
</li>
<li><p>数组类型：通过重写更新数组的一系列方法来实现拦截。（对数组的变更方法进行了包裹）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(data, <span class="string">&#x27;count&#x27;</span>, &#123;</span><br><span class="line">    get () &#123;&#125;, </span><br><span class="line">    set () &#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>存在问题：</p>
<ul>
<li>新增属性、删除属性, 界面不会更新。</li>
<li>直接通过下标修改数组, 界面不会自动更新。</li>
</ul>
</li>
</ul>
<h3 id="Vue3-0的响应式"><a href="#Vue3-0的响应式" class="headerlink" title="Vue3.0的响应式"></a>Vue3.0的响应式</h3><ul>
<li><p>实现原理: </p>
<ul>
<li><p>通过Proxy（代理）:  拦截对象中任意属性的变化, 包括：属性值的读写、属性的添加、属性的删除等。</p>
</li>
<li><p>通过Reflect（反射）:  对源对象的属性进行操作。</p>
</li>
<li><p>MDN文档中描述的Proxy与Reflect：</p>
<ul>
<li><p>Proxy：<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy</a></p>
</li>
<li><p>Reflect：<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Proxy</span>(data, &#123;</span><br><span class="line">	<span class="comment">// 拦截读取属性值</span></span><br><span class="line">    get (target, prop) &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, prop)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 拦截设置属性值或添加新属性</span></span><br><span class="line">    set (target, prop, value) &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, prop, value)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 拦截删除属性</span></span><br><span class="line">    deleteProperty (target, prop) &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">deleteProperty</span>(target, prop)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">proxy.<span class="property">name</span> = <span class="string">&#x27;tom&#x27;</span>   </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="5-reactive对比ref"><a href="#5-reactive对比ref" class="headerlink" title="5.reactive对比ref"></a>5.reactive对比ref</h2><ul>
<li>从定义数据角度对比：<ul>
<li>ref用来定义：<strong style="color:#DD5145">基本类型数据</strong>。</li>
<li>reactive用来定义：<strong style="color:#DD5145">对象（或数组）类型数据</strong>。</li>
<li>备注：ref也可以用来定义<strong style="color:#DD5145">对象（或数组）类型数据</strong>, 它内部会自动通过<code>reactive</code>转为<strong style="color:#DD5145">代理对象</strong>。</li>
</ul>
</li>
<li>从原理角度对比：<ul>
<li>ref通过<code>Object.defineProperty()</code>的<code>get</code>与<code>set</code>来实现响应式（数据劫持）。</li>
<li>reactive通过使用<strong style="color:#DD5145">Proxy</strong>来实现响应式（数据劫持）, 并通过<strong style="color:#DD5145">Reflect</strong>操作<strong style="color:orange">源对象</strong>内部的数据。</li>
</ul>
</li>
<li>从使用角度对比：<ul>
<li>ref定义的数据：操作数据<strong style="color:#DD5145">需要</strong><code>.value</code>，读取数据时模板中直接读取<strong style="color:#DD5145">不需要</strong><code>.value</code>。</li>
<li>reactive定义的数据：操作数据与读取数据：<strong style="color:#DD5145">均不需要</strong><code>.value</code>。</li>
</ul>
</li>
</ul>
<h2 id="6-setup的两个注意点"><a href="#6-setup的两个注意点" class="headerlink" title="6.setup的两个注意点"></a>6.setup的两个注意点</h2><ul>
<li><p>setup执行的时机</p>
<ul>
<li>在beforeCreate之前执行一次，this是undefined。</li>
</ul>
</li>
<li><p>setup的参数</p>
<ul>
<li>props：值为对象，包含：组件外部传递过来，且组件内部声明接收了的属性。</li>
<li>context：上下文对象<ul>
<li>attrs: 值为对象，包含：组件外部传递过来，但没有在props配置中声明的属性, 相当于 <code>this.$attrs</code>。</li>
<li>slots: 收到的插槽内容, 相当于 <code>this.$slots</code>。</li>
<li>emit: 分发自定义事件的函数, 相当于 <code>this.$emit</code>。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="7-计算属性与监视"><a href="#7-计算属性与监视" class="headerlink" title="7.计算属性与监视"></a>7.计算属性与监视</h2><h3 id="1-computed函数"><a href="#1-computed函数" class="headerlink" title="1.computed函数"></a>1.computed函数</h3><ul>
<li><p>与Vue2.x中computed配置功能一致</p>
</li>
<li><p>写法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;computed&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">setup</span>(<span class="params"></span>)&#123;</span><br><span class="line">    ...</span><br><span class="line">	<span class="comment">//计算属性——简写</span></span><br><span class="line">    <span class="keyword">let</span> fullName = <span class="title function_">computed</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> person.<span class="property">firstName</span> + <span class="string">&#x27;-&#x27;</span> + person.<span class="property">lastName</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">//计算属性——完整</span></span><br><span class="line">    <span class="keyword">let</span> fullName = <span class="title function_">computed</span>(&#123;</span><br><span class="line">        <span class="title function_">get</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> person.<span class="property">firstName</span> + <span class="string">&#x27;-&#x27;</span> + person.<span class="property">lastName</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">set</span>(<span class="params">value</span>)&#123;</span><br><span class="line">            <span class="keyword">const</span> nameArr = value.<span class="title function_">split</span>(<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">            person.<span class="property">firstName</span> = nameArr[<span class="number">0</span>]</span><br><span class="line">            person.<span class="property">lastName</span> = nameArr[<span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-watch函数"><a href="#2-watch函数" class="headerlink" title="2.watch函数"></a>2.watch函数</h3><ul>
<li><p>与Vue2.x中watch配置功能一致</p>
</li>
<li><p>两个小“坑”：</p>
<ul>
<li>监视reactive定义的响应式数据时：oldValue无法正确获取、强制开启了深度监视（deep配置失效）。</li>
<li>监视reactive定义的响应式数据中某个属性时：deep配置有效。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//情况一：监视ref定义的响应式数据</span></span><br><span class="line"><span class="title function_">watch</span>(sum,<span class="function">(<span class="params">newValue,oldValue</span>)=&gt;</span>&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;sum变化了&#x27;</span>,newValue,oldValue)</span><br><span class="line">&#125;,&#123;<span class="attr">immediate</span>:<span class="literal">true</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//情况二：监视多个ref定义的响应式数据</span></span><br><span class="line"><span class="title function_">watch</span>([sum,msg],<span class="function">(<span class="params">newValue,oldValue</span>)=&gt;</span>&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;sum或msg变化了&#x27;</span>,newValue,oldValue)</span><br><span class="line">&#125;) </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 情况三：监视reactive定义的响应式数据</span></span><br><span class="line"><span class="comment">			若watch监视的是reactive定义的响应式数据，则无法正确获得oldValue！！</span></span><br><span class="line"><span class="comment">			若watch监视的是reactive定义的响应式数据，则强制开启了深度监视 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="title function_">watch</span>(person,<span class="function">(<span class="params">newValue,oldValue</span>)=&gt;</span>&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;person变化了&#x27;</span>,newValue,oldValue)</span><br><span class="line">&#125;,&#123;<span class="attr">immediate</span>:<span class="literal">true</span>,<span class="attr">deep</span>:<span class="literal">false</span>&#125;) <span class="comment">//此处的deep配置不再奏效</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//情况四：监视reactive定义的响应式数据中的某个属性</span></span><br><span class="line"><span class="title function_">watch</span>(<span class="function">()=&gt;</span>person.<span class="property">job</span>,<span class="function">(<span class="params">newValue,oldValue</span>)=&gt;</span>&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;person的job变化了&#x27;</span>,newValue,oldValue)</span><br><span class="line">&#125;,&#123;<span class="attr">immediate</span>:<span class="literal">true</span>,<span class="attr">deep</span>:<span class="literal">true</span>&#125;) </span><br><span class="line"></span><br><span class="line"><span class="comment">//情况五：监视reactive定义的响应式数据中的某些属性</span></span><br><span class="line"><span class="title function_">watch</span>([<span class="function">()=&gt;</span>person.<span class="property">job</span>,<span class="function">()=&gt;</span>person.<span class="property">name</span>],<span class="function">(<span class="params">newValue,oldValue</span>)=&gt;</span>&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;person的job变化了&#x27;</span>,newValue,oldValue)</span><br><span class="line">&#125;,&#123;<span class="attr">immediate</span>:<span class="literal">true</span>,<span class="attr">deep</span>:<span class="literal">true</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//特殊情况</span></span><br><span class="line"><span class="title function_">watch</span>(<span class="function">()=&gt;</span>person.<span class="property">job</span>,<span class="function">(<span class="params">newValue,oldValue</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;person的job变化了&#x27;</span>,newValue,oldValue)</span><br><span class="line">&#125;,&#123;<span class="attr">deep</span>:<span class="literal">true</span>&#125;) <span class="comment">//此处由于监视的是reactive素定义的对象中的某个属性，所以deep配置有效</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-watchEffect函数"><a href="#3-watchEffect函数" class="headerlink" title="3.watchEffect函数"></a>3.watchEffect函数</h3><ul>
<li><p>watch的套路是：既要指明监视的属性，也要指明监视的回调。</p>
</li>
<li><p>watchEffect的套路是：不用指明监视哪个属性，监视的回调中用到哪个属性，那就监视哪个属性。</p>
</li>
<li><p>watchEffect有点像computed：</p>
<ul>
<li>但computed注重的计算出来的值（回调函数的返回值），所以必须要写返回值。</li>
<li>而watchEffect更注重的是过程（回调函数的函数体），所以不用写返回值。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//watchEffect所指定的回调中用到的数据只要发生变化，则直接重新执行回调。</span></span><br><span class="line"><span class="title function_">watchEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> x1 = sum.<span class="property">value</span></span><br><span class="line">    <span class="keyword">const</span> x2 = person.<span class="property">age</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;watchEffect配置的回调执行了&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="8-生命周期"><a href="#8-生命周期" class="headerlink" title="8.生命周期"></a>8.生命周期</h2><div style="border:1px solid black;width:380px;float:left;margin-right:20px;"><strong>vue2.x的生命周期</strong><img src="https://cn.vuejs.org/images/lifecycle.png" alt="lifecycle_2" style="zoom:33%;width:1200px" /></div><div style="border:1px solid black;width:510px;height:985px;float:left"><strong>vue3.0的生命周期</strong><img src="https://v3.cn.vuejs.org/images/lifecycle.svg" alt="lifecycle_2" style="zoom:33%;width:2500px" /></div>



































<p>1</p>
<ul>
<li>Vue3.0中可以继续使用Vue2.x中的生命周期钩子，但有有两个被更名：<ul>
<li><code>beforeDestroy</code>改名为 <code>beforeUnmount</code></li>
<li><code>destroyed</code>改名为 <code>unmounted</code></li>
</ul>
</li>
<li>Vue3.0也提供了 Composition API 形式的生命周期钩子，与Vue2.x中钩子对应关系如下：<ul>
<li><code>beforeCreate</code>&#x3D;&#x3D;&#x3D;&gt;<code>setup()</code></li>
<li><code>created</code>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;<code>setup()</code></li>
<li><code>beforeMount</code> &#x3D;&#x3D;&#x3D;&gt;<code>onBeforeMount</code></li>
<li><code>mounted</code>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;<code>onMounted</code></li>
<li><code>beforeUpdate</code>&#x3D;&#x3D;&#x3D;&gt;<code>onBeforeUpdate</code></li>
<li><code>updated</code> &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;<code>onUpdated</code></li>
<li><code>beforeUnmount</code> &#x3D;&#x3D;&gt;<code>onBeforeUnmount</code></li>
<li><code>unmounted</code> &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;<code>onUnmounted</code></li>
</ul>
</li>
</ul>
<h2 id="9-自定义hook函数"><a href="#9-自定义hook函数" class="headerlink" title="9.自定义hook函数"></a>9.自定义hook函数</h2><ul>
<li><p>什么是hook？—— 本质是一个函数，把setup函数中使用的Composition API进行了封装。</p>
</li>
<li><p>类似于vue2.x中的mixin。</p>
</li>
<li><p>自定义hook的优势: 复用代码, 让setup中的逻辑更清楚易懂。</p>
</li>
</ul>
<h2 id="10-toRef"><a href="#10-toRef" class="headerlink" title="10.toRef"></a>10.toRef</h2><ul>
<li><p>作用：创建一个 ref 对象，其value值指向另一个对象中的某个属性。</p>
</li>
<li><p>语法：<code>const name = toRef(person,&#39;name&#39;)</code></p>
</li>
<li><p>应用:   要将响应式对象中的某个属性单独提供给外部使用时。</p>
</li>
<li><p>扩展：<code>toRefs</code> 与<code>toRef</code>功能一致，但可以批量创建多个 ref 对象，语法：<code>toRefs(person)</code></p>
</li>
</ul>
<h1 id="三、其它-Composition-API"><a href="#三、其它-Composition-API" class="headerlink" title="三、其它 Composition API"></a>三、其它 Composition API</h1><h2 id="1-shallowReactive-与-shallowRef"><a href="#1-shallowReactive-与-shallowRef" class="headerlink" title="1.shallowReactive 与 shallowRef"></a>1.shallowReactive 与 shallowRef</h2><ul>
<li><p>shallowReactive：只处理对象最外层属性的响应式（浅响应式）。</p>
</li>
<li><p>shallowRef：只处理基本数据类型的响应式, 不进行对象的响应式处理。</p>
</li>
<li><p>什么时候使用?</p>
<ul>
<li>如果有一个对象数据，结构比较深, 但变化时只是外层属性变化 &#x3D;&#x3D;&#x3D;&gt; shallowReactive。</li>
<li>如果有一个对象数据，后续功能不会修改该对象中的属性，而是生新的对象来替换 &#x3D;&#x3D;&#x3D;&gt; shallowRef。</li>
</ul>
</li>
</ul>
<h2 id="2-readonly-与-shallowReadonly"><a href="#2-readonly-与-shallowReadonly" class="headerlink" title="2.readonly 与 shallowReadonly"></a>2.readonly 与 shallowReadonly</h2><ul>
<li>readonly: 让一个响应式数据变为只读的（深只读）。</li>
<li>shallowReadonly：让一个响应式数据变为只读的（浅只读）。</li>
<li>应用场景: 不希望数据被修改时。</li>
</ul>
<h2 id="3-toRaw-与-markRaw"><a href="#3-toRaw-与-markRaw" class="headerlink" title="3.toRaw 与 markRaw"></a>3.toRaw 与 markRaw</h2><ul>
<li>toRaw：<ul>
<li>作用：将一个由<code>reactive</code>生成的<strong style="color:orange">响应式对象</strong>转为<strong style="color:orange">普通对象</strong>。</li>
<li>使用场景：用于读取响应式对象对应的普通对象，对这个普通对象的所有操作，不会引起页面更新。</li>
</ul>
</li>
<li>markRaw：<ul>
<li>作用：标记一个对象，使其永远不会再成为响应式对象。</li>
<li>应用场景:<ol>
<li>有些值不应被设置为响应式的，例如复杂的第三方类库等。</li>
<li>当渲染具有不可变数据源的大列表时，跳过响应式转换可以提高性能。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="4-customRef"><a href="#4-customRef" class="headerlink" title="4.customRef"></a>4.customRef</h2><ul>
<li><p>作用：创建一个自定义的 ref，并对其依赖项跟踪和更新触发进行显式控制。</p>
</li>
<li><p>实现防抖效果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;input type=&quot;text&quot; v-model=&quot;keyword&quot;&gt;</span><br><span class="line">	&lt;h3&gt;&#123;&#123;keyword&#125;&#125;&lt;/h3&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">	import &#123;ref,customRef&#125; from &#x27;vue&#x27;</span><br><span class="line">	export default &#123;</span><br><span class="line">		name:&#x27;Demo&#x27;,</span><br><span class="line">		setup()&#123;</span><br><span class="line">			// let keyword = ref(&#x27;hello&#x27;) //使用Vue准备好的内置ref</span><br><span class="line">			//自定义一个myRef</span><br><span class="line">			function myRef(value,delay)&#123;</span><br><span class="line">				let timer</span><br><span class="line">				//通过customRef去实现自定义</span><br><span class="line">				return customRef((track,trigger)=&gt;&#123;</span><br><span class="line">					return&#123;</span><br><span class="line">						get()&#123;</span><br><span class="line">							track() //告诉Vue这个value值是需要被“追踪”的</span><br><span class="line">							return value</span><br><span class="line">						&#125;,</span><br><span class="line">						set(newValue)&#123;</span><br><span class="line">							clearTimeout(timer)</span><br><span class="line">							timer = setTimeout(()=&gt;&#123;</span><br><span class="line">								value = newValue</span><br><span class="line">								trigger() //告诉Vue去更新界面</span><br><span class="line">							&#125;,delay)</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;)</span><br><span class="line">			&#125;</span><br><span class="line">			let keyword = myRef(&#x27;hello&#x27;,500) //使用程序员自定义的ref</span><br><span class="line">			return &#123;</span><br><span class="line">				keyword</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="5-provide-与-inject"><a href="#5-provide-与-inject" class="headerlink" title="5.provide 与 inject"></a>5.provide 与 inject</h2><img src="https://v3.cn.vuejs.org/images/components_provide.png" style="width:300px" />

<ul>
<li><p>作用：实现<strong style="color:#DD5145">祖与后代组件间</strong>通信</p>
</li>
<li><p>套路：父组件有一个 <code>provide</code> 选项来提供数据，后代组件有一个 <code>inject</code> 选项来开始使用这些数据</p>
</li>
<li><p>具体写法：</p>
<ol>
<li><p>祖组件中：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">setup</span>(<span class="params"></span>)&#123;</span><br><span class="line">	......</span><br><span class="line">    <span class="keyword">let</span> car = <span class="title function_">reactive</span>(&#123;<span class="attr">name</span>:<span class="string">&#x27;奔驰&#x27;</span>,<span class="attr">price</span>:<span class="string">&#x27;40万&#x27;</span>&#125;)</span><br><span class="line">    <span class="title function_">provide</span>(<span class="string">&#x27;car&#x27;</span>,car)</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>后代组件中：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">setup</span>(<span class="params">props,context</span>)&#123;</span><br><span class="line">	......</span><br><span class="line">    <span class="keyword">const</span> car = <span class="title function_">inject</span>(<span class="string">&#x27;car&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> &#123;car&#125;</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<h2 id="6-响应式数据的判断"><a href="#6-响应式数据的判断" class="headerlink" title="6.响应式数据的判断"></a>6.响应式数据的判断</h2><ul>
<li>isRef: 检查一个值是否为一个 ref 对象</li>
<li>isReactive: 检查一个对象是否是由 <code>reactive</code> 创建的响应式代理</li>
<li>isReadonly: 检查一个对象是否是由 <code>readonly</code> 创建的只读代理</li>
<li>isProxy: 检查一个对象是否是由 <code>reactive</code> 或者 <code>readonly</code> 方法创建的代理</li>
</ul>
<h1 id="四、Composition-API-的优势"><a href="#四、Composition-API-的优势" class="headerlink" title="四、Composition API 的优势"></a>四、Composition API 的优势</h1><h2 id="1-Options-API-存在的问题"><a href="#1-Options-API-存在的问题" class="headerlink" title="1.Options API 存在的问题"></a>1.Options API 存在的问题</h2><p>使用传统OptionsAPI中，新增或者修改一个需求，就需要分别在data，methods，computed里修改 。</p>
<div style="width:600px;height:370px;overflow:hidden;float:left">
    <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f84e4e2c02424d9a99862ade0a2e4114~tplv-k3u1fbpfcp-watermark.image" style="width:600px;float:left" />
</div>
<div style="width:300px;height:370px;overflow:hidden;float:left">
    <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e5ac7e20d1784887a826f6360768a368~tplv-k3u1fbpfcp-watermark.image" style="zoom:50%;width:560px;left" /> 
</div>















<h2 id="2-Composition-API-的优势"><a href="#2-Composition-API-的优势" class="headerlink" title="2.Composition API 的优势"></a>2.Composition API 的优势</h2><p>我们可以更加优雅的组织我们的代码，函数。让相关功能的代码更加有序的组织在一起。</p>
<div style="width:500px;height:340px;overflow:hidden;float:left">
    <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bc0be8211fc54b6c941c036791ba4efe~tplv-k3u1fbpfcp-watermark.image"style="height:360px"/>
</div>
<div style="width:430px;height:340px;overflow:hidden;float:left">
    <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6cc55165c0e34069a75fe36f8712eb80~tplv-k3u1fbpfcp-watermark.image"style="height:360px"/>
</div>













<h1 id="五、新的组件"><a href="#五、新的组件" class="headerlink" title="五、新的组件"></a>五、新的组件</h1><h2 id="1-Fragment"><a href="#1-Fragment" class="headerlink" title="1.Fragment"></a>1.Fragment</h2><ul>
<li>在Vue2中: 组件必须有一个根标签</li>
<li>在Vue3中: 组件可以没有根标签, 内部会将多个标签包含在一个Fragment虚拟元素中</li>
<li>好处: 减少标签层级, 减小内存占用</li>
</ul>
<h2 id="2-Teleport"><a href="#2-Teleport" class="headerlink" title="2.Teleport"></a>2.Teleport</h2><ul>
<li><p>什么是Teleport？—— <code>Teleport</code> 是一种能够将我们的<strong style="color:#DD5145">组件html结构</strong>移动到指定位置的技术。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;teleport to=&quot;移动位置&quot;&gt;</span><br><span class="line">	&lt;div v-if=&quot;isShow&quot; class=&quot;mask&quot;&gt;</span><br><span class="line">		&lt;div class=&quot;dialog&quot;&gt;</span><br><span class="line">			&lt;h3&gt;我是一个弹窗&lt;/h3&gt;</span><br><span class="line">			&lt;button @click=&quot;isShow = false&quot;&gt;关闭弹窗&lt;/button&gt;</span><br><span class="line">		&lt;/div&gt;</span><br><span class="line">	&lt;/div&gt;</span><br><span class="line">&lt;/teleport&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="3-Suspense"><a href="#3-Suspense" class="headerlink" title="3.Suspense"></a>3.Suspense</h2><ul>
<li><p>等待异步组件时渲染一些额外内容，让应用有更好的用户体验</p>
</li>
<li><p>使用步骤：</p>
<ul>
<li><p>异步引入组件</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;defineAsyncComponent&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Child</span> = <span class="title function_">defineAsyncComponent</span>(<span class="function">()=&gt;</span><span class="title function_">import</span>(<span class="string">&#x27;./components/Child.vue&#x27;</span>))</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>Suspense</code>包裹组件，并配置好<code>default</code> 与 <code>fallback</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;div class=&quot;app&quot;&gt;</span><br><span class="line">		&lt;h3&gt;我是App组件&lt;/h3&gt;</span><br><span class="line">		&lt;Suspense&gt;</span><br><span class="line">			&lt;template v-slot:default&gt;</span><br><span class="line">				&lt;Child/&gt;</span><br><span class="line">			&lt;/template&gt;</span><br><span class="line">			&lt;template v-slot:fallback&gt;</span><br><span class="line">				&lt;h3&gt;加载中.....&lt;/h3&gt;</span><br><span class="line">			&lt;/template&gt;</span><br><span class="line">		&lt;/Suspense&gt;</span><br><span class="line">	&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h1 id="六、其他"><a href="#六、其他" class="headerlink" title="六、其他"></a>六、其他</h1><h2 id="1-全局API的转移"><a href="#1-全局API的转移" class="headerlink" title="1.全局API的转移"></a>1.全局API的转移</h2><ul>
<li><p>Vue 2.x 有许多全局 API 和配置。</p>
<ul>
<li><p>例如：注册全局组件、注册全局指令等。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注册全局组件</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;MyButton&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">data</span>: <span class="function">() =&gt;</span> (&#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="attr">template</span>: <span class="string">&#x27;&lt;button @click=&quot;count++&quot;&gt;Clicked &#123;&#123; count &#125;&#125; times.&lt;/button&gt;&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//注册全局指令</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">directive</span>(<span class="string">&#x27;focus&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">inserted</span>: <span class="function"><span class="params">el</span> =&gt;</span> el.<span class="title function_">focus</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>Vue3.0中对这些API做出了调整：</p>
<ul>
<li><p>将全局的API，即：<code>Vue.xxx</code>调整到应用实例（<code>app</code>）上</p>
<table>
<thead>
<tr>
<th>2.x 全局 API（<code>Vue</code>）</th>
<th>3.x 实例 API (<code>app</code>)</th>
</tr>
</thead>
<tbody><tr>
<td>Vue.config.xxxx</td>
<td>app.config.xxxx</td>
</tr>
<tr>
<td>Vue.config.productionTip</td>
<td><strong style="color:#DD5145">移除</strong></td>
</tr>
<tr>
<td>Vue.component</td>
<td>app.component</td>
</tr>
<tr>
<td>Vue.directive</td>
<td>app.directive</td>
</tr>
<tr>
<td>Vue.mixin</td>
<td>app.mixin</td>
</tr>
<tr>
<td>Vue.use</td>
<td>app.use</td>
</tr>
<tr>
<td>Vue.prototype</td>
<td>app.config.globalProperties</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
<h2 id="2-其他改变"><a href="#2-其他改变" class="headerlink" title="2.其他改变"></a>2.其他改变</h2><ul>
<li><p>data选项应始终被声明为一个函数。</p>
</li>
<li><p>过度类名的更改：</p>
<ul>
<li><p>Vue2.x写法</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.v-enter</span>,</span><br><span class="line"><span class="selector-class">.v-leave-to</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.v-leave</span>,</span><br><span class="line"><span class="selector-class">.v-enter-to</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Vue3.x写法</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.v-enter-from</span>,</span><br><span class="line"><span class="selector-class">.v-leave-to</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.v-leave-from</span>,</span><br><span class="line"><span class="selector-class">.v-enter-to</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong style="color:#DD5145">移除</strong>keyCode作为 v-on 的修饰符，同时也不再支持<code>config.keyCodes</code></p>
</li>
<li><p><strong style="color:#DD5145">移除</strong><code>v-on.native</code>修饰符</p>
<ul>
<li><p>父组件中绑定事件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;my-component</span><br><span class="line">  v-on:close=&quot;handleComponentEvent&quot;</span><br><span class="line">  v-on:click=&quot;handleNativeClickEvent&quot;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>子组件中声明自定义事件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    emits: [&#x27;close&#x27;]</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong style="color:#DD5145">移除</strong>过滤器（filter）</p>
<blockquote>
<p>过滤器虽然这看起来很方便，但它需要一个自定义语法，打破大括号内表达式是 “只是 JavaScript” 的假设，这不仅有学习成本，而且有实现成本！建议用方法调用或计算属性去替换过滤器。</p>
</blockquote>
</li>
<li><p>……</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/11/01/vue3%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/" data-id="claxeer9s000jv8w1bwuw0u0n" data-title="vue3快速上手" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-9-总结-常见问题解答" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/10/29/9-%E6%80%BB%E7%BB%93-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E8%A7%A3%E7%AD%94/" class="article-date">
  <time class="dt-published" datetime="2022-10-29T12:14:13.000Z" itemprop="datePublished">2022-10-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/10/29/9-%E6%80%BB%E7%BB%93-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E8%A7%A3%E7%AD%94/">9.总结 &amp; 常见问题解答</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在本小册的第一节中，笔者对 Vue.js 内部运行机制做了一个全局的概览，当时通过下面这张图把 Vue.js 拆分成一个一个小模块来介绍，之后通过这一系列小节的学习，相信大家已经对 Vue.js 内部的原理有了一个更进一步的了解，对这张图也再也不会感觉到那么陌生。</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/12/19/1606e7eaa2a664e8~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp"></p>
<p>每个小节中的代码都是笔者根据 Vue.js 原理单独抽离出来写成的 Demo，大家可以在我的 <a href="https://link.juejin.cn/?target=https://github.com/answershuto" title="https://github.com/answershuto">Gtihub</a> 上查看完整的代码 (见 <a href="https://link.juejin.cn/?target=https://github.com/answershuto/VueDemo" title="https://github.com/answershuto/VueDemo">VueDemo</a> 项目)。</p>
<p>本小册对 Vue.js 原理进行了初步的介绍，希望能够起到一个抛砖引玉的作用，读者读完以后，可以利用这些基础对 Vue.js 进行一个更加深入的探索，相信会有更大的收获。</p>
<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><ol>
<li>怎么实现 <code>this._test</code> 改变而不是 <code>this._data.test</code> 改变触发更新？</li>
</ol>
<p>答：其实这中间有一个<strong>代理</strong>的过程。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">_proxy</span>(options.<span class="property">data</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">_proxy</span> (data) &#123;</span><br><span class="line">    <span class="keyword">const</span> that = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">keys</span>(data).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(that, key, &#123;</span><br><span class="line">            <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">get</span>: <span class="keyword">function</span> <span class="title function_">proxyGetter</span> () &#123;</span><br><span class="line">                <span class="keyword">return</span> that.<span class="property">_data</span>[key];</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">set</span>: <span class="keyword">function</span> <span class="title function_">proxySetter</span> (val) &#123;</span><br><span class="line">                that.<span class="property">_data</span>[key] = val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本质就是通过 <code>Object.defineProperty</code> 使在访问 <code>this</code> 上的某属性时从 <code>this._data</code> 中读取（写入）。</p>
<ol start="2">
<li>能不能将依赖收集中讲到的 <code>dep.addSub(Dep.target)</code> 改成 <code>dep.addSub(new Watcher())</code>呢？</li>
</ol>
<p>为了便于读者理解这部分内容，我将代码做了简化，实际上一个 <code>Watcher</code> 对象可能会在多个 <code>Dep</code> 中，并不是每次 <code>addSub</code> 都是一个新的 <code>Watcher</code> 对象，需依赖 <code>Dep.target</code> 进行收集（实际上 <code>Dep.target</code> 也是通过 <code>Watcher</code> 对象的 <code>get</code> 方法调用 <code>pushTarget</code> 将自身赋值给 <code>Dep.target</code>）。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>从 2017 年 12 月开始写这本小册到现在差不多 2 个月的时间，虽说之前写过类似的内容，但是将 Vue.js 源码抽离成一个一个 Demo 还是花了很多时间，对于这本小册也是前前后后改了好几次才让自己满意。</p>
<p>因为读者的基础不一致，而小册的定位是偏向于对新手读者更加友好，所以我尽量用更加浅显易懂的方式去写这本小册的内容。希望大家可以通过这本小册初步掌握 Vue.js 的原理，掌握这些原理以后再去尝试阅读 <a href="https://link.juejin.cn/?target=https://github.com/vuejs/vue" title="https://github.com/vuejs/vue">Vue.js 源码</a>，相信会事半功倍，也会对 Vue.js 有更深一层的理解。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/10/29/9-%E6%80%BB%E7%BB%93-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E8%A7%A3%E7%AD%94/" data-id="claxeer9o000av8w13zddhxad" data-title="9.总结 &amp; 常见问题解答" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-8-Vuex-状态管理的工作原理" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/10/29/8-Vuex-%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/" class="article-date">
  <time class="dt-published" datetime="2022-10-29T12:13:59.000Z" itemprop="datePublished">2022-10-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/10/29/8-Vuex-%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/">8.Vuex 状态管理的工作原理</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="为什么要使用-Vuex"><a href="#为什么要使用-Vuex" class="headerlink" title="为什么要使用 Vuex"></a>为什么要使用 Vuex</h2><p>当我们使用 Vue.js 来开发一个单页应用时，经常会遇到一些组件间共享的数据或状态，或是需要通过 props 深层传递的一些数据。在应用规模较小的时候，我们会使用 props、事件等常用的父子组件的组件间通信方法，或者是通过事件总线来进行任意两个组件的通信。但是当应用逐渐复杂后，问题就开始出现了，这样的通信方式会导致数据流异常地混乱。</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/2/9/1617a011064cc43e~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp"></p>
<p>这个时候，我们就需要用到我们的状态管理工具 Vuex 了。Vuex 是一个专门为 Vue.js 框架设计的、专门用来对于 Vue.js 应用进行状态管理的库。它借鉴了 Flux、redux 的基本思想，将状态抽离到全局，形成一个 Store。因为 Vuex 内部采用了 new Vue 来将 Store 内的数据进行「响应式化」，所以 Vuex 是一款利用 Vue 内部机制的库，与 Vue 高度契合，与 Vue 搭配使用显得更加简单高效，但缺点是不能与其他的框架（如 react）配合使用。</p>
<p>本节将简单介绍 Vuex 最核心的内部机制，起个抛砖引玉的作用，想了解更多细节可以参考笔者 <a href="https://link.juejin.cn/?target=https://github.com/answershuto" title="https://github.com/answershuto">Github</a> 上的另一篇文章 <a href="https://link.juejin.cn/?target=https://github.com/answershuto/learnVue/blob/master/docs/Vuex%25E6%25BA%2590%25E7%25A0%2581%25E8%25A7%25A3%25E6%259E%2590.MarkDown" title="https://github.com/answershuto/learnVue/blob/master/docs/Vuex%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.MarkDown">《Vuex源码解析》</a>或者直接阅读 <a href="https://link.juejin.cn/?target=https://github.com/vuejs/vuex" title="https://github.com/vuejs/vuex">Vuex源码</a>。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>Vue.js 提供了一个 <code>Vue.use</code> 的方法来安装插件，内部会调用插件提供的 <code>install</code> 方法。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.use(Vuex)<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>所以我们的插件需要提供一个 <code>install</code> 方法来安装。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let Vue<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">export default install (_Vue) &#123;</span><br><span class="line">    Vue.mixin(&#123; beforeCreate: vuexInit &#125;)<span class="comment">;</span></span><br><span class="line">    <span class="attr">Vue</span> = _Vue<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们采用 <code>Vue.mixin</code> 方法将 <code>vuexInit</code> 方法混淆进 <code>beforeCreate</code> 钩子中，并用 <code>Vue</code> 保存 Vue 对象。那么 <code>vuexInit</code> 究竟实现了什么呢？</p>
<p>我们知道，在使用 Vuex 的时候，我们需要将 <code>store</code> 传入到 Vue 实例中去。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*将store放入Vue创建时的option中*/</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Vue</span>(&#123;</span><br><span class="line">    el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    store</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>但是我们却在每一个 vm 中都可以访问该 <code>store</code>，这个就需要靠 <code>vuexInit</code> 了。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function vuexInit () &#123;</span><br><span class="line">    const <span class="attr">options</span> = this.<span class="variable">$options</span><span class="comment">;</span></span><br><span class="line">    if (options.store) &#123;</span><br><span class="line">        this.$<span class="attr">store</span> = options.store<span class="comment">;</span></span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        this.$<span class="attr">store</span> = options.parent.<span class="variable">$store</span><span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为之前已经用<code>Vue.mixin</code> 方法将 <code>vuexInit</code> 方法混淆进 <code>beforeCreate</code> 钩子中，所以每一个 vm 实例都会调用 <code>vuexInit</code> 方法。</p>
<p>如果是根节点（<code>$options</code>中存在 <code>store</code> 说明是根节点），则直接将 <code>options.store</code> 赋值给 <code>this.$store</code>。否则则说明不是根节点，从父节点的 <code>$store</code> 中获取。</p>
<p>通过这步的操作，我们已经可以在任意一个 vm 中通过 <code>this.$store</code> 来访问 <code>Store</code> 的实例啦～</p>
<h2 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h2><h3 id="数据的响应式化"><a href="#数据的响应式化" class="headerlink" title="数据的响应式化"></a>数据的响应式化</h3><p>首先我们需要在 <code>Store</code> 的构造函数中对 <code>state</code> 进行「响应式化」。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constructor</span> () &#123;</span><br><span class="line">    <span class="keyword">this</span>._vm = new Vue(&#123;</span><br><span class="line">        <span class="keyword">data</span>: &#123;</span><br><span class="line">            ?state: <span class="keyword">this</span>.state</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>熟悉「响应式」的同学肯定知道，这个步骤以后，<code>state</code> 会将需要的依赖收集在 <code>Dep</code> 中，在被修改时更新对应视图。我们来看一个小例子。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">let <span class="attr">globalData</span> = &#123;</span><br><span class="line">    d: &#x27;hello world&#x27;</span><br><span class="line">&#125;<span class="comment">;</span></span><br><span class="line">new Vue(&#123;</span><br><span class="line">    data () &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            ?state: &#123;</span><br><span class="line">                globalData</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">/* modify */</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">    <span class="attr">globalData.d</span> = <span class="string">&#x27;hi~&#x27;</span><span class="comment">;</span></span><br><span class="line">&#125;, 1000)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Vue.prototype.globalData</span> = globalData<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>任意模板中</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">div</span>&gt;&#123;&#123;globalData<span class="selector-class">.d</span>&#125;&#125;&lt;/<span class="selector-tag">div</span>&gt;</span><br></pre></td></tr></table></figure>

<p>上述代码在全局有一个 <code>globalData</code>，它被传入一个 <code>Vue</code> 对象的 <code>data</code> 中，之后在任意 Vue 模板中对该变量进行展示，因为此时 <code>globalData</code> 已经在 Vue 的 <code>prototype</code> 上了所以直接通过 <code>this.prototype</code> 访问，也就是在模板中的 <code>&#123;&#123;globalData.d&#125;&#125;</code>。此时，<code>setTimeout</code> 在 1s 之后将 <code>globalData.d</code> 进行修改，我们发现模板中的 <code>globalData.d</code> 发生了变化。其实上述部分就是 Vuex 依赖 Vue 核心实现数据的“响应式化”。</p>
<p>讲完了 Vuex 最核心的通过 Vue 进行数据的「响应式化」，接下来我们再来介绍两个 <code>Store</code> 的 API。</p>
<h3 id="commit"><a href="#commit" class="headerlink" title="commit"></a>commit</h3><p>首先是 <code>commit</code> 方法，我们知道 <code>commit</code> 方法是用来触发 <code>mutation</code> 的。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">commit (type, payload, _options) &#123;</span><br><span class="line">    const <span class="attr">entry</span> = this._mutations[type]<span class="comment">;</span></span><br><span class="line">    entry.forEach(function commitIterator (handler) &#123;</span><br><span class="line">        handler(payload)<span class="comment">;</span></span><br><span class="line">    &#125;)<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从 <code>_mutations</code> 中取出对应的 mutation，循环执行其中的每一个 mutation。</p>
<h3 id="dispatch"><a href="#dispatch" class="headerlink" title="dispatch"></a>dispatch</h3><p><code>dispatch</code> 同样道理，用于触发 action，可以包含异步状态。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dispatch (type, payload) &#123;</span><br><span class="line">    const <span class="attr">entry</span> = this._actions[type]<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    return entry.length &gt; 1</span><br><span class="line">    ? Promise.all(entry.map(<span class="attr">handler</span> =&gt; handler(payload)))</span><br><span class="line">    : entry<span class="section">[0]</span>(payload)<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样的，取出 <code>_actions</code> 中的所有对应 action，将其执行，如果有多个则用 <code>Promise.all</code> 进行包装。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>理解 Vuex 的核心在于理解其如何与 Vue 本身结合，如何利用 Vue 的响应式机制来实现核心 Store 的「响应式化」。</p>
<p>Vuex 本身代码不多且设计优雅，非常值得一读，想阅读源码的同学请看<a href="https://link.juejin.cn/?target=https://github.com/vuejs/vuex" title="https://github.com/vuejs/vuex">Vuex源码</a>。</p>
<p>注：本节代码参考<a href="https://link.juejin.cn/?target=https://github.com/answershuto/VueDemo/blob/master/%25E3%2580%258AVuex%25E7%258A%25B6%25E6%2580%2581%25E7%25AE%25A1%25E7%2590%2586%25E7%259A%2584%25E5%25B7%25A5%25E4%25BD%259C%25E5%258E%259F%25E7%2590%2586%25E3%2580%258B.js" title="https://github.com/answershuto/VueDemo/blob/master/%E3%80%8AVuex%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E3%80%8B.js">《Vuex状态管理的工作原理》</a>。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/10/29/8-Vuex-%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/" data-id="claxeer9m0007v8w1hq5ra747" data-title="8.Vuex 状态管理的工作原理" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-7-批量异步更新策略及-nextTick-原理" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/10/29/7-%E6%89%B9%E9%87%8F%E5%BC%82%E6%AD%A5%E6%9B%B4%E6%96%B0%E7%AD%96%E7%95%A5%E5%8F%8A-nextTick-%E5%8E%9F%E7%90%86/" class="article-date">
  <time class="dt-published" datetime="2022-10-29T12:13:45.000Z" itemprop="datePublished">2022-10-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/10/29/7-%E6%89%B9%E9%87%8F%E5%BC%82%E6%AD%A5%E6%9B%B4%E6%96%B0%E7%AD%96%E7%95%A5%E5%8F%8A-nextTick-%E5%8E%9F%E7%90%86/">7.批量异步更新策略及 nextTick 原理</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="为什么要异步更新"><a href="#为什么要异步更新" class="headerlink" title="为什么要异步更新"></a>为什么要异步更新</h2><p>通过前面几个章节我们介绍，相信大家已经明白了 Vue.js 是如何在我们修改 <code>data</code> 中的数据后修改视图了。简单回顾一下，这里面其实就是一个“<code>setter -&gt; Dep -&gt; Watcher -&gt; patch -&gt; 视图</code>”的过程。</p>
<p>假设我们有如下这么一种情况。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;number&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> @<span class="attr">click</span>=<span class="string">&quot;handleClick&quot;</span>&gt;</span>click<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">    data () &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            number: <span class="number">0</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        handleClick () &#123;</span><br><span class="line">            for(let <span class="selector-tag">i</span> = <span class="number">0</span>; <span class="selector-tag">i</span> &lt; <span class="number">1000</span>; <span class="selector-tag">i</span>++) &#123;</span><br><span class="line">                this<span class="selector-class">.number</span>++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们按下 click 按钮的时候，<code>number</code> 会被循环增加1000次。</p>
<p>那么按照之前的理解，每次 <code>number</code> 被 +1 的时候，都会触发 <code>number</code> 的 <code>setter</code> 方法，从而根据上面的流程一直跑下来最后修改真实 DOM。那么在这个过程中，DOM 会被更新 1000 次！太可怕了。</p>
<p>Vue.js 肯定不会以如此低效的方法来处理。Vue.js在默认情况下，每次触发某个数据的 <code>setter</code> 方法后，对应的 <code>Watcher</code> 对象其实会被 <code>push</code> 进一个队列 <code>queue</code> 中，在下一个 tick 的时候将这个队列 <code>queue</code> 全部拿出来 <code>run</code>（ <code>Watcher</code> 对象的一个方法，用来触发 <code>patch</code> 操作） 一遍。</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/1/24/161285d6b2d9e6bd~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp"></p>
<p>那么什么是下一个 tick 呢？</p>
<h2 id="nextTick"><a href="#nextTick" class="headerlink" title="nextTick"></a>nextTick</h2><p>Vue.js 实现了一个 <code>nextTick</code> 函数，传入一个 <code>cb</code> ，这个 <code>cb</code> 会被存储到一个队列中，在下一个 tick 时触发队列中的所有 <code>cb</code> 事件。</p>
<p>因为目前浏览器平台并没有实现 <code>nextTick</code> 方法，所以 Vue.js 源码中分别用 <code>Promise</code>、<code>setTimeout</code>、<code>setImmediate</code> 等方式在 microtask（或是task）中创建一个事件，目的是在当前调用栈执行完毕以后（不一定立即）才会去执行这个事件。</p>
<p>笔者用 <code>setTimeout</code> 来模拟这个方法，当然，真实的源码中会更加复杂，笔者在小册中只讲原理，有兴趣了解源码中 <code>nextTick</code> 的具体实现的同学可以参考<a href="https://link.juejin.cn/?target=https://github.com/vuejs/vue/blob/dev/src/core/util/next-tick.js%23L90" title="https://github.com/vuejs/vue/blob/dev/src/core/util/next-tick.js#L90">next-tick</a>。</p>
<p>首先定义一个 <code>callbacks</code> 数组用来存储 <code>nextTick</code>，在下一个 tick 处理这些回调函数之前，所有的 <code>cb</code> 都会被存在这个 <code>callbacks</code> 数组中。<code>pending</code> 是一个标记位，代表一个等待的状态。</p>
<p><code>setTimeout</code> 会在 task 中创建一个事件 <code>flushCallbacks</code> ，<code>flushCallbacks</code> 则会在执行时将 <code>callbacks</code> 中的所有 <code>cb</code> 依次执行。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">let <span class="attr">callbacks</span> = []<span class="comment">;</span></span><br><span class="line">let <span class="attr">pending</span> = <span class="literal">false</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">function nextTick (cb) &#123;</span><br><span class="line">    callbacks.push(cb)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    if (!pending) &#123;</span><br><span class="line">        <span class="attr">pending</span> = <span class="literal">true</span><span class="comment">;</span></span><br><span class="line">        setTimeout(flushCallbacks, 0)<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function flushCallbacks () &#123;</span><br><span class="line">    <span class="attr">pending</span> = <span class="literal">false</span><span class="comment">;</span></span><br><span class="line">    const <span class="attr">copies</span> = callbacks.slice(<span class="number">0</span>)<span class="comment">;</span></span><br><span class="line">    <span class="attr">callbacks.length</span> = <span class="number">0</span><span class="comment">;</span></span><br><span class="line">    for (let <span class="attr">i</span> = <span class="number">0</span><span class="comment">; i &lt; copies.length; i++) &#123;</span></span><br><span class="line">        copies<span class="section">[i]</span>()<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="再写-Watcher"><a href="#再写-Watcher" class="headerlink" title="再写 Watcher"></a>再写 Watcher</h2><p>第一个例子中，当我们将 <code>number</code> 增加 1000 次时，先将对应的 <code>Watcher</code> 对象给 <code>push</code> 进一个队列 <code>queue</code> 中去，等下一个 tick 的时候再去执行，这样做是对的。但是有没有发现，另一个问题出现了？</p>
<p>因为 <code>number</code> 执行 ++ 操作以后对应的 <code>Watcher</code> 对象都是同一个，我们并不需要在下一个 tick 的时候执行 1000 个同样的 <code>Watcher</code> 对象去修改界面，而是只需要执行一个 <code>Watcher</code> 对象，使其将界面上的 0 变成 1000 即可。</p>
<p>那么，我们就需要执行一个过滤的操作，同一个的 <code>Watcher</code> 在同一个 tick 的时候应该只被执行一次，也就是说队列 <code>queue</code> 中不应该出现重复的 <code>Watcher</code> 对象。</p>
<p>那么我们给 <code>Watcher</code> 对象起个名字吧～用 <code>id</code> 来标记每一个 <code>Watcher</code> 对象，让他们看起来“不太一样”。</p>
<p>实现 <code>update</code> 方法，在修改数据后由 <code>Dep</code> 来调用， 而 <code>run</code> 方法才是真正的触发 <code>patch</code> 更新视图的方法。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">let uid = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Watcher</span> &#123;</span><br><span class="line">    <span class="keyword">constructor</span> () &#123;</span><br><span class="line">        <span class="keyword">this</span>.id = ++uid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    update () &#123;</span><br><span class="line">        console.log(<span class="string">&#x27;watch&#x27;</span> + <span class="keyword">this</span>.id + <span class="string">&#x27; update&#x27;</span>);</span><br><span class="line">        queueWatcher(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    run () &#123;</span><br><span class="line">        console.log(<span class="string">&#x27;watch&#x27;</span> + <span class="keyword">this</span>.id + <span class="string">&#x27;视图更新啦～&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="queueWatcher"><a href="#queueWatcher" class="headerlink" title="queueWatcher"></a>queueWatcher</h2><p>不知道大家注意到了没有？笔者已经将 <code>Watcher</code> 的 <code>update</code> 中的实现改成了</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">queueWatcher(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure>

<p>将 <code>Watcher</code> 对象自身传递给 <code>queueWatcher</code> 方法。</p>
<p>我们来实现一下 <code>queueWatcher</code> 方法。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">let <span class="attr">has</span> = &#123;&#125;<span class="comment">;</span></span><br><span class="line">let <span class="attr">queue</span> = []<span class="comment">;</span></span><br><span class="line">let <span class="attr">waiting</span> = <span class="literal">false</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">function queueWatcher(watcher) &#123;</span><br><span class="line">    const <span class="attr">id</span> = watcher.id<span class="comment">;</span></span><br><span class="line">    if (has<span class="section">[id]</span> == null) &#123;</span><br><span class="line">        has<span class="section">[id]</span> = true<span class="comment">;</span></span><br><span class="line">        queue.push(watcher)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">        if (!waiting) &#123;</span><br><span class="line">            <span class="attr">waiting</span> = <span class="literal">true</span><span class="comment">;</span></span><br><span class="line">            nextTick(flushSchedulerQueue)<span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们使用一个叫做 <code>has</code> 的 map，里面存放 id -&gt; true ( false ) 的形式，用来判断是否已经存在相同的 <code>Watcher</code> 对象 （这样比每次都去遍历 <code>queue</code> 效率上会高很多）。</p>
<p>如果目前队列 <code>queue</code> 中还没有这个 <code>Watcher</code> 对象，则该对象会被 <code>push</code> 进队列 <code>queue</code> 中去。</p>
<p><code>waiting</code> 是一个标记位，标记是否已经向 <code>nextTick</code> 传递了 <code>flushSchedulerQueue</code> 方法，在下一个 tick 的时候执行 <code>flushSchedulerQueue</code> 方法来 flush 队列 <code>queue</code>，执行它里面的所有 <code>Watcher</code> 对象的 <code>run</code> 方法。</p>
<h2 id="flushSchedulerQueue"><a href="#flushSchedulerQueue" class="headerlink" title="flushSchedulerQueue"></a>flushSchedulerQueue</h2><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function flushSchedulerQueue () &#123;</span><br><span class="line">    let watcher, id<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    for (<span class="attr">index</span> = <span class="number">0</span><span class="comment">; index &lt; queue.length; index++) &#123;</span></span><br><span class="line">        <span class="attr">watcher</span> = queue[index]<span class="comment">;</span></span><br><span class="line">        <span class="attr">id</span> = watcher.id<span class="comment">;</span></span><br><span class="line">        has<span class="section">[id]</span> = null<span class="comment">;</span></span><br><span class="line">        watcher.run()<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="attr">waiting</span>  = <span class="literal">false</span><span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h2><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let <span class="attr">watch1</span> = new Watcher()<span class="comment">;</span></span><br><span class="line">let <span class="attr">watch2</span> = new Watcher()<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">watch1.update()<span class="comment">;</span></span><br><span class="line">watch1.update()<span class="comment">;</span></span><br><span class="line">watch2.update()<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>我们现在 new 了两个 <code>Watcher</code> 对象，因为修改了 <code>data</code> 的数据，所以我们模拟触发了两次 <code>watch1</code> 的 <code>update</code> 以及 一次 <code>watch2</code> 的 <code>update</code>。</p>
<p>假设没有批量异步更新策略的话，理论上应该执行 <code>Watcher</code> 对象的 <code>run</code>，那么会打印。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">watch1 <span class="keyword">update</span></span><br><span class="line">watch1视图更新啦～</span><br><span class="line">watch1 <span class="keyword">update</span></span><br><span class="line">watch1视图更新啦～</span><br><span class="line">watch2 <span class="keyword">update</span></span><br><span class="line">watch2视图更新啦～</span><br></pre></td></tr></table></figure>

<p>实际上则执行</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">watch1 <span class="keyword">update</span></span><br><span class="line">watch1 <span class="keyword">update</span></span><br><span class="line">watch2 <span class="keyword">update</span></span><br><span class="line">watch1视图更新啦～</span><br><span class="line">watch2视图更新啦～</span><br></pre></td></tr></table></figure>

<p>这就是异步更新策略的效果，相同的 <code>Watcher</code> 对象会在这个过程中被剔除，在下一个 tick 的时候去更新视图，从而达到对我们第一个例子的优化。</p>
<p>我们再回过头聊一下第一个例子， <code>number</code> 会被不停地进行 <code>++</code> 操作，不断地触发它对应的 <code>Dep</code> 中的 <code>Watcher</code> 对象的 <code>update</code> 方法。然后最终 <code>queue</code> 中因为对相同 <code>id</code> 的 <code>Watcher</code> 对象进行了筛选，从而 <code>queue</code> 中实际上只会存在一个 <code>number</code> 对应的 <code>Watcher</code> 对象。在下一个 tick 的时候（此时 <code>number</code> 已经变成了 1000），触发 <code>Watcher</code> 对象的 <code>run</code> 方法来更新视图，将视图上的 <code>number</code> 从 0 直接变成 1000。</p>
<p>到这里，批量异步更新策略及 nextTick 原理已经讲完了，接下来让我们学习一下 Vuex 状态管理的工作原理。</p>
<p>注：本节代码参考<a href="https://link.juejin.cn/?target=https://github.com/answershuto/VueDemo/blob/master/%25E3%2580%258A%25E6%2589%25B9%25E9%2587%258F%25E5%25BC%2582%25E6%25AD%25A5%25E6%259B%25B4%25E6%2596%25B0%25E7%25AD%2596%25E7%2595%25A5%25E5%258F%258A%2520nextTick%2520%25E5%258E%259F%25E7%2590%2586%25E3%2580%258B.js" title="https://github.com/answershuto/VueDemo/blob/master/%E3%80%8A%E6%89%B9%E9%87%8F%E5%BC%82%E6%AD%A5%E6%9B%B4%E6%96%B0%E7%AD%96%E7%95%A5%E5%8F%8A%20nextTick%20%E5%8E%9F%E7%90%86%E3%80%8B.js">《批量异步更新策略及 nextTick 原理》</a>。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/10/29/7-%E6%89%B9%E9%87%8F%E5%BC%82%E6%AD%A5%E6%9B%B4%E6%96%B0%E7%AD%96%E7%95%A5%E5%8F%8A-nextTick-%E5%8E%9F%E7%90%86/" data-id="claxeer9l0006v8w1drxv6uqj" data-title="7.批量异步更新策略及 nextTick 原理" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-6-数据状态更新时的差异-diff-及-patch-机制" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/10/29/6-%E6%95%B0%E6%8D%AE%E7%8A%B6%E6%80%81%E6%9B%B4%E6%96%B0%E6%97%B6%E7%9A%84%E5%B7%AE%E5%BC%82-diff-%E5%8F%8A-patch-%E6%9C%BA%E5%88%B6/" class="article-date">
  <time class="dt-published" datetime="2022-10-29T12:13:31.000Z" itemprop="datePublished">2022-10-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/10/29/6-%E6%95%B0%E6%8D%AE%E7%8A%B6%E6%80%81%E6%9B%B4%E6%96%B0%E6%97%B6%E7%9A%84%E5%B7%AE%E5%BC%82-diff-%E5%8F%8A-patch-%E6%9C%BA%E5%88%B6/">6.数据状态更新时的差异 diff 及 patch 机制</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="数据更新视图"><a href="#数据更新视图" class="headerlink" title="数据更新视图"></a>数据更新视图</h2><p>之前讲到，在对 <code>model</code> 进行操作对时候，会触发对应 <code>Dep</code> 中的 <code>Watcher</code> 对象。<code>Watcher</code> 对象会调用对应的 <code>update</code> 来修改视图。最终是将新产生的 VNode 节点与老 VNode 进行一个 <code>patch</code> 的过程，比对得出「差异」，最终将这些「差异」更新到视图上。</p>
<p>这一章就来介绍一下这个 <code>patch</code> 的过程，因为 <code>patch</code> 过程本身比较复杂，这一章的内容会比较多，但是不要害怕，我们逐块代码去看，一定可以理解。</p>
<h2 id="跨平台"><a href="#跨平台" class="headerlink" title="跨平台"></a>跨平台</h2><p>因为使用了 Virtual DOM 的原因，Vue.js具有了跨平台的能力，Virtual DOM 终归只是一些 JavaScript 对象罢了，那么最终是如何调用不同平台的 API 的呢？</p>
<p>这就需要依赖一层适配层了，将不同平台的 API 封装在内，以同样的接口对外提供。</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">const nodeOps = &#123;</span><br><span class="line">    setTextContent (text) &#123;</span><br><span class="line">        if (platform === &#x27;weex&#x27;) &#123;</span><br><span class="line">            node<span class="selector-class">.parentNode</span><span class="selector-class">.setAttr</span>(&#x27;value&#x27;, text);</span><br><span class="line">        &#125; else if (platform === &#x27;web&#x27;) &#123;</span><br><span class="line">            node<span class="selector-class">.textContent</span> = text;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    parentNode () &#123;</span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">    &#125;,</span><br><span class="line">    removeChild () &#123;</span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">    &#125;,</span><br><span class="line">    nextSibling () &#123;</span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">    &#125;,</span><br><span class="line">    insertBefore () &#123;</span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>举个例子，现在我们有上述一个 <code>nodeOps</code> 对象做适配，根据 platform 区分不同平台来执行当前平台对应的API，而对外则是提供了一致的接口，供 Virtual DOM 来调用。</p>
<h2 id="一些API"><a href="#一些API" class="headerlink" title="一些API"></a>一些API</h2><p>接下来我们来介绍其他的一些 API，这些API在下面 <code>patch</code> 的过程中会被用到，他们最终都会调用 <code>nodeOps</code> 中的相应函数来操作平台。</p>
<p><code>insert</code> 用来在 <code>parent</code> 这个父节点下插入一个子节点，如果指定了 <code>ref</code> 则插入到 <code>ref</code> 这个子节点前面。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">insert</span> (<span class="params">parent, elm, <span class="keyword">ref</span></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (parent) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">ref</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">ref</span>.parentNode === parent) &#123;</span><br><span class="line">                nodeOps.insertBefore(parent, elm, <span class="keyword">ref</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nodeOps.appendChild(parent, elm)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>createElm</code> 用来新建一个节点， <code>tag</code> 存在创建一个标签节点，否则创建一个文本节点。</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function createElm (vnode, parentElm, refElm) &#123;</span><br><span class="line">    if (vnode.tag) &#123;</span><br><span class="line">        <span class="built_in">insert</span>(parentElm, nodeOps.createElement(vnode.tag), refElm);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        <span class="built_in">insert</span>(parentElm, nodeOps.createTextNode(vnode.text), refElm);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>addVnodes</code> 用来批量调用 <code>createElm</code> 新建节点。</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function addVnodes (parentElm, refElm, vnodes, startIdx, endIdx) &#123;</span><br><span class="line">    for (; startIdx &lt;= endIdx; ++startIdx) &#123;</span><br><span class="line">        <span class="built_in">createElm</span>(vnodes[startIdx], parentElm, refElm);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>removeNode</code> 用来移除一个节点。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function removeNode (el) &#123;</span><br><span class="line">    const <span class="attr">parent</span> = nodeOps.parentNode(el)<span class="comment">;</span></span><br><span class="line">    if (parent) &#123;</span><br><span class="line">        nodeOps.removeChild(parent, el)<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>removeVnodes</code> 会批量调用 <code>removeNode</code> 移除节点。</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function removeVnodes (parentElm, vnodes, startIdx, endIdx) &#123;</span><br><span class="line">    for (; startIdx &lt;= endIdx; ++startIdx) &#123;</span><br><span class="line">        const ch = vnodes<span class="selector-attr">[startIdx]</span></span><br><span class="line">        if (ch) &#123;</span><br><span class="line">            <span class="built_in">removeNode</span>(ch.elm);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="patch"><a href="#patch" class="headerlink" title="patch"></a>patch</h2><p>首先说一下 <code>patch</code> 的核心 diff 算法，我们用 diff 算法可以比对出两颗树的「差异」，我们来看一下，假设我们现在有如下两颗树，它们分别是新老 VNode 节点，这时候到了 <code>patch</code> 的过程，我们需要将他们进行比对。</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/12/28/1609be691ed64525~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp"></p>
<p>diff 算法是通过同层的树节点进行比较而非对树进行逐层搜索遍历的方式，所以时间复杂度只有 O(n)，是一种相当高效的算法，如下图。</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/12/28/1609be700a80c98a~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp"></p>
<p>。</p>
<p>这张图中的相同颜色的方块中的节点会进行比对，比对得到「<strong>差异</strong>」后将这些「<strong>差异</strong>」更新到视图上。因为只进行同层级的比对，所以十分高效。</p>
<p><code>patch</code> 的过程相当复杂，我们先用简单的代码来看一下。</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function patch (oldVnode, vnode, parentElm) &#123;</span><br><span class="line">    if (!oldVnode) &#123;</span><br><span class="line">        <span class="built_in">addVnodes</span>(parentElm, null, vnode, <span class="number">0</span>, vnode.length - <span class="number">1</span>);</span><br><span class="line">    &#125; else if (!vnode) &#123;</span><br><span class="line">        <span class="built_in">removeVnodes</span>(parentElm, oldVnode, <span class="number">0</span>, oldVnode.length - <span class="number">1</span>);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (sameVnode(oldVNode, vnode)) &#123;</span><br><span class="line">            <span class="built_in">patchVnode</span>(oldVNode, vnode);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            <span class="built_in">removeVnodes</span>(parentElm, oldVnode, <span class="number">0</span>, oldVnode.length - <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">addVnodes</span>(parentElm, null, vnode, <span class="number">0</span>, vnode.length - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为 <code>patch</code> 的主要功能是比对两个 VNode 节点，将「差异」更新到视图上，所以入参有新老两个 VNode 以及父节点的 element 。我们来逐步捋一下逻辑， <code>addVnodes</code> 、 <code>removeVnodes</code> 等函数后面会讲。</p>
<p>首先在 <code>oldVnode</code>（老 VNode 节点）不存在的时候，相当于新的 VNode 替代原本没有的节点，所以直接用 <code>addVnodes</code> 将这些节点批量添加到 <code>parentElm</code> 上。</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (!oldVnode) &#123;</span><br><span class="line">    <span class="built_in">addVnodes</span>(parentElm, null, vnode, <span class="number">0</span>, vnode.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后同理，在 <code>vnode</code>（新 VNode 节点）不存在的时候，相当于要把老的节点删除，所以直接使用 <code>removeVnodes</code> 进行批量的节点删除即可。</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">else if (!vnode) &#123;</span><br><span class="line">    <span class="built_in">removeVnodes</span>(parentElm, oldVnode, <span class="number">0</span>, oldVnode.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后一种情况，当 <code>oldVNode</code> 与 <code>vnode</code> 都存在的时候，需要判断它们是否属于 <code>sameVnode</code>（相同的节点）。如果是则进行patchVnode（比对 VNode ）操作，否则删除老节点，增加新节点。</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (sameVnode(oldVNode, vnode)) &#123;</span><br><span class="line">    <span class="built_in">patchVnode</span>(oldVNode, vnode);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    <span class="built_in">removeVnodes</span>(parentElm, oldVnode, <span class="number">0</span>, oldVnode.length - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">addVnodes</span>(parentElm, null, vnode, <span class="number">0</span>, vnode.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="sameVnode"><a href="#sameVnode" class="headerlink" title="sameVnode"></a>sameVnode</h2><p>上面这些比较好理解，下面我们来看看什么情况下两个 VNode 会属于 <code>sameVnode</code> （相同的节点）呢？</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function sameVnode () &#123;</span><br><span class="line">    return (</span><br><span class="line">        <span class="selector-tag">a</span><span class="selector-class">.key</span> === <span class="selector-tag">b</span><span class="selector-class">.key</span> &amp;&amp;</span><br><span class="line">        <span class="selector-tag">a</span><span class="selector-class">.tag</span> === <span class="selector-tag">b</span><span class="selector-class">.tag</span> &amp;&amp;</span><br><span class="line">        <span class="selector-tag">a</span><span class="selector-class">.isComment</span> === <span class="selector-tag">b</span><span class="selector-class">.isComment</span> &amp;&amp;</span><br><span class="line">        (!!<span class="selector-tag">a</span><span class="selector-class">.data</span>) === (!!<span class="selector-tag">b</span><span class="selector-class">.data</span>) &amp;&amp;</span><br><span class="line">        sameInputType(<span class="selector-tag">a</span>, <span class="selector-tag">b</span>)</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function sameInputType (<span class="selector-tag">a</span>, <span class="selector-tag">b</span>) &#123;</span><br><span class="line">    if (<span class="selector-tag">a</span><span class="selector-class">.tag</span> !== &#x27;<span class="selector-tag">input</span>&#x27;) return true</span><br><span class="line">    let <span class="selector-tag">i</span></span><br><span class="line">    const typeA = (<span class="selector-tag">i</span> = <span class="selector-tag">a</span><span class="selector-class">.data</span>) &amp;&amp; (<span class="selector-tag">i</span> = <span class="selector-tag">i</span><span class="selector-class">.attrs</span>) &amp;&amp; <span class="selector-tag">i</span><span class="selector-class">.type</span></span><br><span class="line">    const typeB = (<span class="selector-tag">i</span> = <span class="selector-tag">b</span><span class="selector-class">.data</span>) &amp;&amp; (<span class="selector-tag">i</span> = <span class="selector-tag">i</span><span class="selector-class">.attrs</span>) &amp;&amp; <span class="selector-tag">i</span><span class="selector-class">.type</span></span><br><span class="line">    return typeA === typeB</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>sameVnode</code> 其实很简单，只有当 <code>key</code>、 <code>tag</code>、 <code>isComment</code>（是否为注释节点）、 <code>data</code>同时定义（或不定义），同时满足当标签类型为 input 的时候 type 相同（某些浏览器不支持动态修改<input>类型，所以他们被视为不同类型）即可。</p>
<h2 id="patchVnode"><a href="#patchVnode" class="headerlink" title="patchVnode"></a>patchVnode</h2><p>之前patch的过程还剩下 <code>patchVnode</code> 这个函数没有讲，这也是最复杂的一个，我们现在来看一下。因为这个函数是在符合 <code>sameVnode</code> 的条件下触发的，所以会进行「<strong>比对</strong>」。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">function patchVnode (oldVnode, vnode) &#123;</span><br><span class="line">    if (<span class="attr">oldVnode</span> === vnode) &#123;</span><br><span class="line">        return<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (vnode.isStatic &amp;&amp; oldVnode.isStatic &amp;&amp; <span class="attr">vnode.key</span> === oldVnode.key) &#123;</span><br><span class="line">        <span class="attr">vnode.elm</span> = oldVnode.elm<span class="comment">;</span></span><br><span class="line">        <span class="attr">vnode.componentInstance</span> = oldVnode.componentInstance<span class="comment">;</span></span><br><span class="line">        return<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const <span class="attr">elm</span> = vnode.elm = oldVnode.elm<span class="comment">;</span></span><br><span class="line">    const <span class="attr">oldCh</span> = oldVnode.children<span class="comment">;</span></span><br><span class="line">    const <span class="attr">ch</span> = vnode.children<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    if (vnode.text) &#123;</span><br><span class="line">        nodeOps.setTextContent(elm, vnode.text)<span class="comment">;</span></span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (oldCh &amp;&amp; ch &amp;&amp; (oldCh !== ch)) &#123;</span><br><span class="line">            updateChildren(elm, oldCh, ch)<span class="comment">;</span></span><br><span class="line">        &#125; else if (ch) &#123;</span><br><span class="line">            if (oldVnode.text) nodeOps.setTextContent(elm, &#x27;&#x27;)<span class="comment">;</span></span><br><span class="line">            addVnodes(elm, null, ch, 0, ch.length - 1)<span class="comment">;</span></span><br><span class="line">        &#125; else if (oldCh) &#123;</span><br><span class="line">            removeVnodes(elm, oldCh, 0, oldCh.length - 1)</span><br><span class="line">        &#125; else if (oldVnode.text) &#123;</span><br><span class="line">            nodeOps.setTextContent(elm, &#x27;&#x27;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先在新老 VNode 节点相同的情况下，就不需要做任何改变了，直接 return 掉。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (<span class="attr">oldVnode</span> === vnode) &#123;</span><br><span class="line">    return<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面的这种情况也比较简单，在当新老 VNode 节点都是 <code>isStatic</code>（静态的），并且 <code>key</code> 相同时，只要将 <code>componentInstance</code> 与 <code>elm</code> 从老 VNode 节点“拿过来”即可。这里的 <code>isStatic</code> 也就是前面提到过的「编译」的时候会将静态节点标记出来，这样就可以跳过比对的过程。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (vnode.isStatic &amp;&amp; oldVnode.isStatic &amp;&amp; <span class="attr">vnode.key</span> === oldVnode.key) &#123;</span><br><span class="line">    <span class="attr">vnode.elm</span> = oldVnode.elm<span class="comment">;</span></span><br><span class="line">    <span class="attr">vnode.componentInstance</span> = oldVnode.componentInstance<span class="comment">;</span></span><br><span class="line">    return<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，当新 VNode 节点是文本节点的时候，直接用 <code>setTextContent</code> 来设置 text，这里的 <code>nodeOps</code> 是一个适配层，根据不同平台提供不同的操作平台 DOM 的方法，实现跨平台。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (vnode.text) &#123;</span><br><span class="line">    nodeOps.<span class="built_in">setTextContent</span>(elm, vnode.text);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当新 VNode 节点是非文本节点当时候，需要分几种情况。</p>
<ul>
<li><code>oldCh</code> 与 <code>ch</code> 都存在且不相同时，使用 <code>updateChildren</code> 函数来更新子节点，这个后面重点讲。</li>
<li>如果只有 <code>ch</code> 存在的时候，如果老节点是文本节点则先将节点的文本清除，然后将 <code>ch</code> 批量插入插入到节点elm下。</li>
<li>同理当只有 <code>oldch</code> 存在时，说明需要将老节点通过 <code>removeVnodes</code> 全部清除。</li>
<li>最后一种情况是当只有老节点是文本节点的时候，清除其节点文本内容。</li>
</ul>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">if (oldCh &amp;&amp; ch &amp;&amp; (oldCh !== ch)) &#123;</span><br><span class="line">    <span class="built_in">updateChildren</span>(elm, oldCh, ch);</span><br><span class="line">&#125; else if (ch) &#123;</span><br><span class="line">    if (oldVnode.text) nodeOps<span class="selector-class">.setTextContent</span>(elm, &#x27;&#x27;);</span><br><span class="line">    <span class="built_in">addVnodes</span>(elm, null, ch, <span class="number">0</span>, ch.length - <span class="number">1</span>);</span><br><span class="line">&#125; else if (oldCh) &#123;</span><br><span class="line">    <span class="built_in">removeVnodes</span>(elm, oldCh, <span class="number">0</span>, oldCh.length - <span class="number">1</span>)</span><br><span class="line">&#125; else if (oldVnode.text) &#123;</span><br><span class="line">    nodeOps<span class="selector-class">.setTextContent</span>(elm, &#x27;&#x27;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="updateChildren"><a href="#updateChildren" class="headerlink" title="updateChildren"></a>updateChildren</h2><p>接下来就要讲一下 <code>updateChildren</code> 函数了。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">function updateChildren (parentElm, oldCh, newCh) &#123;</span><br><span class="line">    let <span class="attr">oldStartIdx</span> = <span class="number">0</span><span class="comment">;</span></span><br><span class="line">    let <span class="attr">newStartIdx</span> = <span class="number">0</span><span class="comment">;</span></span><br><span class="line">    let <span class="attr">oldEndIdx</span> = oldCh.length - <span class="number">1</span><span class="comment">;</span></span><br><span class="line">    let <span class="attr">oldStartVnode</span> = oldCh[<span class="number">0</span>]<span class="comment">;</span></span><br><span class="line">    let <span class="attr">oldEndVnode</span> = oldCh[oldEndIdx]<span class="comment">;</span></span><br><span class="line">    let <span class="attr">newEndIdx</span> = newCh.length - <span class="number">1</span><span class="comment">;</span></span><br><span class="line">    let <span class="attr">newStartVnode</span> = newCh[<span class="number">0</span>]<span class="comment">;</span></span><br><span class="line">    let <span class="attr">newEndVnode</span> = newCh[newEndIdx]<span class="comment">;</span></span><br><span class="line">    let oldKeyToIdx, idxInOld, elmToMove, refElm<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    while (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;</span><br><span class="line">        if (!oldStartVnode) &#123;</span><br><span class="line">            <span class="attr">oldStartVnode</span> = oldCh[++oldStartIdx]<span class="comment">;</span></span><br><span class="line">        &#125; else if (!oldEndVnode) &#123;</span><br><span class="line">            <span class="attr">oldEndVnode</span> = oldCh[--oldEndIdx]<span class="comment">;</span></span><br><span class="line">        &#125; else if (sameVnode(oldStartVnode, newStartVnode)) &#123;</span><br><span class="line">            patchVnode(oldStartVnode, newStartVnode)<span class="comment">;</span></span><br><span class="line">            <span class="attr">oldStartVnode</span> = oldCh[++oldStartIdx]<span class="comment">;</span></span><br><span class="line">            <span class="attr">newStartVnode</span> = newCh[++newStartIdx]<span class="comment">;</span></span><br><span class="line">        &#125; else if (sameVnode(oldEndVnode, newEndVnode)) &#123;</span><br><span class="line">            patchVnode(oldEndVnode, newEndVnode)<span class="comment">;</span></span><br><span class="line">            <span class="attr">oldEndVnode</span> = oldCh[--oldEndIdx]<span class="comment">;</span></span><br><span class="line">            <span class="attr">newEndVnode</span> = newCh[--newEndIdx]<span class="comment">;</span></span><br><span class="line">        &#125; else if (sameVnode(oldStartVnode, newEndVnode)) &#123;</span><br><span class="line">            patchVnode(oldStartVnode, newEndVnode)<span class="comment">;</span></span><br><span class="line">            nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm))<span class="comment">;</span></span><br><span class="line">            <span class="attr">oldStartVnode</span> = oldCh[++oldStartIdx]<span class="comment">;</span></span><br><span class="line">            <span class="attr">newEndVnode</span> = newCh[--newEndIdx]<span class="comment">;</span></span><br><span class="line">        &#125; else if (sameVnode(oldEndVnode, newStartVnode)) &#123;</span><br><span class="line">            patchVnode(oldEndVnode, newStartVnode)<span class="comment">;</span></span><br><span class="line">            nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm)<span class="comment">;</span></span><br><span class="line">            <span class="attr">oldEndVnode</span> = oldCh[--oldEndIdx]<span class="comment">;</span></span><br><span class="line">            <span class="attr">newStartVnode</span> = newCh[++newStartIdx]<span class="comment">;</span></span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            let <span class="attr">elmToMove</span> = oldCh[idxInOld]<span class="comment">;</span></span><br><span class="line">            if (!oldKeyToIdx) <span class="attr">oldKeyToIdx</span> = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)<span class="comment">;</span></span><br><span class="line">            <span class="attr">idxInOld</span> = newStartVnode.key ? oldKeyToIdx[newStartVnode.key] : null<span class="comment">;</span></span><br><span class="line">            if (!idxInOld) &#123;</span><br><span class="line">                createElm(newStartVnode, parentElm)<span class="comment">;</span></span><br><span class="line">                <span class="attr">newStartVnode</span> = newCh[++newStartIdx]<span class="comment">;</span></span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                <span class="attr">elmToMove</span> = oldCh[idxInOld]<span class="comment">;</span></span><br><span class="line">                if (sameVnode(elmToMove, newStartVnode)) &#123;</span><br><span class="line">                    patchVnode(elmToMove, newStartVnode)<span class="comment">;</span></span><br><span class="line">                    oldCh<span class="section">[idxInOld]</span> = undefined<span class="comment">;</span></span><br><span class="line">                    nodeOps.insertBefore(parentElm, newStartVnode.elm, oldStartVnode.elm)<span class="comment">;</span></span><br><span class="line">                    <span class="attr">newStartVnode</span> = newCh[++newStartIdx]<span class="comment">;</span></span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    createElm(newStartVnode, parentElm)<span class="comment">;</span></span><br><span class="line">                    <span class="attr">newStartVnode</span> = newCh[++newStartIdx]<span class="comment">;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (oldStartIdx &gt; oldEndIdx) &#123;</span><br><span class="line">        <span class="attr">refElm</span> = (newCh[newEndIdx + <span class="number">1</span>]) ? newCh[newEndIdx + <span class="number">1</span>].elm : null<span class="comment">;</span></span><br><span class="line">        addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx)<span class="comment">;</span></span><br><span class="line">    &#125; else if (newStartIdx &gt; newEndIdx) &#123;</span><br><span class="line">        removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx)<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到代码那么多先不要着急，我们还是一点一点地讲解。</p>
<p>首先我们定义 <code>oldStartIdx</code>、<code>newStartIdx</code>、<code>oldEndIdx</code> 以及 <code>newEndIdx</code> 分别是新老两个 VNode 的两边的索引，同时 <code>oldStartVnode</code>、<code>newStartVnode</code>、<code>oldEndVnode</code> 以及 <code>newEndVnode</code> 分别指向这几个索引对应的 VNode 节点。</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/1/2/160b707df4902029~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp"></p>
<p>接下来是一个 <code>while</code> 循环，在这过程中，<code>oldStartIdx</code>、<code>newStartIdx</code>、<code>oldEndIdx</code> 以及 <code>newEndIdx</code> 会逐渐向中间靠拢。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) </span><br></pre></td></tr></table></figure>

<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/1/2/160b70ecf5967f0a~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp"></p>
<p>首先当 <code>oldStartVnode</code> 或者 <code>oldEndVnode</code> 不存在的时候，<code>oldStartIdx</code> 与 <code>oldEndIdx</code> 继续向中间靠拢，并更新对应的 <code>oldStartVnode</code> 与 <code>oldEndVnode</code> 的指向（注：下面讲到的 <code>oldStartIdx</code>、<code>newStartIdx</code>、<code>oldEndIdx</code> 以及 <code>newEndIdx</code> 移动都会伴随着 <code>oldStartVnode</code>、<code>newStartVnode</code>、<code>oldEndVnode</code> 以及 <code>newEndVnode</code> 的指向的变化，之后的部分只会讲 <code>Idx</code> 的移动）。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (!oldStartVnode) &#123;</span><br><span class="line">    <span class="attr">oldStartVnode</span> = oldCh[++oldStartIdx]<span class="comment">;</span></span><br><span class="line">&#125; else if (!oldEndVnode) &#123;</span><br><span class="line">    <span class="attr">oldEndVnode</span> = oldCh[--oldEndIdx]<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来这一块，是将 <code>oldStartIdx</code>、<code>newStartIdx</code>、<code>oldEndIdx</code> 以及 <code>newEndIdx</code> 两两比对的过程，一共会出现 2*2&#x3D;4 种情况。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> else if (sameVnode(oldStartVnode, newStartVnode)) &#123;</span><br><span class="line">    patchVnode(oldStartVnode, newStartVnode)<span class="comment">;</span></span><br><span class="line">    <span class="attr">oldStartVnode</span> = oldCh[++oldStartIdx]<span class="comment">;</span></span><br><span class="line">    <span class="attr">newStartVnode</span> = newCh[++newStartIdx]<span class="comment">;</span></span><br><span class="line">&#125; else if (sameVnode(oldEndVnode, newEndVnode)) &#123;</span><br><span class="line">    patchVnode(oldEndVnode, newEndVnode)<span class="comment">;</span></span><br><span class="line">    <span class="attr">oldEndVnode</span> = oldCh[--oldEndIdx]<span class="comment">;</span></span><br><span class="line">    <span class="attr">newEndVnode</span> = newCh[--newEndIdx]<span class="comment">;</span></span><br><span class="line">&#125; else if (sameVnode(oldStartVnode, newEndVnode)) &#123;</span><br><span class="line">    patchVnode(oldStartVnode, newEndVnode)<span class="comment">;</span></span><br><span class="line">    nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm))<span class="comment">;</span></span><br><span class="line">    <span class="attr">oldStartVnode</span> = oldCh[++oldStartIdx]<span class="comment">;</span></span><br><span class="line">    <span class="attr">newEndVnode</span> = newCh[--newEndIdx]<span class="comment">;</span></span><br><span class="line">&#125; else if (sameVnode(oldEndVnode, newStartVnode)) &#123;</span><br><span class="line">    patchVnode(oldEndVnode, newStartVnode)<span class="comment">;</span></span><br><span class="line">    nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm)<span class="comment">;</span></span><br><span class="line">    <span class="attr">oldEndVnode</span> = oldCh[--oldEndIdx]<span class="comment">;</span></span><br><span class="line">    <span class="attr">newStartVnode</span> = newCh[++newStartIdx]<span class="comment">;</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>首先是 <code>oldStartVnode</code> 与 <code>newStartVnode</code> 符合 <code>sameVnode</code> 时，说明老 VNode 节点的头部与新 VNode 节点的头部是相同的 VNode 节点，直接进行 <code>patchVnode</code>，同时 <code>oldStartIdx</code> 与 <code>newStartIdx</code> 向后移动一位。</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/1/2/160b71f5a48631f4~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp"></p>
<p>其次是 <code>oldEndVnode</code> 与 <code>newEndVnode</code> 符合 <code>sameVnode</code>，也就是两个 VNode 的结尾是相同的 VNode，同样进行 <code>patchVnode</code> 操作并将 <code>oldEndVnode</code> 与 <code>newEndVnode</code> 向前移动一位。</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/1/2/160b7228b9ecb23a~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp"></p>
<p>接下来是两种交叉的情况。</p>
<p>先是 <code>oldStartVnode</code> 与 <code>newEndVnode</code> 符合 <code>sameVnode</code> 的时候，也就是老 VNode 节点的头部与新 VNode 节点的尾部是同一节点的时候，将 <code>oldStartVnode.elm</code> 这个节点直接移动到 <code>oldEndVnode.elm</code> 这个节点的后面即可。然后 <code>oldStartIdx</code> 向后移动一位，<code>newEndIdx</code> 向前移动一位。</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/1/2/160b723af0fd706a~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp"></p>
<p>同理，<code>oldEndVnode</code> 与 <code>newStartVnode</code> 符合 <code>sameVnode</code> 时，也就是老 VNode 节点的尾部与新 VNode 节点的头部是同一节点的时候，将 <code>oldEndVnode.elm</code> 插入到 <code>oldStartVnode.elm</code> 前面。同样的，<code>oldEndIdx</code> 向前移动一位，<code>newStartIdx</code> 向后移动一位。</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/1/2/160b72ae720954cd~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp"></p>
<p>最后是当以上情况都不符合的时候，这种情况怎么处理呢？</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">else &#123;</span><br><span class="line">    let <span class="attr">elmToMove</span> = oldCh[idxInOld]<span class="comment">;</span></span><br><span class="line">    if (!oldKeyToIdx) <span class="attr">oldKeyToIdx</span> = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)<span class="comment">;</span></span><br><span class="line">    <span class="attr">idxInOld</span> = newStartVnode.key ? oldKeyToIdx[newStartVnode.key] : null<span class="comment">;</span></span><br><span class="line">    if (!idxInOld) &#123;</span><br><span class="line">        createElm(newStartVnode, parentElm)<span class="comment">;</span></span><br><span class="line">        <span class="attr">newStartVnode</span> = newCh[++newStartIdx]<span class="comment">;</span></span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        <span class="attr">elmToMove</span> = oldCh[idxInOld]<span class="comment">;</span></span><br><span class="line">        if (sameVnode(elmToMove, newStartVnode)) &#123;</span><br><span class="line">            patchVnode(elmToMove, newStartVnode)<span class="comment">;</span></span><br><span class="line">            oldCh<span class="section">[idxInOld]</span> = undefined<span class="comment">;</span></span><br><span class="line">            nodeOps.insertBefore(parentElm, newStartVnode.elm, oldStartVnode.elm)<span class="comment">;</span></span><br><span class="line">            <span class="attr">newStartVnode</span> = newCh[++newStartIdx]<span class="comment">;</span></span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            createElm(newStartVnode, parentElm)<span class="comment">;</span></span><br><span class="line">            <span class="attr">newStartVnode</span> = newCh[++newStartIdx]<span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function createKeyToOldIdx (children, beginIdx, endIdx) &#123;</span><br><span class="line">    let i, key</span><br><span class="line">    const <span class="attr">map</span> = &#123;&#125;</span><br><span class="line">    for (<span class="attr">i</span> = beginIdx<span class="comment">; i &lt;= endIdx; ++i) &#123;</span></span><br><span class="line">        <span class="attr">key</span> = children[i].key</span><br><span class="line">        if (isDef(key)) map<span class="section">[key]</span> = i</span><br><span class="line">    &#125;</span><br><span class="line">    return map</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>createKeyToOldIdx</code> 的作用是产生 <code>key</code> 与 <code>index</code> 索引对应的一个 map 表。比如说：</p>
<figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;xx: xx, <span class="keyword">key</span>: <span class="comment">&#x27;key0&#x27;&#125;,</span></span><br><span class="line">    &#123;xx: xx, <span class="keyword">key</span>: <span class="comment">&#x27;key1&#x27;&#125;, </span></span><br><span class="line">    &#123;xx: xx, <span class="keyword">key</span>: <span class="comment">&#x27;key2&#x27;&#125;</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>在经过 <code>createKeyToOldIdx</code> 转化以后会变成：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">key0:</span> <span class="number">0</span>, </span><br><span class="line">    <span class="attr">key1:</span> <span class="number">1</span>, </span><br><span class="line">    <span class="attr">key2:</span> <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以根据某一个 key 的值，快速地从 <code>oldKeyToIdx</code>（<code>createKeyToOldIdx</code> 的返回值）中获取相同 key 的节点的索引 <code>idxInOld</code>，然后找到相同的节点。</p>
<p>如果没有找到相同的节点，则通过 <code>createElm</code> 创建一个新节点，并将 <code>newStartIdx</code> 向后移动一位。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (!idxInOld) &#123;</span><br><span class="line">    createElm(newStartVnode, parentElm)<span class="comment">;</span></span><br><span class="line">    <span class="attr">newStartVnode</span> = newCh[++newStartIdx]<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>否则如果找到了节点，同时它符合 <code>sameVnode</code>，则将这两个节点进行 <code>patchVnode</code>，将该位置的老节点赋值 undefined（之后如果还有新节点与该节点key相同可以检测出来提示已有重复的 key ），同时将 <code>newStartVnode.elm</code> 插入到 <code>oldStartVnode.elm</code> 的前面。同理，<code>newStartIdx</code> 往后移动一位。</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/1/2/160b73aa8f758342~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp"></p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">else &#123;</span><br><span class="line">    <span class="attr">elmToMove</span> = oldCh[idxInOld]<span class="comment">;</span></span><br><span class="line">    if (sameVnode(elmToMove, newStartVnode)) &#123;</span><br><span class="line">        patchVnode(elmToMove, newStartVnode)<span class="comment">;</span></span><br><span class="line">        oldCh<span class="section">[idxInOld]</span> = undefined<span class="comment">;</span></span><br><span class="line">        nodeOps.insertBefore(parentElm, newStartVnode.elm, oldStartVnode.elm)<span class="comment">;</span></span><br><span class="line">        <span class="attr">newStartVnode</span> = newCh[++newStartIdx]<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果不符合 <code>sameVnode</code>，只能创建一个新节点插入到 <code>parentElm</code> 的子节点中，<code>newStartIdx</code> 往后移动一位。</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/1/2/160b73f50ed43932~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp"></p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">else &#123;</span><br><span class="line">    createElm(newStartVnode, parentElm)<span class="comment">;</span></span><br><span class="line">    <span class="attr">newStartVnode</span> = newCh[++newStartIdx]<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后一步就很容易啦，当 <code>while</code> 循环结束以后，如果 <code>oldStartIdx &gt; oldEndIdx</code>，说明老节点比对完了，但是新节点还有多的，需要将新节点插入到真实 DOM 中去，调用 <code>addVnodes</code> 将这些节点插入即可。</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/1/2/160b7457cae26687~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp"></p>
<p>同理，如果满足 <code>newStartIdx &gt; newEndIdx</code> 条件，说明新节点比对完了，老节点还有多，将这些无用的老节点通过 <code>removeVnodes</code> 批量删除即可。</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/1/2/160b744a2c07257d~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp"></p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (oldStartIdx &gt; oldEndIdx) &#123;</span><br><span class="line">    refElm = (newCh[newEndIdx + <span class="number">1</span>]) ? newCh<span class="selector-attr">[newEndIdx + 1]</span><span class="selector-class">.elm</span> : null;</span><br><span class="line">    <span class="built_in">addVnodes</span>(parentElm, refElm, newCh, newStartIdx, newEndIdx);</span><br><span class="line">&#125; else if (newStartIdx &gt; newEndIdx) &#123;</span><br><span class="line">    <span class="built_in">removeVnodes</span>(parentElm, oldCh, oldStartIdx, oldEndIdx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里，比对的核心实现已经讲完了，这部分比较复杂，不过仔细地梳理一下比对的过程，相信一定能够理解得更加透彻的。</p>
<p>注：本节代码参考<a href="https://link.juejin.cn/?target=https://github.com/answershuto/VueDemo/blob/master/%25E3%2580%258A%25E6%2595%25B0%25E6%258D%25AE%25E7%258A%25B6%25E6%2580%2581%25E6%259B%25B4%25E6%2596%25B0%25E6%2597%25B6%25E7%259A%2584%25E5%25B7%25AE%25E5%25BC%2582%2520diff%2520%25E5%258F%258A%2520patch%2520%25E6%259C%25BA%25E5%2588%25B6%25E3%2580%258B.js" title="https://github.com/answershuto/VueDemo/blob/master/%E3%80%8A%E6%95%B0%E6%8D%AE%E7%8A%B6%E6%80%81%E6%9B%B4%E6%96%B0%E6%97%B6%E7%9A%84%E5%B7%AE%E5%BC%82%20diff%20%E5%8F%8A%20patch%20%E6%9C%BA%E5%88%B6%E3%80%8B.js">《数据状态更新时的差异 diff 及 patch 机制》</a>。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/10/29/6-%E6%95%B0%E6%8D%AE%E7%8A%B6%E6%80%81%E6%9B%B4%E6%96%B0%E6%97%B6%E7%9A%84%E5%B7%AE%E5%BC%82-diff-%E5%8F%8A-patch-%E6%9C%BA%E5%88%B6/" data-id="claxeer9l0005v8w1898j9lno" data-title="6.数据状态更新时的差异 diff 及 patch 机制" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-5-template-模板是怎样通过-Compile-编译的" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/10/29/5-template-%E6%A8%A1%E6%9D%BF%E6%98%AF%E6%80%8E%E6%A0%B7%E9%80%9A%E8%BF%87-Compile-%E7%BC%96%E8%AF%91%E7%9A%84/" class="article-date">
  <time class="dt-published" datetime="2022-10-29T12:13:19.000Z" itemprop="datePublished">2022-10-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/10/29/5-template-%E6%A8%A1%E6%9D%BF%E6%98%AF%E6%80%8E%E6%A0%B7%E9%80%9A%E8%BF%87-Compile-%E7%BC%96%E8%AF%91%E7%9A%84/">5.template 模板是怎样通过 Compile 编译的</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Compile"><a href="#Compile" class="headerlink" title="Compile"></a>Compile</h2><p><code>compile</code> 编译可以分成 <code>parse</code>、<code>optimize</code> 与 <code>generate</code> 三个阶段，最终需要得到 render function。这部分内容不算 Vue.js 的响应式核心，只是用来编译的，笔者认为在精力有限的情况下不需要追究其全部的实现细节，能够把握如何解析的大致流程即可。</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/12/19/1606ec3d306ab28f~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp"></p>
<p>由于解析过程比较复杂，直接上代码可能会导致不了解这部分内容的同学一头雾水。所以笔者准备提供一个 template 的示例，通过这个示例的变化来看解析的过程。但是解析的过程及结果都是将最重要的部分抽离出来展示，希望能让读者更好地了解其核心部分的实现。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">div</span> :class=<span class="string">&quot;c&quot;</span> class=<span class="string">&quot;demo&quot;</span> v-if=<span class="string">&quot;isShow&quot;</span>&gt;</span><br><span class="line">    &lt;span v-for=<span class="string">&quot;item in sz&quot;</span>&gt;&#123;&#123;item&#125;&#125;&lt;/<span class="selector-tag">span</span>&gt;</span><br><span class="line">&lt;/<span class="selector-tag">div</span>&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">var</span> <span class="selector-tag">html</span> = &#x27;&lt;<span class="selector-tag">div</span> :class=<span class="string">&quot;c&quot;</span> class=<span class="string">&quot;demo&quot;</span> v-if=<span class="string">&quot;isShow&quot;</span>&gt;&lt;span v-for=<span class="string">&quot;item in sz&quot;</span>&gt;&#123;&#123;item&#125;&#125;&lt;/<span class="selector-tag">span</span>&gt;&lt;/<span class="selector-tag">div</span>&gt;&#x27;;</span><br></pre></td></tr></table></figure>

<p>接下来的过程都会依赖这个示例来进行。</p>
<h2 id="parse"><a href="#parse" class="headerlink" title="parse"></a>parse</h2><p>首先是 <code>parse</code>，<code>parse</code> 会用正则等方式将 template 模板中进行字符串解析，得到指令、class、style等数据，形成 AST（<a href="https://link.juejin.cn/?target=https://zh.wikipedia.org/wiki/%25E6%258A%25BD%25E8%25B1%25A1%25E8%25AA%259E%25E6%25B3%2595%25E6%25A8%25B9" title="https://zh.wikipedia.org/wiki/%E6%8A%BD%E8%B1%A1%E8%AA%9E%E6%B3%95%E6%A8%B9">在计算机科学中，抽象语法树（abstract syntax tree或者缩写为AST），或者语法树（syntax tree），是源代码的抽象语法结构的树状表现形式，这里特指编程语言的源代码。</a>）。</p>
<p>这个过程比较复杂，会涉及到比较多的正则进行字符串解析，我们来看一下得到的 AST 的样子。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 标签属性的map，记录了标签上属性 */</span></span><br><span class="line">    <span class="string">&#x27;attrsMap&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;:class&#x27;</span>: <span class="string">&#x27;c&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;class&#x27;</span>: <span class="string">&#x27;demo&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;v-if&#x27;</span>: <span class="string">&#x27;isShow&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">/* 解析得到的:class */</span></span><br><span class="line">    <span class="string">&#x27;classBinding&#x27;</span>: <span class="string">&#x27;c&#x27;</span>,</span><br><span class="line">    <span class="comment">/* 标签属性v-if */</span></span><br><span class="line">    <span class="string">&#x27;if&#x27;</span>: <span class="string">&#x27;isShow&#x27;</span>,</span><br><span class="line">    <span class="comment">/* v-if的条件 */</span></span><br><span class="line">    <span class="string">&#x27;ifConditions&#x27;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&#x27;exp&#x27;</span>: <span class="string">&#x27;isShow&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="comment">/* 标签属性class */</span></span><br><span class="line">    <span class="string">&#x27;staticClass&#x27;</span>: <span class="string">&#x27;demo&#x27;</span>,</span><br><span class="line">    <span class="comment">/* 标签的tag */</span></span><br><span class="line">    <span class="string">&#x27;tag&#x27;</span>: <span class="string">&#x27;div&#x27;</span>,</span><br><span class="line">    <span class="comment">/* 子标签数组 */</span></span><br><span class="line">    <span class="string">&#x27;children&#x27;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&#x27;attrsMap&#x27;</span>: &#123;</span><br><span class="line">                <span class="string">&#x27;v-for&#x27;</span>: <span class="string">&quot;item in sz&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">/* for循环的参数 */</span></span><br><span class="line">            <span class="string">&#x27;alias&#x27;</span>: <span class="string">&quot;item&quot;</span>,</span><br><span class="line">            <span class="comment">/* for循环的对象 */</span></span><br><span class="line">            <span class="string">&#x27;for&#x27;</span>: <span class="string">&#x27;sz&#x27;</span>,</span><br><span class="line">            <span class="comment">/* for循环是否已经被处理的标记位 */</span></span><br><span class="line">            <span class="string">&#x27;forProcessed&#x27;</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="string">&#x27;tag&#x27;</span>: <span class="string">&#x27;span&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;children&#x27;</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">/* 表达式，_s是一个转字符串的函数 */</span></span><br><span class="line">                    <span class="string">&#x27;expression&#x27;</span>: <span class="string">&#x27;_s(item)&#x27;</span>,</span><br><span class="line">                    <span class="string">&#x27;text&#x27;</span>: <span class="string">&#x27;&#123;&#123;item&#125;&#125;&#x27;</span></span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最终得到的 AST 通过一些特定的属性，能够比较清晰地描述出标签的属性以及依赖关系。</p>
<p>接下来我们用代码来讲解一下如何使用正则来把 template 编译成我们需要的 AST 的。</p>
<h3 id="正则"><a href="#正则" class="headerlink" title="正则"></a>正则</h3><p>首先我们定义一下接下来我们会用到的正则。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ncname = <span class="string">&#x27;[a-zA-Z_][\\w\\-\\.]*&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> singleAttrIdentifier = <span class="regexp">/([^\s&quot;&#x27;&lt;&gt;/=]+)/</span></span><br><span class="line"><span class="keyword">const</span> singleAttrAssign = <span class="regexp">/(?:=)/</span></span><br><span class="line"><span class="keyword">const</span> singleAttrValues = [</span><br><span class="line">  <span class="regexp">/&quot;([^&quot;]*)&quot;+/</span>.<span class="property">source</span>,</span><br><span class="line">  <span class="regexp">/&#x27;([^&#x27;]*)&#x27;+/</span>.<span class="property">source</span>,</span><br><span class="line">  <span class="regexp">/([^\s&quot;&#x27;=&lt;&gt;`]+)/</span>.<span class="property">source</span></span><br><span class="line">]</span><br><span class="line"><span class="keyword">const</span> attribute = <span class="keyword">new</span> <span class="title class_">RegExp</span>(</span><br><span class="line">  <span class="string">&#x27;^\\s*&#x27;</span> + singleAttrIdentifier.<span class="property">source</span> +</span><br><span class="line">  <span class="string">&#x27;(?:\\s*(&#x27;</span> + singleAttrAssign.<span class="property">source</span> + <span class="string">&#x27;)&#x27;</span> +</span><br><span class="line">  <span class="string">&#x27;\\s*(?:&#x27;</span> + singleAttrValues.<span class="title function_">join</span>(<span class="string">&#x27;|&#x27;</span>) + <span class="string">&#x27;))?&#x27;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> qnameCapture = <span class="string">&#x27;((?:&#x27;</span> + ncname + <span class="string">&#x27;\\:)?&#x27;</span> + ncname + <span class="string">&#x27;)&#x27;</span></span><br><span class="line"><span class="keyword">const</span> startTagOpen = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&#x27;^&lt;&#x27;</span> + qnameCapture)</span><br><span class="line"><span class="keyword">const</span> startTagClose = <span class="regexp">/^\s*(\/?)&gt;/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> endTag = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&#x27;^&lt;\\/&#x27;</span> + qnameCapture + <span class="string">&#x27;[^&gt;]*&gt;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> defaultTagRE = <span class="regexp">/\&#123;\&#123;((?:.|\n)+?)\&#125;\&#125;/g</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> forAliasRE = <span class="regexp">/(.*?)\s+(?:in|of)\s+(.*)/</span></span><br></pre></td></tr></table></figure>

<h2 id="advance"><a href="#advance" class="headerlink" title="advance"></a>advance</h2><p>因为我们解析 template 采用循环进行字符串匹配的方式，所以每匹配解析完一段我们需要将已经匹配掉的去掉，头部的指针指向接下来需要匹配的部分。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function advance (n) &#123;</span><br><span class="line">    index += n</span><br><span class="line">    <span class="selector-tag">html</span> = <span class="selector-tag">html</span><span class="selector-class">.substring</span>(n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>举个例子，当我们把第一个 div 的头标签全部匹配完毕以后，我们需要将这部分除去，也就是向右移动 43 个字符。</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/1/7/160d00562f38ab39~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp"></p>
<p>调用 <code>advance</code> 函数</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">advance</span>(<span class="number">43</span>);</span><br></pre></td></tr></table></figure>

<p>得到结果</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/1/7/160d0058331006a5~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp"></p>
<h3 id="parseHTML"><a href="#parseHTML" class="headerlink" title="parseHTML"></a>parseHTML</h3><p>首先我们需要定义个 <code>parseHTML</code> 函数，在里面我们循环解析 template 字符串。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">parseHTML</span> ()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(html) &#123;</span><br><span class="line">        <span class="keyword">let</span> textEnd = html.indexOf(<span class="string">&#x27;&lt;&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (textEnd === <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (html.match(endTag)) &#123;</span><br><span class="line">                <span class="comment">//...process end tag</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (html.match(startTagOpen)) &#123;</span><br><span class="line">                <span class="comment">//...process start tag</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//...process text</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>parseHTML</code> 会用 <code>while</code> 来循环解析 template ，用正则在匹配到标签头、标签尾以及文本的时候分别进行不同的处理。直到整个 template 被解析完毕。</p>
<h3 id="parseStartTag"><a href="#parseStartTag" class="headerlink" title="parseStartTag"></a>parseStartTag</h3><p>我们来写一个 <code>parseStartTag</code> 函数，用来解析起始标签（”<div :class="c" class="demo" v-if="isShow">“部分的内容）。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">function parseStartTag () &#123;</span><br><span class="line">    const <span class="attr">start</span> = html.match(startTagOpen)<span class="comment">;</span></span><br><span class="line">    if (start) &#123;</span><br><span class="line">        const <span class="attr">match</span> = &#123;</span><br><span class="line">            tagName: start<span class="section">[1]</span>,</span><br><span class="line">            attrs: <span class="section">[]</span>,</span><br><span class="line">            start: index</span><br><span class="line">        &#125;</span><br><span class="line">        advance(start<span class="section">[0]</span>.length)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">        let end, attr</span><br><span class="line">        while (!(<span class="attr">end</span> = html.match(startTagClose)) &amp;&amp; (attr = html.match(attribute))) &#123;</span><br><span class="line">            advance(attr<span class="section">[0]</span>.length)</span><br><span class="line">            match.attrs.push(&#123;</span><br><span class="line">                name: attr<span class="section">[1]</span>,</span><br><span class="line">                value: attr<span class="section">[3]</span></span><br><span class="line">            &#125;)<span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line">        if (end) &#123;</span><br><span class="line">            <span class="attr">match.unarySlash</span> = end[<span class="number">1</span>]<span class="comment">;</span></span><br><span class="line">            advance(end<span class="section">[0]</span>.length)<span class="comment">;</span></span><br><span class="line">            <span class="attr">match.end</span> = index<span class="comment">;</span></span><br><span class="line">            return match</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先用 <code>startTagOpen</code> 正则得到标签的头部，可以得到 <code>tagName</code>（标签名称），同时我们需要一个数组 <code>attrs</code> 用来存放标签内的属性。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const <span class="attr">start</span> = html.match(startTagOpen)<span class="comment">;</span></span><br><span class="line">const <span class="attr">match</span> = &#123;</span><br><span class="line">    tagName: start<span class="section">[1]</span>,</span><br><span class="line">    attrs: <span class="section">[]</span>,</span><br><span class="line">    start: index</span><br><span class="line">&#125;</span><br><span class="line">advance(start<span class="section">[0]</span>.length)<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>接下来使用 <code>startTagClose</code> 与 <code>attribute</code> 两个正则分别用来解析标签结束以及标签内的属性。这段代码用 <code>while</code> 循环一直到匹配到 <code>startTagClose</code> 为止，解析内部所有的属性。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">let end, attr</span><br><span class="line">while (!(<span class="attr">end</span> = html.match(startTagClose)) &amp;&amp; (attr = html.match(attribute))) &#123;</span><br><span class="line">    advance(attr<span class="section">[0]</span>.length)</span><br><span class="line">    match.attrs.push(&#123;</span><br><span class="line">        name: attr<span class="section">[1]</span>,</span><br><span class="line">        value: attr<span class="section">[3]</span></span><br><span class="line">    &#125;)<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line">if (end) &#123;</span><br><span class="line">    <span class="attr">match.unarySlash</span> = end[<span class="number">1</span>]<span class="comment">;</span></span><br><span class="line">    advance(end<span class="section">[0]</span>.length)<span class="comment">;</span></span><br><span class="line">    <span class="attr">match.end</span> = index<span class="comment">;</span></span><br><span class="line">    return match</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h2><p>此外，我们需要维护一个 <strong>stack</strong> 栈来保存已经解析好的标签头，这样我们可以根据在解析尾部标签的时候得到所属的层级关系以及父标签。同时我们定义一个 <code>currentParent</code> 变量用来存放当前标签的父标签节点的引用， <code>root</code> 变量用来指向根标签节点。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const <span class="attr">stack</span> = []<span class="comment">;</span></span><br><span class="line">let currentParent, root<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/1/7/160d0f34a5642ce8~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp"></p>
<p>知道这个以后，我们优化一下 <code>parseHTML</code> ，在 <code>startTagOpen</code> 的 <code>if</code> 逻辑中加上新的处理。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">if (html.match(startTagOpen)) &#123;</span><br><span class="line">    const <span class="attr">startTagMatch</span> = parseStartTag()<span class="comment">;</span></span><br><span class="line">    const <span class="attr">element</span> = &#123;</span><br><span class="line">        type: 1,</span><br><span class="line">        tag: startTagMatch.tagName,</span><br><span class="line">        lowerCasedTag: startTagMatch.tagName.toLowerCase(),</span><br><span class="line">        attrsList: startTagMatch.attrs,</span><br><span class="line">        attrsMap: makeAttrsMap(startTagMatch.attrs),</span><br><span class="line">        parent: currentParent,</span><br><span class="line">        children: <span class="section">[]</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(!root)&#123;</span><br><span class="line">        <span class="attr">root</span> = element</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(currentParent)&#123;</span><br><span class="line">        currentParent.children.push(element)<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stack.push(element)<span class="comment">;</span></span><br><span class="line">    <span class="attr">currentParent</span> = element<span class="comment">;</span></span><br><span class="line">    continue<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们将 <code>startTagMatch</code> 得到的结果首先封装成 <code>element</code> ，这个就是最终形成的 AST 的节点，标签节点的 type 为 1。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const <span class="attr">startTagMatch</span> = parseStartTag()<span class="comment">;</span></span><br><span class="line">const <span class="attr">element</span> = &#123;</span><br><span class="line">    type: 1,</span><br><span class="line">    tag: startTagMatch.tagName,</span><br><span class="line">    attrsList: startTagMatch.attrs,</span><br><span class="line">    attrsMap: makeAttrsMap(startTagMatch.attrs),</span><br><span class="line">    parent: currentParent,</span><br><span class="line">    children: <span class="section">[]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后让 <code>root</code> 指向根节点的引用。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(!root)&#123;</span><br><span class="line">    <span class="attr">root</span> = element</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着我们将当前节点的 <code>element</code> 放入父节点 <code>currentParent</code> 的 <code>children</code> 数组中。</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">if</span>(currentParent)&#123;</span><br><span class="line">    currentParent<span class="selector-class">.children</span><span class="selector-class">.push</span>(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后将当前节点 <code>element</code> 压入 stack 栈中，并将 <code>currentParent</code> 指向当前节点，因为接下去下一个解析如果还是头标签或者是文本的话，会成为当前节点的子节点，如果是尾标签的话，那么将会从栈中取出当前节点，这种情况我们接下来要讲。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stack.push(element)<span class="comment">;</span></span><br><span class="line"><span class="attr">currentParent</span> = element<span class="comment">;</span></span><br><span class="line">continue<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>其中的 <code>makeAttrsMap</code> 是将 attrs 转换成 map 格式的一个方法。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function makeAttrsMap (attrs) &#123;</span><br><span class="line">    const <span class="attr">map</span> = &#123;&#125;</span><br><span class="line">    for (let <span class="attr">i</span> = <span class="number">0</span>, l = attrs.length<span class="comment">; i &lt; l; i++) &#123;</span></span><br><span class="line">        map<span class="section">[attrs[i]</span>.name] = attrs<span class="section">[i]</span>.value<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    return map</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="parseEndTag"><a href="#parseEndTag" class="headerlink" title="parseEndTag"></a>parseEndTag</h3><p>同样，我们在 <code>parseHTML</code> 中加入对尾标签的解析函数，为了匹配如“</div>”。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const <span class="attr">endTagMatch</span> = html.match(endTag)</span><br><span class="line"> if (endTagMatch) &#123;</span><br><span class="line">    advance(endTagMatch<span class="section">[0]</span>.length)<span class="comment">;</span></span><br><span class="line">    parseEndTag(endTagMatch<span class="section">[1]</span>)<span class="comment">;</span></span><br><span class="line">    continue<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用 <code>parseEndTag</code> 来解析尾标签，它会从 stack 栈中取出最近的跟自己标签名一致的那个元素，将 <code>currentParent</code> 指向那个元素，并将该元素之前的元素都从 stack 中出栈。</p>
<p>这里可能有同学会问，难道解析的尾元素不应该对应 stack 栈的最上面的一个元素才对吗？</p>
<p>其实不然，比如说可能会存在自闭合的标签，如“<br />”，或者是写了“<span>”但是没有加上“&lt; &#x2F;span&gt;”的情况，这时候就要找到 stack 中的第二个位置才能找到同名标签。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function parseEndTag (tagName) &#123;</span><br><span class="line">    let pos<span class="comment">;</span></span><br><span class="line">    for (<span class="attr">pos</span> = stack.length - <span class="number">1</span><span class="comment">; pos &gt;= 0; pos--) &#123;</span></span><br><span class="line">        if (stack<span class="section">[pos]</span>.<span class="attr">lowerCasedTag</span> === tagName.toLowerCase()) &#123;</span><br><span class="line">            break<span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (pos &gt;= 0) &#123;</span><br><span class="line">        <span class="attr">stack.length</span> = pos<span class="comment">;</span></span><br><span class="line">        <span class="attr">currentParent</span> = stack[pos]<span class="comment">; </span></span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="parseText"><a href="#parseText" class="headerlink" title="parseText"></a>parseText</h3><p>最后是解析文本，这个比较简单，只需要将文本取出，然后有两种情况，一种是普通的文本，直接构建一个节点 push 进当前 <code>currentParent</code> 的 children 中即可。还有一种情况是文本是如“”这样的 Vue.js 的表达式，这时候我们需要用 <code>parseText</code> 来将表达式转化成代码。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">text</span> = html.substring(<span class="number">0</span>, textEnd)</span><br><span class="line">advance(textEnd)</span><br><span class="line">let expression<span class="comment">;</span></span><br><span class="line">if (<span class="attr">expression</span> = parseText(text)) &#123;</span><br><span class="line">    currentParent.children.push(&#123;</span><br><span class="line">        type: 2,</span><br><span class="line">        text,</span><br><span class="line">        expression</span><br><span class="line">    &#125;)<span class="comment">;</span></span><br><span class="line">&#125; else &#123;</span><br><span class="line">    currentParent.children.push(&#123;</span><br><span class="line">        type: 3,</span><br><span class="line">        text,</span><br><span class="line">    &#125;)<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line">continue<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>我们会用到一个 <code>parseText</code> 函数。</p>
<figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> parseText (<span class="keyword">text</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!defaultTagRE.test(<span class="keyword">text</span>)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> tokens = [];</span><br><span class="line">    <span class="keyword">let</span> lastIndex = defaultTagRE.lastIndex = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> match, index</span><br><span class="line">    <span class="keyword">while</span> ((match = defaultTagRE.exec(<span class="keyword">text</span>))) &#123;</span><br><span class="line">        index = match.index</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (index &gt; lastIndex) &#123;</span><br><span class="line">            tokens.push(JSON.stringify(<span class="keyword">text</span>.slice(lastIndex, index)))</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">const</span> exp = match[<span class="number">1</span>].trim()</span><br><span class="line">        tokens.push(`_s($&#123;exp&#125;)`)</span><br><span class="line">        lastIndex = index + match[<span class="number">0</span>].length</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lastIndex &lt; <span class="keyword">text</span>.length) &#123;</span><br><span class="line">        tokens.push(JSON.stringify(<span class="keyword">text</span>.slice(lastIndex)))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tokens.<span class="keyword">join</span>(<span class="comment">&#x27;+&#x27;);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们使用一个 <code>tokens</code> 数组来存放解析结果，通过 <code>defaultTagRE</code> 来循环匹配该文本，如果是普通文本直接 <code>push</code> 到 <code>tokens</code> 数组中去，如果是表达式（），则转化成“_s(${exp})”的形式。</p>
<p>举个例子，如果我们有这样一个文本。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">div</span>&gt;hello,&#123;&#123;name&#125;&#125;.&lt;/<span class="selector-tag">div</span>&gt;</span><br></pre></td></tr></table></figure>

<p>最终得到 <code>tokens</code>。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">tokens</span> = [<span class="string">&#x27;hello,&#x27;</span>, _s(name), <span class="string">&#x27;.&#x27;</span>]<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>最终通过 <code>join</code> 返回表达式。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;hello&#x27;</span> + _s(name) + <span class="string">&#x27;.&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="processIf与processFor"><a href="#processIf与processFor" class="headerlink" title="processIf与processFor"></a>processIf与processFor</h3><p>最后介绍一下如何处理“<code>v-if</code>”以及“<code>v-for</code>”这样的 Vue.js 的表达式的，这里我们只简单介绍两个示例中用到的表达式解析。</p>
<p>我们只需要在解析头标签的内容中加入这两个表达式的解析函数即可，在这时“<code>v-for</code>”之类指令已经在属性解析时存入了 <code>attrsMap</code> 中了。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">if (html.match(startTagOpen)) &#123;</span><br><span class="line">    const <span class="attr">startTagMatch</span> = parseStartTag()<span class="comment">;</span></span><br><span class="line">    const <span class="attr">element</span> = &#123;</span><br><span class="line">        type: 1,</span><br><span class="line">        tag: startTagMatch.tagName,</span><br><span class="line">        attrsList: startTagMatch.attrs,</span><br><span class="line">        attrsMap: makeAttrsMap(startTagMatch.attrs),</span><br><span class="line">        parent: currentParent,</span><br><span class="line">        children: <span class="section">[]</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    processIf(element)<span class="comment">;</span></span><br><span class="line">    processFor(element)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    if(!root)&#123;</span><br><span class="line">        <span class="attr">root</span> = element</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(currentParent)&#123;</span><br><span class="line">        currentParent.children.push(element)<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stack.push(element)<span class="comment">;</span></span><br><span class="line">    <span class="attr">currentParent</span> = element<span class="comment">;</span></span><br><span class="line">    continue<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先我们需要定义一个 <code>getAndRemoveAttr</code> 函数，用来从 <code>el</code> 的 <code>attrsMap</code> 属性或是 <code>attrsList</code> 属性中取出 <code>name</code> 对应值。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function getAndRemoveAttr (el, name) &#123;</span><br><span class="line">    let val</span><br><span class="line">    if ((<span class="attr">val</span> = el.attrsMap[name]) != null) &#123;</span><br><span class="line">        const <span class="attr">list</span> = el.attrsList</span><br><span class="line">        for (let <span class="attr">i</span> = <span class="number">0</span>, l = list.length<span class="comment">; i &lt; l; i++) &#123;</span></span><br><span class="line">            if (list<span class="section">[i]</span>.<span class="attr">name</span> === name) &#123;</span><br><span class="line">                list.splice(i, 1)</span><br><span class="line">                break</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return val</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如说解析示例的 div 标签属性。</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">getAndRemoveAttr</span>(el, &#x27;v-for&#x27;);</span><br></pre></td></tr></table></figure>

<p>可有得到“item in sz”。</p>
<p>有了这个函数这样我们就可以开始实现 <code>processFor</code> 与 <code>processIf</code> 了。</p>
<p>“v-for”会将指令解析成 <code>for</code> 属性以及 <code>alias</code> 属性，而“v-if”会将条件都存入 <code>ifConditions</code> 数组中。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">function processFor (el) &#123;</span><br><span class="line">    let exp<span class="comment">;</span></span><br><span class="line">    if ((<span class="attr">exp</span> = getAndRemoveAttr(el, <span class="string">&#x27;v-for&#x27;</span>))) &#123;</span><br><span class="line">        const <span class="attr">inMatch</span> = exp.match(forAliasRE)<span class="comment">;</span></span><br><span class="line">        <span class="attr">el.for</span> = inMatch[<span class="number">2</span>].trim()<span class="comment">;</span></span><br><span class="line">        <span class="attr">el.alias</span> = inMatch[<span class="number">1</span>].trim()<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function processIf (el) &#123;</span><br><span class="line">    const <span class="attr">exp</span> = getAndRemoveAttr(el, <span class="string">&#x27;v-if&#x27;</span>)<span class="comment">;</span></span><br><span class="line">    if (exp) &#123;</span><br><span class="line">        <span class="attr">el.if</span> = exp<span class="comment">;</span></span><br><span class="line">        if (!el.ifConditions) &#123;</span><br><span class="line">            <span class="attr">el.ifConditions</span> = []<span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line">        el.ifConditions.push(&#123;</span><br><span class="line">            exp: exp,</span><br><span class="line">            block: el</span><br><span class="line">        &#125;)<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里，我们已经把 <code>parse</code> 的过程介绍完了，接下来看一下 <code>optimize</code>。</p>
<h2 id="optimize"><a href="#optimize" class="headerlink" title="optimize"></a>optimize</h2><p><code>optimize</code> 主要作用就跟它的名字一样，用作「优化」。</p>
<p>这个涉及到后面要讲 <code>patch</code> 的过程，因为 <code>patch</code> 的过程实际上是将 VNode 节点进行一层一层的比对，然后将「差异」更新到视图上。那么一些静态节点是不会根据数据变化而产生变化的，这些节点我们没有比对的需求，是不是可以跳过这些静态节点的比对，从而节省一些性能呢？</p>
<p>那么我们就需要为静态的节点做上一些「标记」，在 <code>patch</code> 的时候我们就可以直接跳过这些被标记的节点的比对，从而达到「优化」的目的。</p>
<p>经过 <code>optimize</code> 这层的处理，每个节点会加上 <code>static</code> 属性，用来标记是否是静态的。</p>
<p>得到如下结果。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&#x27;attrsMap&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;:class&#x27;</span>: <span class="string">&#x27;c&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;class&#x27;</span>: <span class="string">&#x27;demo&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;v-if&#x27;</span>: <span class="string">&#x27;isShow&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&#x27;classBinding&#x27;</span>: <span class="string">&#x27;c&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;if&#x27;</span>: <span class="string">&#x27;isShow&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;ifConditions&#x27;</span>: [</span><br><span class="line">        <span class="string">&#x27;exp&#x27;</span>: <span class="string">&#x27;isShow&#x27;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&#x27;staticClass&#x27;</span>: <span class="string">&#x27;demo&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;tag&#x27;</span>: <span class="string">&#x27;div&#x27;</span>,</span><br><span class="line">    <span class="comment">/* 静态标志 */</span></span><br><span class="line">    <span class="string">&#x27;static&#x27;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="string">&#x27;children&#x27;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&#x27;attrsMap&#x27;</span>: &#123;</span><br><span class="line">                <span class="string">&#x27;v-for&#x27;</span>: <span class="string">&quot;item in sz&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">&#x27;static&#x27;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">&#x27;alias&#x27;</span>: <span class="string">&quot;item&quot;</span>,</span><br><span class="line">            <span class="string">&#x27;for&#x27;</span>: <span class="string">&#x27;sz&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;forProcessed&#x27;</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="string">&#x27;tag&#x27;</span>: <span class="string">&#x27;span&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;children&#x27;</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="string">&#x27;expression&#x27;</span>: <span class="string">&#x27;_s(item)&#x27;</span>,</span><br><span class="line">                    <span class="string">&#x27;text&#x27;</span>: <span class="string">&#x27;&#123;&#123;item&#125;&#125;&#x27;</span>,</span><br><span class="line">                    <span class="string">&#x27;static&#x27;</span>: <span class="literal">false</span></span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们用代码实现一下 <code>optimize</code> 函数。</p>
<h3 id="isStatic"><a href="#isStatic" class="headerlink" title="isStatic"></a>isStatic</h3><p>首先实现一个 <code>isStatic</code> 函数，传入一个 node 判断该 node 是否是静态节点。判断的标准是当 type 为 2（表达式节点）则是非静态节点，当 type 为 3（文本节点）的时候则是静态节点，当然，如果存在 <code>if</code> 或者 <code>for</code>这样的条件的时候（表达式节点），也是非静态节点。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isStatic</span> <span class="params">(node)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node.<span class="built_in">type</span> === <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node.<span class="built_in">type</span> === <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (!node.<span class="keyword">if</span> &amp;&amp; !node.<span class="keyword">for</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="markStatic"><a href="#markStatic" class="headerlink" title="markStatic"></a>markStatic</h3><p><code>markStatic</code> 为所有的节点标记上 <code>static</code>，遍历所有节点通过 <code>isStatic</code> 来判断当前节点是否是静态节点，此外，会遍历当前节点的所有子节点，如果子节点是非静态节点，那么当前节点也是非静态节点。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function markStatic (node) &#123;</span><br><span class="line">    <span class="attr">node.static</span> = isStatic(node)<span class="comment">;</span></span><br><span class="line">    if (<span class="attr">node.type</span> === <span class="number">1</span>) &#123;</span><br><span class="line">        for (let <span class="attr">i</span> = <span class="number">0</span>, l = node.children.length<span class="comment">; i &lt; l; i++) &#123;</span></span><br><span class="line">            const <span class="attr">child</span> = node.children[i]<span class="comment">;</span></span><br><span class="line">            markStatic(child)<span class="comment">;</span></span><br><span class="line">            if (!child.static) &#123;</span><br><span class="line">                <span class="attr">node.static</span> = <span class="literal">false</span><span class="comment">;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="markStaticRoots"><a href="#markStaticRoots" class="headerlink" title="markStaticRoots"></a>markStaticRoots</h3><p>接下来是 <code>markStaticRoots</code> 函数，用来标记 <code>staticRoot</code>（静态根）。这个函数实现比较简单，简单来将就是如果当前节点是静态节点，同时满足该节点并不是只有一个文本节点左右子节点（作者认为这种情况的优化消耗会大于收益）时，标记 <code>staticRoot</code> 为 true，否则为 false。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function markStaticRoots (node) &#123;</span><br><span class="line">    if (<span class="attr">node.type</span> === <span class="number">1</span>) &#123;</span><br><span class="line">        if (node.static &amp;&amp; node.children.length &amp;&amp; !(</span><br><span class="line">        <span class="attr">node.children.length</span> === <span class="number">1</span> &amp;&amp;</span><br><span class="line">        node.children<span class="section">[0]</span>.<span class="attr">type</span> === <span class="number">3</span></span><br><span class="line">        )) &#123;</span><br><span class="line">            <span class="attr">node.staticRoot</span> = <span class="literal">true</span><span class="comment">;</span></span><br><span class="line">            return<span class="comment">;</span></span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            <span class="attr">node.staticRoot</span> = <span class="literal">false</span><span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="optimize-1"><a href="#optimize-1" class="headerlink" title="optimize"></a>optimize</h3><p>有了以上的函数，就可以实现 <code>optimize</code> 了。</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function optimize (rootAst) &#123;</span><br><span class="line">    <span class="built_in">markStatic</span>(rootAst);</span><br><span class="line">    <span class="built_in">markStaticRoots</span>(rootAst);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="generate"><a href="#generate" class="headerlink" title="generate"></a>generate</h2><p><code>generate</code> 会将 AST 转化成 render funtion 字符串，最终得到 render 的字符串以及 staticRenderFns 字符串。</p>
<p>首先带大家感受一下真实的 Vue.js 编译得到的结果。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">with</span>(<span class="params"><span class="variable language_">this</span></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> (isShow) ? </span><br><span class="line">    <span class="title function_">_c</span>(</span><br><span class="line">        <span class="string">&#x27;div&#x27;</span>,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">staticClass</span>: <span class="string">&quot;demo&quot;</span>,</span><br><span class="line">            <span class="attr">class</span>: c</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">_l</span>(</span><br><span class="line">            (sz),</span><br><span class="line">            <span class="keyword">function</span>(<span class="params">item</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="title function_">_c</span>(<span class="string">&#x27;span&#x27;</span>,[<span class="title function_">_v</span>(<span class="title function_">_s</span>(item))])</span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line">    : <span class="title function_">_e</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到这里可能会纳闷了，这些 <code>_c</code>，<code>_l</code> 到底是什么？其实他们是 Vue.js 对一些函数的简写，比如说 <code>_c</code> 对应的是 <code>createElement</code> 这个函数。没关系，我们把它用 VNode 的形式写出来就会明白了，这个对接上一章写的 VNode 函数。</p>
<p>首先是第一层 div 节点。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">render</span> () &#123;</span><br><span class="line">    <span class="keyword">return</span> isShow ? (<span class="keyword">new</span> <span class="built_in">VNode</span>(<span class="string">&#x27;div&#x27;</span>, &#123;</span><br><span class="line">        <span class="string">&#x27;staticClass&#x27;</span>: <span class="string">&#x27;demo&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;class&#x27;</span>: c</span><br><span class="line">    &#125;, [ <span class="comment">/*这里还有子节点*/</span> ])) : <span class="built_in">createEmptyVNode</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们在 <code>children</code> 中加上第二层 span 及其子文本节点节点。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 渲染v-for列表 */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">renderList</span> (val, render) &#123;</span><br><span class="line">    <span class="keyword">let</span> ret = <span class="keyword">new</span> <span class="title class_">Array</span>(val.<span class="property">length</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, l = val.<span class="property">length</span>; i &lt; l; i++) &#123;</span><br><span class="line">        ret[i] = <span class="title function_">render</span>(val[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">render () &#123;</span><br><span class="line">    <span class="keyword">return</span> isShow ? (<span class="keyword">new</span> <span class="title class_">VNode</span>(<span class="string">&#x27;div&#x27;</span>, &#123;</span><br><span class="line">        <span class="string">&#x27;staticClass&#x27;</span>: <span class="string">&#x27;demo&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;class&#x27;</span>: c</span><br><span class="line">    &#125;, </span><br><span class="line">        <span class="comment">/* begin */</span></span><br><span class="line">        <span class="title function_">renderList</span>(sz, <span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">VNode</span>(<span class="string">&#x27;span&#x27;</span>, &#123;&#125;, [</span><br><span class="line">                <span class="title function_">createTextVNode</span>(item);</span><br><span class="line">            ]);</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">/* end */</span></span><br><span class="line">    )) : <span class="title function_">createEmptyVNode</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那我们如何来实现一个 <code>generate</code> 呢？</p>
<h3 id="genIf"><a href="#genIf" class="headerlink" title="genIf"></a>genIf</h3><p>首先实现一个处理 <code>if</code> 条件的 <code>genIf</code> 函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">genIf</span> (el) &#123;</span><br><span class="line">    el.<span class="property">ifProcessed</span> = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (!el.<span class="property">ifConditions</span>.<span class="property">length</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;_e()&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`(<span class="subst">$&#123;el.ifConditions[<span class="number">0</span>].exp&#125;</span>)?<span class="subst">$&#123;genElement(el.ifConditions[<span class="number">0</span>].block)&#125;</span>: _e()`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="genFor"><a href="#genFor" class="headerlink" title="genFor"></a>genFor</h3><p>然后是处理 <code>for</code> 循环的函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">genFor</span> (el) &#123;</span><br><span class="line">    el.<span class="property">forProcessed</span> = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> exp = el.<span class="property">for</span>;</span><br><span class="line">    <span class="keyword">const</span> alias = el.<span class="property">alias</span>;</span><br><span class="line">    <span class="keyword">const</span> iterator1 = el.<span class="property">iterator1</span> ? <span class="string">`,<span class="subst">$&#123;el.iterator1&#125;</span>`</span> : <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">const</span> iterator2 = el.<span class="property">iterator2</span> ? <span class="string">`,<span class="subst">$&#123;el.iterator2&#125;</span>`</span> : <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">`_l((<span class="subst">$&#123;exp&#125;</span>),`</span> +</span><br><span class="line">        <span class="string">`function(<span class="subst">$&#123;alias&#125;</span><span class="subst">$&#123;iterator1&#125;</span><span class="subst">$&#123;iterator2&#125;</span>)&#123;`</span> +</span><br><span class="line">        <span class="string">`return <span class="subst">$&#123;genElement(el)&#125;</span>`</span> +</span><br><span class="line">    <span class="string">&#x27;&#125;)&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="genText"><a href="#genText" class="headerlink" title="genText"></a>genText</h3><p>处理文本节点的函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">genText</span> (el) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`_v(<span class="subst">$&#123;el.expression&#125;</span>)`</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="genElement"><a href="#genElement" class="headerlink" title="genElement"></a>genElement</h3><p>接下来实现一下 <code>genElement</code>，这是一个处理节点的函数，因为它依赖 <code>genChildren</code> 以及g <code>enNode</code> ，所以这三个函数放在一起讲。</p>
<p>genElement会根据当前节点是否有 <code>if</code> 或者 <code>for</code> 标记然后判断是否要用 <code>genIf</code> 或者 <code>genFor</code> 处理，否则通过 <code>genChildren</code> 处理子节点，同时得到 <code>staticClass</code>、<code>class</code> 等属性。</p>
<p><code>genChildren</code> 比较简单，遍历所有子节点，通过 <code>genNode</code> 处理后用“，”隔开拼接成字符串。</p>
<p><code>genNode</code> 则是根据 <code>type</code> 来判断该节点是用文本节点 <code>genText</code> 还是标签节点 <code>genElement</code> 来处理。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">genNode</span> (el) &#123;</span><br><span class="line">    <span class="keyword">if</span> (el.<span class="property">type</span> === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">genElement</span>(el);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">genText</span>(el);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">genChildren</span> (el) &#123;</span><br><span class="line">    <span class="keyword">const</span> children = el.<span class="property">children</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (children &amp;&amp; children.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;children.map(genNode).join(<span class="string">&#x27;,&#x27;</span>)&#125;</span>`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">genElement</span> (el) &#123;</span><br><span class="line">    <span class="keyword">if</span> (el.<span class="property">if</span> &amp;&amp; !el.<span class="property">ifProcessed</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">genIf</span>(el);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (el.<span class="property">for</span> &amp;&amp; !el.<span class="property">forProcessed</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">genFor</span>(el);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> children = <span class="title function_">genChildren</span>(el);</span><br><span class="line">        <span class="keyword">let</span> code;</span><br><span class="line">        code = <span class="string">`_c(&#x27;<span class="subst">$&#123;el.tag&#125;</span>,&#x27;&#123;</span></span><br><span class="line"><span class="string">            staticClass: <span class="subst">$&#123;el.attrsMap &amp;&amp; el.attrsMap[<span class="string">&#x27;:class&#x27;</span>]&#125;</span>,</span></span><br><span class="line"><span class="string">            class: <span class="subst">$&#123;el.attrsMap &amp;&amp; el.attrsMap[<span class="string">&#x27;class&#x27;</span>]&#125;</span>,</span></span><br><span class="line"><span class="string">        &#125;<span class="subst">$&#123;</span></span></span><br><span class="line"><span class="subst"><span class="string">            children ? <span class="string">`,<span class="subst">$&#123;children&#125;</span>`</span> : <span class="string">&#x27;&#x27;</span></span></span></span><br><span class="line"><span class="subst"><span class="string">        &#125;</span>)`</span></span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="generate-1"><a href="#generate-1" class="headerlink" title="generate"></a>generate</h3><p>最后我们使用上面的函数来实现 <code>generate</code>，其实很简单，我们只需要将整个 AST 传入后判断是否为空，为空则返回一个 div 标签，否则通过 <code>generate</code> 来处理。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function generate (rootAst) &#123;</span><br><span class="line">    <span class="keyword">const</span> code = rootAst ? genElement(rootAst) : <span class="string">&#x27;_c(&quot;div&quot;)&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        render: `with(<span class="keyword">this</span>)&#123;<span class="keyword">return</span> $&#123;code&#125;&#125;`,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经历过这些过程以后，我们已经把 template 顺利转成了 render function 了，接下来我们将介绍 <code>patch</code> 的过程，来看一下具体 VNode 节点如何进行差异的比对。</p>
<p>注：本节代码参考<a href="https://link.juejin.cn/?target=https://github.com/answershuto/VueDemo/blob/master/%25E3%2580%258Atemplate%2520%25E6%25A8%25A1%25E6%259D%25BF%25E6%2598%25AF%25E6%2580%258E%25E6%25A0%25B7%25E9%2580%259A%25E8%25BF%2587%2520Compile%2520%25E7%25BC%2596%25E8%25AF%2591%25E7%259A%2584%25E3%2580%258B.js" title="https://github.com/answershuto/VueDemo/blob/master/%E3%80%8Atemplate%20%E6%A8%A1%E6%9D%BF%E6%98%AF%E6%80%8E%E6%A0%B7%E9%80%9A%E8%BF%87%20Compile%20%E7%BC%96%E8%AF%91%E7%9A%84%E3%80%8B.js">《template 模板是怎样通过 Compile 编译的》</a>。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/10/29/5-template-%E6%A8%A1%E6%9D%BF%E6%98%AF%E6%80%8E%E6%A0%B7%E9%80%9A%E8%BF%87-Compile-%E7%BC%96%E8%AF%91%E7%9A%84/" data-id="claxeer9k0004v8w1cuvjfojv" data-title="5.template 模板是怎样通过 Compile 编译的" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-4-实现-Virtual-DOM-下的一个-VNode-节点" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/10/29/4-%E5%AE%9E%E7%8E%B0-Virtual-DOM-%E4%B8%8B%E7%9A%84%E4%B8%80%E4%B8%AA-VNode-%E8%8A%82%E7%82%B9/" class="article-date">
  <time class="dt-published" datetime="2022-10-29T12:13:04.000Z" itemprop="datePublished">2022-10-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/10/29/4-%E5%AE%9E%E7%8E%B0-Virtual-DOM-%E4%B8%8B%E7%9A%84%E4%B8%80%E4%B8%AA-VNode-%E8%8A%82%E7%82%B9/">4.实现 Virtual DOM 下的一个 VNode 节点</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="什么是VNode"><a href="#什么是VNode" class="headerlink" title="什么是VNode"></a>什么是VNode</h2><p>我们知道，render function 会被转化成 VNode 节点。Virtual DOM 其实就是一棵以 JavaScript 对象（VNode 节点）作为基础的树，用对象属性来描述节点，实际上它只是一层对真实 DOM 的抽象。最终可以通过一系列操作使这棵树映射到真实环境上。由于 Virtual DOM 是以 JavaScript 对象为基础而不依赖真实平台环境，所以使它具有了跨平台的能力，比如说浏览器平台、Weex、Node 等。</p>
<h2 id="实现一个VNode"><a href="#实现一个VNode" class="headerlink" title="实现一个VNode"></a>实现一个VNode</h2><p>VNode 归根结底就是一个 JavaScript 对象，只要这个类的一些属性可以正确直观地描述清楚当前节点的信息即可。我们来实现一个简单的 <code>VNode</code> 类，加入一些基本属性，为了便于理解，我们先不考虑复杂的情况。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VNode</span> &#123;</span><br><span class="line">    <span class="keyword">constructor</span> (tag, <span class="keyword">data</span>, children, text, elm) &#123;</span><br><span class="line">        <span class="comment">/*当前节点的标签名*/</span></span><br><span class="line">        <span class="keyword">this</span>.tag = tag;</span><br><span class="line">        <span class="comment">/*当前节点的一些数据信息，比如props、attrs等数据*/</span></span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">data</span> = <span class="keyword">data</span>;</span><br><span class="line">        <span class="comment">/*当前节点的子节点，是一个数组*/</span></span><br><span class="line">        <span class="keyword">this</span>.children = children;</span><br><span class="line">        <span class="comment">/*当前节点的文本*/</span></span><br><span class="line">        <span class="keyword">this</span>.text = text;</span><br><span class="line">        <span class="comment">/*当前虚拟节点对应的真实dom节点*/</span></span><br><span class="line">        <span class="keyword">this</span>.elm = elm;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如我目前有这么一个 Vue 组件。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;demo&quot;</span> <span class="attr">v-show</span>=<span class="string">&quot;isShow&quot;</span>&gt;</span></span><br><span class="line">    This is a span.</span><br><span class="line">  <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>用 JavaScript 代码形式就是这样的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">render</span> () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">VNode</span>(</span><br><span class="line">        <span class="string">&#x27;span&#x27;</span>,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 指令集合数组 */</span></span><br><span class="line">            <span class="attr">directives</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">/* v-show指令 */</span></span><br><span class="line">                    <span class="attr">rawName</span>: <span class="string">&#x27;v-show&#x27;</span>,</span><br><span class="line">                    <span class="attr">expression</span>: <span class="string">&#x27;isShow&#x27;</span>,</span><br><span class="line">                    <span class="attr">name</span>: <span class="string">&#x27;show&#x27;</span>,</span><br><span class="line">                    <span class="attr">value</span>: <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            <span class="comment">/* 静态class */</span></span><br><span class="line">            <span class="attr">staticClass</span>: <span class="string">&#x27;demo&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        [ <span class="keyword">new</span> <span class="title class_">VNode</span>(<span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="string">&#x27;This is a span.&#x27;</span>) ]</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看看转换成 VNode 以后的情况。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    tag: <span class="string">&#x27;span&#x27;</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        <span class="comment">/* 指令集合数组 */</span></span><br><span class="line">        directives: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/* v-show指令 */</span></span><br><span class="line">                rawName: <span class="string">&#x27;v-show&#x27;</span>,</span><br><span class="line">                expression: <span class="string">&#x27;isShow&#x27;</span>,</span><br><span class="line">                name: <span class="string">&#x27;show&#x27;</span>,</span><br><span class="line">                value: true</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="comment">/* 静态class */</span></span><br><span class="line">        staticClass: <span class="string">&#x27;demo&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    text: undefined,</span><br><span class="line">    children: [</span><br><span class="line">        <span class="comment">/* 子节点是一个文本VNode节点 */</span></span><br><span class="line">        &#123;</span><br><span class="line">            tag: undefined,</span><br><span class="line">            data: undefined,</span><br><span class="line">            text: <span class="string">&#x27;This is a span.&#x27;</span>,</span><br><span class="line">            children: undefined</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们可以将 VNode 进一步封装一下，可以实现一些产生常用 VNode 的方法。</p>
<ul>
<li>创建一个空节点</li>
</ul>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function createEmptyVNode () &#123;</span><br><span class="line">    const <span class="attr">node</span> = new VNode()<span class="comment">;</span></span><br><span class="line">    <span class="attr">node.text</span> = <span class="string">&#x27;&#x27;</span><span class="comment">;</span></span><br><span class="line">    return node<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>创建一个文本节点</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createTextVNode</span> (val) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">VNode</span>(<span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="title class_">String</span>(val));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>克隆一个 VNode 节点</li>
</ul>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">cloneVNode</span> <span class="params">(node)</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> cloneVnode = <span class="keyword">new</span> <span class="built_in">VNode</span>(</span><br><span class="line">        node.tag,</span><br><span class="line">        node.data,</span><br><span class="line">        node.children,</span><br><span class="line">        node.text,</span><br><span class="line">        node.elm</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> cloneVnode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总的来说，VNode 就是一个 JavaScript 对象，用 JavaScript 对象的属性来描述当前节点的一些状态，用 VNode 节点的形式来模拟一棵 Virtual DOM 树。</p>
<p>注：本节代码参考<a href="https://link.juejin.cn/?target=https://github.com/answershuto/VueDemo/blob/master/%25E3%2580%258A%25E5%25AE%259E%25E7%258E%25B0%2520Virtual%2520DOM%2520%25E4%25B8%258B%25E7%259A%2584%25E4%25B8%2580%25E4%25B8%25AA%2520VNode%2520%25E8%258A%2582%25E7%2582%25B9%25E3%2580%258B.js" title="https://github.com/answershuto/VueDemo/blob/master/%E3%80%8A%E5%AE%9E%E7%8E%B0%20Virtual%20DOM%20%E4%B8%8B%E7%9A%84%E4%B8%80%E4%B8%AA%20VNode%20%E8%8A%82%E7%82%B9%E3%80%8B.js">《实现 Virtual DOM 下的一个 VNode 节点》</a>。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/10/29/4-%E5%AE%9E%E7%8E%B0-Virtual-DOM-%E4%B8%8B%E7%9A%84%E4%B8%80%E4%B8%AA-VNode-%E8%8A%82%E7%82%B9/" data-id="claxeer9j0002v8w17btp2b1q" data-title="4.实现 Virtual DOM 下的一个 VNode 节点" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-3-响应式系统的依赖收集追踪原理" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/10/29/3-%E5%93%8D%E5%BA%94%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%94%B6%E9%9B%86%E8%BF%BD%E8%B8%AA%E5%8E%9F%E7%90%86/" class="article-date">
  <time class="dt-published" datetime="2022-10-29T12:12:45.000Z" itemprop="datePublished">2022-10-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/10/29/3-%E5%93%8D%E5%BA%94%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%94%B6%E9%9B%86%E8%BF%BD%E8%B8%AA%E5%8E%9F%E7%90%86/">3.响应式系统的依赖收集追踪原理</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="为什么要依赖收集？"><a href="#为什么要依赖收集？" class="headerlink" title="为什么要依赖收集？"></a>为什么要依赖收集？</h2><p><strong>先举个栗子🌰</strong></p>
<p>我们现在有这么一个 Vue 对象。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">    template: </span><br><span class="line">        `&lt;div&gt;</span><br><span class="line">            &lt;span&gt;&#123;&#123;text1&#125;&#125;&lt;/<span class="selector-tag">span</span>&gt; </span><br><span class="line">            &lt;<span class="selector-tag">span</span>&gt;&#123;&#123;text2&#125;&#125;&lt;/<span class="selector-tag">span</span>&gt; </span><br><span class="line">        &lt;<span class="selector-tag">div</span>&gt;`,</span><br><span class="line">    data: &#123;</span><br><span class="line">        text1: <span class="string">&#x27;text1&#x27;</span>,</span><br><span class="line">        text2: <span class="string">&#x27;text2&#x27;</span>,</span><br><span class="line">        text3: <span class="string">&#x27;text3&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>然后我们做了这么一个操作。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">this.text3</span> = <span class="string">&#x27;modify text3&#x27;</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>我们修改了 <code>data</code> 中 <code>text3</code> 的数据，但是因为视图中并不需要用到 <code>text3</code> ，所以我们并不需要触发上一章所讲的 <code>cb</code> 函数来更新视图，调用 <code>cb</code> 显然是不正确的。</p>
<p><strong>再来一个栗子🌰</strong></p>
<p>假设我们现在有一个全局的对象，我们可能会在多个 Vue 对象中用到它进行展示。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">let globalObj = &#123;</span><br><span class="line">    text1: <span class="string">&#x27;text1&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let o1 = new Vue(&#123;</span><br><span class="line">    template:</span><br><span class="line">        `&lt;div&gt;</span><br><span class="line">            &lt;span&gt;&#123;&#123;text1&#125;&#125;&lt;/<span class="selector-tag">span</span>&gt; </span><br><span class="line">        &lt;<span class="selector-tag">div</span>&gt;`,</span><br><span class="line">    data: globalObj</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">let o2 = new Vue(&#123;</span><br><span class="line">    template:</span><br><span class="line">        `&lt;div&gt;</span><br><span class="line">            &lt;span&gt;&#123;&#123;text1&#125;&#125;&lt;/<span class="selector-tag">span</span>&gt; </span><br><span class="line">        &lt;<span class="selector-tag">div</span>&gt;`,</span><br><span class="line">    data: globalObj</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这个时候，我们执行了如下操作。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">globalObj.text1</span> = <span class="string">&#x27;hello,text1&#x27;</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>我们应该需要通知 <code>o1</code> 以及 <code>o2</code> 两个vm实例进行视图的更新，「依赖收集」会让 <code>text1</code> 这个数据知道“哦～有两个地方依赖我的数据，我变化的时候需要通知它们～”。</p>
<p>最终会形成数据与视图的一种对应关系，如下图。</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/1/5/160c4572fdd738f2~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp"></p>
<p>接下来我们来介绍一下「依赖收集」是如何实现的。</p>
<h2 id="订阅者-Dep"><a href="#订阅者-Dep" class="headerlink" title="订阅者 Dep"></a>订阅者 Dep</h2><p>首先我们来实现一个订阅者 Dep ，它的主要作用是用来存放 <code>Watcher</code> 观察者对象。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dep</span> &#123;</span><br><span class="line">    <span class="keyword">constructor</span> () &#123;</span><br><span class="line">        <span class="comment">/* 用来存放Watcher对象的数组 */</span></span><br><span class="line">        <span class="keyword">this</span>.subs = [];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 在subs中添加一个Watcher对象 */</span></span><br><span class="line">    addSub (sub) &#123;</span><br><span class="line">        <span class="keyword">this</span>.subs.push(sub);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 通知所有Watcher对象更新视图 */</span></span><br><span class="line">    notify () &#123;</span><br><span class="line">        <span class="keyword">this</span>.subs.forEach((sub) =&gt; &#123;</span><br><span class="line">            sub.update();</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了便于理解我们只实现了添加的部分代码，主要是两件事情：</p>
<ol>
<li>用 <code>addSub</code> 方法可以在目前的 <code>Dep</code> 对象中增加一个 <code>Watcher</code> 的订阅操作；</li>
<li>用 <code>notify</code> 方法通知目前 <code>Dep</code> 对象的 <code>subs</code> 中的所有 <code>Watcher</code> 对象触发更新操作。</li>
</ol>
<h2 id="观察者-Watcher"><a href="#观察者-Watcher" class="headerlink" title="观察者 Watcher"></a>观察者 Watcher</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Watcher</span> &#123;</span><br><span class="line">    <span class="keyword">constructor</span> () &#123;</span><br><span class="line">        <span class="comment">/* 在new一个Watcher对象时将该对象赋值给Dep.target，在get中会用到 */</span></span><br><span class="line">        Dep.target = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 更新视图的方法 */</span></span><br><span class="line">    update () &#123;</span><br><span class="line">        console.log(<span class="string">&quot;视图更新啦～&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Dep.target = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<h2 id="依赖收集"><a href="#依赖收集" class="headerlink" title="依赖收集"></a>依赖收集</h2><p>接下来我们修改一下 <code>defineReactive</code> 以及 Vue 的构造函数，来完成依赖收集。</p>
<p>我们在闭包中增加了一个 Dep 类的对象，用来收集 <code>Watcher</code> 对象。在对象被「读」的时候，会触发 <code>reactiveGetter</code> 函数把当前的 <code>Watcher</code> 对象（存放在 Dep.target 中）收集到 <code>Dep</code> 类中去。之后如果当该对象被「<strong>写</strong>」的时候，则会触发 <code>reactiveSetter</code> 方法，通知 <code>Dep</code> 类调用 <code>notify</code> 来触发所有 <code>Watcher</code> 对象的 <code>update</code> 方法更新对应视图。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">function defineReactive (obj, key, <span class="keyword">val</span>) &#123;</span><br><span class="line">    <span class="comment">/* 一个Dep类对象 */</span></span><br><span class="line">    <span class="keyword">const</span> dep = new Dep();</span><br><span class="line">    </span><br><span class="line">    Object.defineProperty(obj, key, &#123;</span><br><span class="line">        enumerable: <span class="literal">true</span>,</span><br><span class="line">        configurable: <span class="literal">true</span>,</span><br><span class="line">        <span class="keyword">get</span>: function reactiveGetter () &#123;</span><br><span class="line">            <span class="comment">/* 将Dep.target（即当前的Watcher对象存入dep的subs中） */</span></span><br><span class="line">            dep.addSub(Dep.target);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">val</span>;         </span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">set</span>: function reactiveSetter (newVal) &#123;</span><br><span class="line">            <span class="keyword">if</span> (newVal === <span class="keyword">val</span>) <span class="keyword">return</span>;</span><br><span class="line">            <span class="comment">/* 在set的时候触发dep的notify来通知所有的Watcher对象更新视图 */</span></span><br><span class="line">            dep.notify();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vue</span> &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(options) &#123;</span><br><span class="line">        <span class="keyword">this</span>._data = options.<span class="keyword">data</span>;</span><br><span class="line">        observer(<span class="keyword">this</span>._data);</span><br><span class="line">        <span class="comment">/* 新建一个Watcher观察者对象，这时候Dep.target会指向这个Watcher对象 */</span></span><br><span class="line">        new Watcher();</span><br><span class="line">        <span class="comment">/* 在这里模拟render的过程，为了触发test属性的get函数 */</span></span><br><span class="line">        console.log(<span class="string">&#x27;render~&#x27;</span>, <span class="keyword">this</span>._data.test);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>总结一下。</p>
<p>首先在 <code>observer</code> 的过程中会注册 <code>get</code> 方法，该方法用来进行「<strong>依赖收集</strong>」。在它的闭包中会有一个 <code>Dep</code> 对象，这个对象用来存放 Watcher 对象的实例。其实「<strong>依赖收集</strong>」的过程就是把 <code>Watcher</code> 实例存放到对应的 <code>Dep</code> 对象中去。<code>get</code> 方法可以让当前的 <code>Watcher</code> 对象（Dep.target）存放到它的 subs 中（<code>addSub</code>）方法，在数据变化时，<code>set</code> 会调用 <code>Dep</code> 对象的 <code>notify</code> 方法通知它内部所有的 <code>Watcher</code> 对象进行视图更新。</p>
<p>这是 <code>Object.defineProperty</code> 的 <code>set/get</code> 方法处理的事情，那么「<strong>依赖收集</strong>」的前提条件还有两个：</p>
<ol>
<li>触发 <code>get</code> 方法；</li>
<li>新建一个 Watcher 对象。</li>
</ol>
<p>这个我们在 Vue 的构造类中处理。新建一个 <code>Watcher</code> 对象只需要 new 出来，这时候 <code>Dep.target</code> 已经指向了这个 new 出来的 <code>Watcher</code> 对象来。而触发 <code>get</code> 方法也很简单，实际上只要把 render function 进行渲染，那么其中的依赖的对象都会被「读取」，这里我们通过打印来模拟这个过程，读取 test 来触发 <code>get</code> 进行「依赖收集」。</p>
<p>本章我们介绍了「依赖收集」的过程，配合之前的响应式原理，已经把整个「响应式系统」介绍完毕了。其主要就是 <code>get</code> 进行「依赖收集」。<code>set</code> 通过观察者来更新视图，配合下图仔细捋一捋，相信一定能搞懂它！</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/12/19/1606edad5ca9e23d~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp"></p>
<p>注：本节代码参考<a href="https://link.juejin.cn/?target=https://github.com/answershuto/VueDemo/blob/master/%25E3%2580%258A%25E5%2593%258D%25E5%25BA%2594%25E5%25BC%258F%25E7%25B3%25BB%25E7%25BB%259F%25E7%259A%2584%25E4%25BE%259D%25E8%25B5%2596%25E6%2594%25B6%25E9%259B%2586%25E8%25BF%25BD%25E8%25B8%25AA%25E5%258E%259F%25E7%2590%2586%25E3%2580%258B.js" title="https://github.com/answershuto/VueDemo/blob/master/%E3%80%8A%E5%93%8D%E5%BA%94%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%94%B6%E9%9B%86%E8%BF%BD%E8%B8%AA%E5%8E%9F%E7%90%86%E3%80%8B.js">《响应式系统的依赖收集追踪原理》</a>。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/10/29/3-%E5%93%8D%E5%BA%94%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%94%B6%E9%9B%86%E8%BF%BD%E8%B8%AA%E5%8E%9F%E7%90%86/" data-id="claxeer9k0003v8w1d996eu0d" data-title="3.响应式系统的依赖收集追踪原理" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2-响应式系统的基本原理" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/10/29/2-%E5%93%8D%E5%BA%94%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/" class="article-date">
  <time class="dt-published" datetime="2022-10-29T12:12:00.000Z" itemprop="datePublished">2022-10-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/10/29/2-%E5%93%8D%E5%BA%94%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/">2.响应式系统的基本原理</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="响应式系统"><a href="#响应式系统" class="headerlink" title="响应式系统"></a>响应式系统</h2><p>Vue.js 是一款 MVVM 框架，数据模型仅仅是普通的 JavaScript 对象，但是对这些对象进行操作时，却能影响对应视图，它的核心实现就是「<strong>响应式系统</strong>」。尽管我们在使用 Vue.js 进行开发时不会直接修改「<strong>响应式系统</strong>」，但是理解它的实现有助于避开一些常见的「<strong>坑</strong>」，也有助于在遇见一些琢磨不透的问题时可以深入其原理来解决它。</p>
<h2 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty"></a><code>Object.defineProperty</code></h2><p>首先我们来介绍一下 <a href="https://link.juejin.cn/?target=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" title="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty"><code>Object.defineProperty</code></a>，Vue.js就是基于它实现「<strong>响应式系统</strong>」的。</p>
<p>首先是使用方法：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">/*</span></span><br><span class="line">    <span class="attr">obj:</span> <span class="string">目标对象</span></span><br><span class="line">    <span class="attr">prop:</span> <span class="string">需要操作的目标对象的属性名</span></span><br><span class="line">    <span class="attr">descriptor:</span> <span class="string">描述符</span></span><br><span class="line">    </span><br><span class="line">    <span class="string">return</span> <span class="string">value</span> <span class="string">传入对象</span></span><br><span class="line"><span class="string">*/</span></span><br><span class="line"><span class="string">Object.defineProperty(obj,</span> <span class="string">prop,</span> <span class="string">descriptor)</span></span><br></pre></td></tr></table></figure>

<p>descriptor的一些属性，简单介绍几个属性，具体可以参考 <a href="https://link.juejin.cn/?target=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" title="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">MDN 文档</a>。</p>
<ul>
<li><code>enumerable</code>，属性是否可枚举，默认 false。</li>
<li><code>configurable</code>，属性是否可以被修改或者删除，默认 false。</li>
<li><code>get</code>，获取属性的方法。</li>
<li><code>set</code>，设置属性的方法。</li>
</ul>
<h2 id="实现-observer（可观察的）"><a href="#实现-observer（可观察的）" class="headerlink" title="实现 observer（可观察的）"></a>实现 <code>observer</code>（可观察的）</h2><p>知道了 <code>Object.defineProperty</code> 以后，我们来用它使对象变成可观察的。</p>
<p>这一部分的内容我们在第二小节中已经初步介绍过，在 <code>init</code> 的阶段会进行初始化，对数据进行「<strong>响应式化</strong>」。</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/12/19/1606e8abbababbe6~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp"></p>
<p>为了便于理解，我们不考虑数组等复杂的情况，只对对象进行处理。</p>
<p>首先我们定义一个 <code>cb</code> 函数，这个函数用来模拟视图更新，调用它即代表更新视图，内部可以是一些更新视图的方法。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">cb</span> <span class="params">(val)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 渲染视图 */</span></span><br><span class="line">    console.<span class="built_in">log</span>(<span class="string">&quot;视图更新啦～&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们定义一个 <code>defineReactive</code> ，这个方法通过 <code>Object.defineProperty</code> 来实现对对象的「<strong>响应式</strong>」化，入参是一个 obj（需要绑定的对象）、key（obj的某一个属性），val（具体的值）。经过 <code>defineReactive</code> 处理以后，我们的 obj 的 key 属性在「读」的时候会触发 <code>reactiveGetter</code> 方法，而在该属性被「写」的时候则会触发 <code>reactiveSetter</code> 方法。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function defineReactive (obj, key, <span class="keyword">val</span>) &#123;</span><br><span class="line">    Object.defineProperty(obj, key, &#123;</span><br><span class="line">        enumerable: <span class="literal">true</span>,       <span class="comment">/* 属性可枚举 */</span></span><br><span class="line">        configurable: <span class="literal">true</span>,     <span class="comment">/* 属性可被修改或删除 */</span></span><br><span class="line">        <span class="keyword">get</span>: function reactiveGetter () &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">val</span>;         <span class="comment">/* 实际上会依赖收集，下一小节会讲 */</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">set</span>: function reactiveSetter (newVal) &#123;</span><br><span class="line">            <span class="keyword">if</span> (newVal === <span class="keyword">val</span>) <span class="keyword">return</span>;</span><br><span class="line">            cb(newVal);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然这是不够的，我们需要在上面再封装一层 <code>observer</code> 。这个函数传入一个 value（需要「<strong>响应式</strong>」化的对象），通过遍历所有属性的方式对该对象的每一个属性都通过 <code>defineReactive</code> 处理。（注：实际上 observer 会进行递归调用，为了便于理解去掉了递归的过程）</p>
<figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> observer (value) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!value || (<span class="built_in">typeof</span> value !== <span class="comment">&#x27;object&#x27;)) &#123;</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">Object</span>.keys(value).forEach((<span class="keyword">key</span>) =&gt; &#123;</span><br><span class="line">        defineReactive(value, <span class="keyword">key</span>, value[<span class="keyword">key</span>]);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，让我们用 <code>observer</code> 来封装一个 Vue 吧！</p>
<p>在 Vue 的构造函数中，对 <code>options</code> 的 <code>data</code> 进行处理，这里的 <code>data</code> 想必大家很熟悉，就是平时我们在写 Vue 项目时组件中的 <code>data</code> 属性（实际上是一个函数，这里当作一个对象来简单处理）。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vue</span> &#123;</span><br><span class="line">    <span class="comment">/* Vue构造类 */</span></span><br><span class="line">    <span class="keyword">constructor</span>(options) &#123;</span><br><span class="line">        <span class="keyword">this</span>._data = options.<span class="keyword">data</span>;</span><br><span class="line">        observer(<span class="keyword">this</span>._data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样我们只要 new 一个 Vue 对象，就会将 <code>data</code> 中的数据进行「<strong>响应式</strong>」化。如果我们对 <code>data</code> 的属性进行下面的操作，就会触发 <code>cb</code> 方法更新视图。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let <span class="attr">o</span> = new Vue(&#123;</span><br><span class="line">    data: &#123;</span><br><span class="line">        test: &quot;I am test.&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)<span class="comment">;</span></span><br><span class="line"><span class="attr">o._data.test</span> = <span class="string">&quot;hello,world.&quot;</span><span class="comment">;  /* 视图更新啦～ */</span></span><br></pre></td></tr></table></figure>

<p>至此，响应式原理已经介绍完了，接下来让我们学习「<strong>响应式系统</strong>」的另一部分 ——「<strong>依赖收集</strong>」。</p>
<p>注：本节代码参考<a href="https://link.juejin.cn/?target=https://github.com/answershuto/VueDemo/blob/master/%25E3%2580%258A%25E5%2593%258D%25E5%25BA%2594%25E5%25BC%258F%25E7%25B3%25BB%25E7%25BB%259F%25E7%259A%2584%25E5%259F%25BA%25E6%259C%25AC%25E5%258E%259F%25E7%2590%2586%25E3%2580%258B.js" title="https://github.com/answershuto/VueDemo/blob/master/%E3%80%8A%E5%93%8D%E5%BA%94%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E3%80%8B.js">《响应式系统的基本原理》</a>。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/10/29/2-%E5%93%8D%E5%BA%94%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/" data-id="claxeer9i0001v8w16jh4b0fo" data-title="2.响应式系统的基本原理" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/5/">&laquo; 上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/7/">下一页 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/11/">十一月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">十月 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/11/26/%E4%B8%BA%E4%BB%80%E4%B9%88React16%E8%A6%81%E6%9B%B4%E6%94%B9%E7%BB%84%E4%BB%B6%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-%EF%BC%88%E4%B8%8B%EF%BC%89/">为什么React16要更改组件的生命周期?（下）</a>
          </li>
        
          <li>
            <a href="/2022/11/26/%E8%A6%81%E6%9B%B4%E6%94%B9%E7%BB%84%E4%BB%B6%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%9F%EF%BC%88%E4%B8%8A%EF%BC%89/">(no title)</a>
          </li>
        
          <li>
            <a href="/2022/11/26/%E4%BB%A3%E7%A0%81%E8%BD%ACdom/">代码转dom</a>
          </li>
        
          <li>
            <a href="/2022/11/26/React%E7%9F%A5%E8%AF%86%E9%93%BE/">React知识链</a>
          </li>
        
          <li>
            <a href="/2022/11/02/%E6%8E%92%E5%BA%8F%E2%80%9C/">排序“</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 XuJiaDi<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>