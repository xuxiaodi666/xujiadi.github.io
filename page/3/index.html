<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>徐嘉迪的个人网站</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="没有永远的失败者，只有努力的成功者">
<meta property="og:type" content="website">
<meta property="og:title" content="徐嘉迪的个人网站">
<meta property="og:url" content="http://example.com/page/3/index.html">
<meta property="og:site_name" content="徐嘉迪的个人网站">
<meta property="og:description" content="没有永远的失败者，只有努力的成功者">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="XuJiaDi">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="徐嘉迪的个人网站" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">徐嘉迪的个人网站</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">没有永远的失败者，只有努力的成功者</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS 订阅"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-Webpack-究竟解决了什么问题？" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/11/02/Webpack-%E7%A9%B6%E7%AB%9F%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F/" class="article-date">
  <time class="dt-published" datetime="2022-11-02T11:35:19.000Z" itemprop="datePublished">2022-11-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/11/02/Webpack-%E7%A9%B6%E7%AB%9F%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F/">Webpack 究竟解决了什么问题？</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>你好，我是汪磊，今天我要跟你分享的内容是 Webpack 背后的模块化以及它的发展过程。</p>
<p>正如开篇词中所描述的，Webpack 最初的目标就是实现前端项目的模块化，也就是说它所解决的问题是<strong>如何在前端项目中更高效地管理和维护项目中的每一个资源</strong>。</p>
<p>所以如果你想要搞明白 Webpack ，就必须先对它想要解决的问题或者目标有一个充分的认识，带着问题再去理解它的很多特性，学习思路会更清晰，理解也会更深刻。</p>
<p>在这一课时中，我将带你简单了解前端模块化的发展史，以及这个过程中所出现的一些标准规范。有句话叫作：读史使人明智，希望通过学习本课时的内容，能够为你在 Webpack 的理解上带来新的启示。</p>
<h3>模块化的演进过程</h3>
<p>随着互联网的深入发展，前端技术标准发生了巨大的变化。早期的前端技术标准根本没有预料到前端行业会有今天这个规模，所以在设计上存在很多缺陷，导致我们现在去实现前端模块化时会遇到诸多问题。虽然说，如今绝大部分问题都已经被一些标准或者工具解决了，但在这个演进过程中依然有很多东西值得我们思考和学习，所以接下来我想先介绍一下前端方向落实模块化的几个代表阶段。</p>
<h4>1. Stage 1 - 文件划分方式</h4>
<p>最早我们会基于文件划分的方式实现模块化，也就是 Web 最原始的模块系统。具体做法是将每个功能及其相关状态数据各自单独放到不同的 JS 文件中，约定每个文件是一个独立的模块。使用某个模块将这个模块引入到页面中，一个 script 标签对应一个模块，然后直接调用模块中的成员（变量 / 函数）。</p>
<pre><code data-language="js" class="lang-js">└─&nbsp;stage<span class="hljs-number">-1</span>
&nbsp;&nbsp;&nbsp;&nbsp;├──&nbsp;<span class="hljs-built_in">module</span>-a.js
&nbsp;&nbsp;&nbsp;&nbsp;├──&nbsp;<span class="hljs-built_in">module</span>-b.js
&nbsp;&nbsp;&nbsp;&nbsp;└──&nbsp;index.html
</code></pre>
<pre><code data-language="js" class="lang-js"><span class="hljs-comment">//&nbsp;module-a.js&nbsp;</span>
<span class="hljs-function"><span class="hljs-keyword">function</span>&nbsp;<span class="hljs-title">foo</span>&nbsp;(<span class="hljs-params"></span>)&nbsp;</span>&#123;
&nbsp;&nbsp;&nbsp;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'moduleA#foo'</span>)&nbsp;
&#125;
</code></pre>
<pre><code data-language="js" class="lang-js"><span class="hljs-comment">//&nbsp;module-b.js&nbsp;</span>
<span class="hljs-keyword">var</span>&nbsp;data&nbsp;=&nbsp;<span class="hljs-string">'something'</span>
</code></pre>
<pre><code data-language="js" class="lang-js">&lt;!DOCTYPE&nbsp;html&gt;
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
&nbsp;&nbsp;<span class="hljs-tag">&lt;<span class="hljs-name">meta</span>&nbsp;<span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>
&nbsp;&nbsp;<span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Stage&nbsp;1<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
&nbsp;&nbsp;<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&nbsp;<span class="hljs-attr">src</span>=<span class="hljs-string">"module-a.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
&nbsp;&nbsp;<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&nbsp;<span class="hljs-attr">src</span>=<span class="hljs-string">"module-b.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
&nbsp;&nbsp;<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;直接使用全局成员</span>
&nbsp;&nbsp;&nbsp;&nbsp;foo()&nbsp;<span class="hljs-comment">//&nbsp;可能存在命名冲突</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-built_in">console</span>.log(data)
&nbsp;&nbsp;&nbsp;&nbsp;data&nbsp;=&nbsp;<span class="hljs-string">'other'</span>&nbsp;<span class="hljs-comment">//&nbsp;数据可能会被修改</span>
&nbsp;&nbsp;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</span></code></pre>
<p>缺点：</p>
<ul>
<li>模块直接在全局工作，大量模块成员污染全局作用域；</li>
<li>没有私有空间，所有模块内的成员都可以在模块外部被访问或者修改；</li>
<li>一旦模块增多，容易产生命名冲突；</li>
<li>无法管理模块与模块之间的依赖关系；</li>
<li>在维护的过程中也很难分辨每个成员所属的模块。</li>
</ul>
<p>总之，这种原始“模块化”的实现方式完全依靠约定实现，一旦项目规模变大，这种约定就会暴露出种种问题，非常不可靠，所以我们需要尽可能解决这个过程中暴露出来的问题。</p>
<h4>2. Stage 2 – 命名空间方式</h4>
<p>后来，我们约定每个模块只暴露一个全局对象，所有模块成员都挂载到这个全局对象中，具体做法是在第一阶段的基础上，通过将每个模块“包裹”为一个全局对象的形式实现，这种方式就好像是为模块内的成员添加了“命名空间”，所以我们又称之为命名空间方式。<br>
<br></p>
<pre><code data-language="js" class="lang-js"><span class="hljs-comment">//&nbsp;module-a.js</span>
<span class="hljs-built_in">window</span>.moduleA&nbsp;=&nbsp;&#123;
&nbsp;&nbsp;<span class="hljs-attr">method1</span>:&nbsp;<span class="hljs-function"><span class="hljs-keyword">function</span>&nbsp;(<span class="hljs-params"></span>)&nbsp;</span>&#123;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'moduleA#method1'</span>)
&nbsp;&nbsp;&#125;
&#125;
</code></pre>
<pre><code data-language="js" class="lang-js"><span class="hljs-comment">//&nbsp;module-b.js</span>
<span class="hljs-built_in">window</span>.moduleB&nbsp;=&nbsp;&#123;
&nbsp;&nbsp;<span class="hljs-attr">data</span>:&nbsp;<span class="hljs-string">'something'</span>
&nbsp;&nbsp;<span class="hljs-attr">method1</span>:&nbsp;<span class="hljs-function"><span class="hljs-keyword">function</span>&nbsp;(<span class="hljs-params"></span>)&nbsp;</span>&#123;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'moduleB#method1'</span>)
&nbsp;&nbsp;&#125;
&#125;
</code></pre>
<pre><code data-language="js" class="lang-js">&lt;!DOCTYPE&nbsp;html&gt;
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
&nbsp;&nbsp;<span class="hljs-tag">&lt;<span class="hljs-name">meta</span>&nbsp;<span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>
&nbsp;&nbsp;<span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Stage&nbsp;2<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
&nbsp;&nbsp;<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&nbsp;<span class="hljs-attr">src</span>=<span class="hljs-string">"module-a.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
&nbsp;&nbsp;<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&nbsp;<span class="hljs-attr">src</span>=<span class="hljs-string">"module-b.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
&nbsp;&nbsp;<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="actionscript">
&nbsp;&nbsp;&nbsp;&nbsp;moduleA.method1()
&nbsp;&nbsp;&nbsp;&nbsp;moduleB.method1()
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;模块成员依然可以被修改</span>
&nbsp;&nbsp;&nbsp;&nbsp;moduleA.data&nbsp;=&nbsp;<span class="hljs-string">'foo'</span>
&nbsp;&nbsp;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</span></code></pre>
<p>这种命名空间的方式只是解决了命名冲突的问题，但是其它问题依旧存在。</p>
<h4>3. Stage 3 – IIFE</h4>
<p>使用立即执行函数表达式（IIFE，Immediately-Invoked Function Expression）为模块提供私有空间。具体做法是将每个模块成员都放在一个立即执行函数所形成的私有作用域中，对于需要暴露给外部的成员，通过挂到全局对象上的方式实现。</p>
<pre><code data-language="js" class="lang-js"><span class="hljs-comment">//&nbsp;module-a.js</span>
;(<span class="hljs-function"><span class="hljs-keyword">function</span>&nbsp;(<span class="hljs-params"></span>)&nbsp;</span>&#123;
&nbsp;&nbsp;<span class="hljs-keyword">var</span>&nbsp;name&nbsp;=&nbsp;<span class="hljs-string">'module-a'</span>


<p>&amp;nbsp;&amp;nbsp;<span class="hljs-function"><span class="hljs-keyword">function</span>&amp;nbsp;<span class="hljs-title">method1</span>&amp;nbsp;(<span class="hljs-params"></span>)&amp;nbsp;</span>&#123;<br>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;<span class="hljs-built_in">console</span>.log(name&amp;nbsp;+&amp;nbsp;<span class="hljs-string">‘#method1’</span>)<br>&amp;nbsp;&amp;nbsp;&#125;</p>
<p>&amp;nbsp;&amp;nbsp;<span class="hljs-built_in">window</span>.moduleA&amp;nbsp;&#x3D;&amp;nbsp;&#123;<br>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;<span class="hljs-attr">method1</span>:&amp;nbsp;method1<br>&amp;nbsp;&amp;nbsp;&#125;<br>&#125;)()<br></code></pre></p>
<pre><code data-language="js" class="lang-js"><span class="hljs-comment">//&nbsp;module-b.js</span>
;(<span class="hljs-function"><span class="hljs-keyword">function</span>&nbsp;(<span class="hljs-params"></span>)&nbsp;</span>&#123;
&nbsp;&nbsp;<span class="hljs-keyword">var</span>&nbsp;name&nbsp;=&nbsp;<span class="hljs-string">'module-b'</span>


&nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">function</span>&nbsp;<span class="hljs-title">method1</span>&nbsp;(<span class="hljs-params"></span>)&nbsp;</span>&#123;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-built_in">console</span>.log(name&nbsp;+&nbsp;<span class="hljs-string">'#method1'</span>)
&nbsp;&nbsp;&#125;

&nbsp;&nbsp;<span class="hljs-built_in">window</span>.moduleB&nbsp;=&nbsp;&#123;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">method1</span>:&nbsp;method1
&nbsp;&nbsp;&#125;
&#125;)()
</code></pre>

<p>这种方式带来了私有成员的概念，私有成员只能在模块成员内通过闭包的形式访问，这就解决了前面所提到的全局作用域污染和命名冲突的问题。</p>
<h4>4. Stage 4 - IIFE 依赖参数</h4>
<p>在 IIFE 的基础之上，我们还可以利用 IIFE 参数作为依赖声明使用，这使得每一个模块之间的依赖关系变得更加明显。</p>
<pre><code data-language="js" class="lang-js"><span class="hljs-comment">//&nbsp;module-a.js</span>
;(<span class="hljs-function"><span class="hljs-keyword">function</span>&nbsp;(<span class="hljs-params">$</span>)&nbsp;</span>&#123;&nbsp;<span class="hljs-comment">//&nbsp;通过参数明显表明这个模块的依赖</span>
&nbsp;&nbsp;<span class="hljs-keyword">var</span>&nbsp;name&nbsp;=&nbsp;<span class="hljs-string">'module-a'</span>


<p>&amp;nbsp;&amp;nbsp;<span class="hljs-function"><span class="hljs-keyword">function</span>&amp;nbsp;<span class="hljs-title">method1</span>&amp;nbsp;(<span class="hljs-params"></span>)&amp;nbsp;</span>&#123;<br>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;<span class="hljs-built_in">console</span>.log(name&amp;nbsp;+&amp;nbsp;<span class="hljs-string">‘#method1’</span>)<br>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;$(<span class="hljs-string">‘body’</span>).animate(&#123;&amp;nbsp;<span class="hljs-attr">margin</span>:&amp;nbsp;<span class="hljs-string">‘200px’</span>&amp;nbsp;&#125;)<br>&amp;nbsp;&amp;nbsp;&#125;</p>
<p>&amp;nbsp;&amp;nbsp;<span class="hljs-built_in">window</span>.moduleA&amp;nbsp;&#x3D;&amp;nbsp;&#123;<br>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;<span class="hljs-attr">method1</span>:&amp;nbsp;method1<br>&amp;nbsp;&amp;nbsp;&#125;<br>&#125;)(jQuery)<br></code></pre></p>
<h4>模块加载的问题</h4>
<p>以上 4 个阶段是早期的开发者在没有工具和规范的情况下对模块化的落地方式，这些方式确实解决了很多在前端领域实现模块化的问题，但是仍然存在一些没有解决的问题。</p>
<pre><code data-language="js" class="lang-js">&lt;!DOCTYPE&nbsp;html&gt;
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
&nbsp;&nbsp;<span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Evolution<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
&nbsp;&nbsp;<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&nbsp;<span class="hljs-attr">src</span>=<span class="hljs-string">"https://unpkg.com/jquery"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
&nbsp;&nbsp;<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&nbsp;<span class="hljs-attr">src</span>=<span class="hljs-string">"module-a.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
&nbsp;&nbsp;<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&nbsp;<span class="hljs-attr">src</span>=<span class="hljs-string">"module-b.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
&nbsp;&nbsp;<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span>
&nbsp;&nbsp;&nbsp;&nbsp;moduleA.method1()
&nbsp;&nbsp;&nbsp;&nbsp;moduleB.method1()
&nbsp;&nbsp;<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span>
</code></pre>
<p>最明显的问题就是：模块的加载。在这几种方式中虽然都解决了模块代码的组织问题，但模块加载的问题却被忽略了，我们都是通过 script 标签的方式直接在页面中引入的这些模块，这意味着模块的加载并不受代码的控制，时间久了维护起来会十分麻烦。试想一下，如果你的代码需要用到某个模块，如果 HTML 中忘记引入这个模块，又或是代码中移除了某个模块的使用，而 HTML 还忘记删除该模块的引用，都会引起很多问题和不必要的麻烦。</p>
<p>更为理想的方式应该是在页面中引入一个 JS 入口文件，其余用到的模块可以通过代码控制，按需加载进来。</p>
<h4>模块化规范的出现</h4>
<p>除了模块加载的问题以外，目前这几种通过约定实现模块化的方式，不同的开发者在实施的过程中会出现一些细微的差别，因此，为了统一不同开发者、不同项目之间的差异，我们就需要制定一个行业标准去规范模块化的实现方式。</p>
<p>再接合我们刚刚提到的模块加载的问题，我们现在的需求就是两点：</p>
<ul>
<li>一个统一的模块化标准规范</li>
<li>一个可以自动加载模块的基础库</li>
</ul>
<p>提到模块化规范，你可能会想到 CommonJS 规范，它是 Node.js 中所遵循的模块规范，该规范约定，一个文件就是一个模块，每个模块都有单独的作用域，通过 module.exports 导出成员，再通过 require 函数载入模块。现如今的前端开发者应该对其有所了解，但是如果我们想要在浏览器端直接使用这个规范，那就会出现一些新的问题。</p>
<p>如果你对 Node.js 的模块加载机制有所了解，那么你应该知道，CommonJS 约定的是以同步的方式加载模块，因为 Node.js 执行机制是在启动时加载模块，执行过程中只是使用模块，所以这种方式不会有问题。但是如果要在浏览器端使用同步的加载模式，就会引起大量的同步模式请求，导致应用运行效率低下。</p>
<p>所以在早期制定前端模块化标准时，并没有直接选择 CommonJS 规范，而是专门为浏览器端重新设计了一个规范，叫做 AMD （ Asynchronous Module Definition） 规范，即异步模块定义规范。同期还推出了一个非常出名的库，叫做 Require.js，它除了实现了 AMD 模块化规范，本身也是一个非常强大的模块加载器。</p>
<p>在 AMD 规范中约定每个模块通过 define() 函数定义，这个函数默认可以接收两个参数，第一个参数是一个数组，用于声明此模块的依赖项；第二个参数是一个函数，参数与前面的依赖项一一对应，每一项分别对应依赖项模块的导出成员，这个函数的作用就是为当前模块提供一个私有空间。如果在当前模块中需要向外部导出成员，可以通过 return 的方式实现。</p>
<p><img src="https://s0.lgstatic.com/i/image3/M01/89/DC/Cgq2xl6YeWWAZhc-AAIVA96nDrk023.png" alt=""></p>
<p>除此之外，Require.js 还提供了一个 require() 函数用于自动加载模块，用法与 define() 函数类似，区别在于 require() 只能用来载入模块，而 &nbsp;define() 还可以定义模块。当 Require.js 需要加载一个模块时，内部就会自动创建 script 标签去请求并执行相应模块的代码。</p>
<p><img src="https://s0.lgstatic.com/i/image3/M01/03/97/CgoCgV6YeWWAZBOiAAFbOHcA3-o771.png" alt=""></p>
<p>目前绝大多数第三方库都支持 AMD 规范，但是它使用起来相对复杂，而且当项目中模块划分过于细致时，就会出现同一个页面对 js 文件的请求次数过多的情况，从而导致效率降低。在当时的环境背景下，AMD 规范为前端模块化提供了一个标准，但这只是一种妥协的实现方式，并不能成为最终的解决方案。</p>
<p>同期出现的规范还有淘宝的 Sea.js，只不过它实现的是另外一个标准，叫作 CMD，这个标准类似于 CommonJS，在使用上基本和 Require.js 相同，可以算上是重复的轮子。但随着前端技术的发展，Sea.js 后来也被 Require.js 兼容了。如果你感兴趣可以课后了解一下&nbsp;<a target="_blank" rel="noopener" href="https://seajs.github.io/seajs/docs/">Seajs官网</a>。</p>
<p><img src="https://s0.lgstatic.com/i/image3/M01/10/C6/Ciqah16YeWWAHUDmAAI62LbE3vI465.png" alt=""></p>
<h4>模块化的标准规范</h4>
<p>尽管上面介绍的这些方式和标准都已经实现了模块化，但是都仍然存在一些让开发者难以接受的问题。</p>
<p>随着技术的发展，JavaScript 的标准逐渐走向完善，可以说，如今的前端模块化已经发展得非常成熟了，而且对前端模块化规范的最佳实践方式也基本实现了统一。</p>
<ul>
<li>在 Node.js 环境中，我们遵循 CommonJS 规范来组织模块。</li>
<li>在浏览器环境中，我们遵循 ES Modules 规范。</li>
</ul>
<p><img src="https://s0.lgstatic.com/i/image3/M01/89/DC/Cgq2xl6YeWWAQftyAAFnRTB-PpI302.png" alt=""></p>
<p>而且在最新的 Node.js 提案中表示，Node 环境也会逐渐趋向于 ES Modules 规范，也就是说作为现阶段的前端开发者，应该重点掌握 ES Modules 规范。</p>
<p>因为 CommonJS 属于内置模块系统，所以在 Node.js 环境中使用时不存在环境支持问题，只需要直接遵循标准使用 require 和 module 即可。</p>
<p>但是对于 ES Modules 规范来说，情况会相对复杂一些。我们知道 ES Modules 是 ECMAScript 2015（ES6）中才定义的模块系统，也就是说它是近几年才制定的标准，所以肯定会存在环境兼容的问题。在这个标准刚推出的时候，几乎所有主流的浏览器都不支持。但是随着 Webpack 等一系列打包工具的流行，这一规范才开始逐渐被普及。</p>
<p>经过 5 年的迭代， ES Modules 已发展成为现今最主流的前端模块化标准。相比于 AMD 这种社区提出的开发规范，ES Modules 是在语言层面实现的模块化，因此它的标准更为完善也更为合理。而且目前绝大多数浏览器都已经开始能够原生支持 ES Modules 这个特性了，所以说在未来几年，它还会有更好的发展，短期内应该不会有新的轮子出现了。</p>
<p>综上所述，如何在不同的环境中去更好的使用 ES Modules 将是你重点考虑的问题。</p>
<h3>ES Modules 特性</h3>
<p>那对于 ES Modules 的学习，可以从两个维度入手。首先，你需要了解它作为一个规范或者说标准，到底约定了哪些特性和语法；其次，你需要学习如何通过一些工具和方案去解决运行环境兼容带来的问题。</p>
<p>针对 ES Modules 本身的一些特性本课时不做赘述，你可以参考：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Modules">MDN 官方的详细资料</a></li>
<li><a target="_blank" rel="noopener" href="http://www.ecma-international.org/ecma-262/6.0/#sec-modules">ECMAScript 官方详细资料</a></li>
</ul>
<p><img src="https://s0.lgstatic.com/i/image3/M01/03/97/CgoCgV6YeWaAN1caAAFPHLEZF0A908.png" alt=""></p>
<h3>模块打包工具的出现</h3>
<p>模块化可以帮助我们更好地解决复杂应用开发过程中的代码组织问题，但是随着模块化思想的引入，我们的前端应用又会产生了一些新的问题，比如：</p>
<ul>
<li>首先，我们所使用的 ES Modules 模块系统本身就存在环境兼容问题。尽管现如今主流浏览器的最新版本都支持这一特性，但是目前还无法保证用户的浏览器使用情况。所以我们还需要解决兼容问题。</li>
<li>其次，模块化的方式划分出来的模块文件过多，而前端应用又运行在浏览器中，每一个文件都需要单独从服务器请求回来。零散的模块文件必然会导致浏览器的频繁发送网络请求，影响应用的工作效率。</li>
<li>最后，谈一下在实现 JS 模块化的基础上的发散。随着应用日益复杂，在前端应用开发过程中不仅仅只有 JavaScript 代码需要模块化，HTML 和 CSS 这些资源文件也会面临需要被模块化的问题。而且从宏观角度来看，这些文件也都应该看作前端应用中的一个模块，只不过这些模块的种类和用途跟 JavaScript 不同。</li>
</ul>
<p>对于开发过程而言，模块化肯定是必要的，所以我们需要在前面所说的模块化实现的基础之上引入更好的方案或者工具，去解决上面提出的 3 个问题，让我们的应用在开发阶段继续享受模块化带来的优势，又不必担心模块化对生产环境所产生的影响。</p>
<p>接下来我们先对这个更好的方案或者工具提出一些设想：</p>
<ul>
<li>第一，它需要具备编译代码的能力，也就是将我们开发阶段编写的那些包含新特性的代码转换为能够兼容大多数环境的代码，解决我们所面临的环境兼容问题。</li>
</ul>
<p><img src="https://s0.lgstatic.com/i/image3/M01/10/C6/Ciqah16YeWaAEqbZAAB2uMwv74E224.png" alt=""></p>
<ul>
<li>第二，能够将散落的模块再打包到一起，这样就解决了浏览器频繁请求模块文件的问题。这里需要注意，只是在开发阶段才需要模块化的文件划分，因为它能够帮我们更好地组织代码，到了实际运行阶段，这种划分就没有必要了。</li>
</ul>
<p><img src="https://s0.lgstatic.com/i/image3/M01/03/97/CgoCgV6YeWaAHgm3AAB8JgXpadc131.png" alt=""></p>
<ul>
<li>第三，它需要支持不同种类的前端模块类型，也就是说可以将开发过程中涉及的样式、图片、字体等所有资源文件都作为模块使用，这样我们就拥有了一个统一的模块化方案，所有资源文件的加载都可以通过代码控制，与业务代码统一维护，更为合理。</li>
</ul>
<p><img src="https://s0.lgstatic.com/i/image3/M01/89/DC/Cgq2xl6YeWaARx0OAACCLDANJto655.png" alt=""></p>
<p>针对上面第一、第二个设想，我们可以借助 Gulp 之类的构建系统配合一些编译工具和插件去实现，但是对于第三个可以对不同种类资源进行模块化的设想，就很难通过这种方式去解决了，所以就有了我们接下来要介绍的主题：前端模块打包工具。</p>
<h3>写在最后</h3>
<p>本课时重点介绍了前端模块化的发展过程和最终的统一的 ES Modules 标准，这些都是我们深入学习 Webpack 前必须要掌握的内容，同时也是现代前端开发者必不可少的基础储备，请你务必要掌握。</p>
<p>学到这里，你可能会有这样的疑问，本课时的内容是否偏离了主题？但其实我想传达的思想是，虽然 Webpack 发展到今天，它的功能已经非常强大了，但依然改变不了它是一个模块化解决方案的初衷。你可以看到， Webpack 官方的 Slogan 仍然是：<em>A bundler for javascript and friends（一个 JavaScript 和周边的打包工具）</em>。</p>
<p>从另外一个角度来看，Webpack 从一个“打包工具”，发展成现在开发者眼中对整个前端项目的“构建系统”，表面上似乎只是称呼发生了变化，但是这背后却透露出来一个信号：模块化思想是非常伟大的，伟大到可以帮你“统治”前端整个项目。这也足以见得模块化思想背后还有很多值得我们思考的内容。</p>
<p>总的来说，我们可以把 Webpack 看作现代化前端应用的“管家”，这个“管家”所践行的核心理论就是“模块化”，也就是说&nbsp;<strong>Webpack 以模块化思想为核心，帮助开发者更好的管理整个前端工程。</strong></p>

<hr>
<h3 id="精选评论"><a href="#精选评论" class="headerlink" title="精选评论"></a>精选评论</h3><h5 id="zhanglong："><a href="#zhanglong：" class="headerlink" title="zhanglong："></a>zhanglong：</h5><blockquote>
<p>很认真的看了一遍，构思设计内容相当好。</p>
</blockquote>
<h5 id="强："><a href="#强：" class="headerlink" title="**强："></a>**强：</h5><blockquote>
<p>系统地梳理了前端模块的发展历程，讲得非常好。</p>
</blockquote>
<h5 id="7949："><a href="#7949：" class="headerlink" title="**7949："></a>**7949：</h5><blockquote>
<p>讲得不错👍</p>
</blockquote>
<h5 id="用户："><a href="#用户：" class="headerlink" title="**用户："></a>**用户：</h5><blockquote>
<p>后端程序员前来报道</p>
</blockquote>
<h5 id="龙："><a href="#龙：" class="headerlink" title="**龙："></a>**龙：</h5><blockquote>
<p>webpack就是一个模块打包工具</p>
</blockquote>
<h5 id="聪："><a href="#聪：" class="headerlink" title="*聪："></a>*聪：</h5><blockquote>
<p>读史使人明智，让我们知其然更知其所以然，老师梳理得很棒👍🏻</p>
</blockquote>
<h5 id="健："><a href="#健：" class="headerlink" title="*健："></a>*健：</h5><blockquote>
<p>读史使人明智，看完模块化对学习webpack的目的更清晰了</p>
</blockquote>
<h5 id="帅："><a href="#帅：" class="headerlink" title="*帅："></a>*帅：</h5><blockquote>
<p>赞!</p>
</blockquote>
<h5 id="gjd："><a href="#gjd：" class="headerlink" title="gjd："></a>gjd：</h5><blockquote>
<p>做个沙发</p>
</blockquote>
<h5 id="宽："><a href="#宽：" class="headerlink" title="**宽："></a>**宽：</h5><blockquote>
<p>讲的太好了，很容易理解，我还要再看一遍才能记住</p>
</blockquote>
<h5 id="飞："><a href="#飞：" class="headerlink" title="**飞："></a>**飞：</h5><blockquote>
<p>没得说，讲的真的好</p>
</blockquote>
<h5 id="浩："><a href="#浩：" class="headerlink" title="*浩："></a>*浩：</h5><blockquote>
<p>一个工具的出现必然会解决一些问题，带着解决问题的目的去学习效果会更好。</p>
</blockquote>
<h5 id="灵："><a href="#灵：" class="headerlink" title="**灵："></a>**灵：</h5><blockquote>
<p>这文章看的爽</p>
</blockquote>
<h5 id="洋："><a href="#洋：" class="headerlink" title="**洋："></a>**洋：</h5><blockquote>
<p>学习了,早就想学习webpak,跟着老师思路走,小白也能看懂,不知道老师有没有vue的课</p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-编辑回复："><a href="#amp-nbsp-amp-nbsp-amp-nbsp-编辑回复：" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 编辑回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 编辑回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; 老师在“大前端结业集训营”讲解了vue的内容，小伙伴感兴趣可以了解一下哦，链接如下：<br><a target="_blank" rel="noopener" href="https://kaiwu.lagou.com/fe_essential.html?utm_campaign=App%25E8%25AE%25AD%25E7%25BB%2583%25E8%2590%25A5%25E4%25B8%2593%25E5%258C%25BA&amp;put_id=26&amp;channel_from=%25E8%25AE%25AD%25E7%25BB%2583%25E8%2590%25A5%25E4%25B8%2593%25E5%258C%25BA">https://kaiwu.lagou.com/fe_essential.html?utm_campaign=App%25E8%25AE%25AD%25E7%25BB%2583%25E8%2590%25A5%25E4%25B8%2593%25E5%258C%25BA&amp;put_id=26&amp;channel_from=%25E8%25AE%25AD%25E7%25BB%2583%25E8%2590%25A5%25E4%25B8%2593%25E5%258C%25BA</a></p>
</blockquote>
<h5 id="程："><a href="#程：" class="headerlink" title="*程："></a>*程：</h5><blockquote>
<p>老师，你的这篇写得非常好。以发展历史背景，抛砖引玉。</p>
</blockquote>
<h5 id="ADogc："><a href="#ADogc：" class="headerlink" title="ADogc："></a>ADogc：</h5><blockquote>
<p>最后的总结，高度一下就上来了</p>
</blockquote>
<h5 id="键："><a href="#键：" class="headerlink" title="*键："></a>*键：</h5><blockquote>
<p>那默认构建出来的模块类型应该就是AMD了</p>
</blockquote>
<h5 id="其："><a href="#其：" class="headerlink" title="*其："></a>*其：</h5><blockquote>
<p>写的可以啊，看了前2章，很棒，思路清晰。可以的</p>
</blockquote>
<h5 id="文："><a href="#文：" class="headerlink" title="**文："></a>**文：</h5><blockquote>
<p>模块化讲得很好，可以反复看几遍</p>
</blockquote>
<h5 id="菲："><a href="#菲：" class="headerlink" title="**菲："></a>**菲：</h5><blockquote>
<p>打卡😁</p>
</blockquote>
<h5 id="民："><a href="#民：" class="headerlink" title="**民："></a>**民：</h5><blockquote>
<p>坚持学习</p>
</blockquote>
<h5 id="力："><a href="#力：" class="headerlink" title="*力："></a>*力：</h5><blockquote>
<p>之前对webpack的理解一直很片面也不是很清晰，读完这一篇终于真相了</p>
</blockquote>
<h5 id="平："><a href="#平：" class="headerlink" title="**平："></a>**平：</h5><blockquote>
<p>赞👍</p>
</blockquote>
<h5 id="峰："><a href="#峰：" class="headerlink" title="*峰："></a>*峰：</h5><blockquote>
<p>嗯，自己也简单概括梳理了笔记。</p>
</blockquote>
<h5 id="朝："><a href="#朝：" class="headerlink" title="**朝："></a>**朝：</h5><blockquote>
<p>循序渐进，先讲背景，再讲使用，思路很清晰，非常好！</p>
</blockquote>
<h5 id="源："><a href="#源：" class="headerlink" title="**源："></a>**源：</h5><blockquote>
<p>打卡，7-13</p>
</blockquote>
<h5 id="强：-1"><a href="#强：-1" class="headerlink" title="*强："></a>*强：</h5><blockquote>
<p>作者用心了，写的很细致</p>
</blockquote>
<h5 id="1388："><a href="#1388：" class="headerlink" title="**1388："></a>**1388：</h5><blockquote>
<p>哇 对于我这种前端小白 真的很有用</p>
</blockquote>
<h5 id="NARUTOne："><a href="#NARUTOne：" class="headerlink" title="NARUTOne："></a>NARUTOne：</h5><blockquote>
<p>赞👍，模块化历史清晰，不同时候解决各种痛点</p>
</blockquote>
<h5 id="杰："><a href="#杰：" class="headerlink" title="**杰："></a>**杰：</h5><blockquote>
<p>恩，写的挺清楚的，对理解一些技术有太大的帮助了</p>
</blockquote>
<h5 id="3033："><a href="#3033：" class="headerlink" title="**3033："></a>**3033：</h5><blockquote>
<p>老师讲的真好</p>
</blockquote>
<h5 id="用户0920："><a href="#用户0920：" class="headerlink" title="**用户0920："></a>**用户0920：</h5><blockquote>
<p>老师，“前端应用又运行在浏览器中，每一个文件都需要单独从服务器请求回来”，这句应该怎么理解，为什么说每个文件都需要单独从服务器请求回来？那岂不是先将本地文件上传到服务器，在浏览器输入域名，然后浏览器请求当前域名下的文件，是该这么理解吗？那后面说的“零散的模块文件必然会导致浏览器的频繁发送网络请求”，又是怎么产生的呢？域名和模块文件之间的关系不太懂</p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-讲师回复："><a href="#amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; 开发阶段所有的资源都在本地，但是对于生产阶段，这些资源都应该在服务器上。Web 开发的基本功要扎实</p>
</blockquote>
<h5 id="娟："><a href="#娟：" class="headerlink" title="**娟："></a>**娟：</h5><blockquote>
<p>期待汪磊老师更多的课程</p>
</blockquote>
<h5 id="诚："><a href="#诚：" class="headerlink" title="**诚："></a>**诚：</h5><blockquote>
<p>老师，请问下，import 或者 require 是怎么加载文件的，比如我 A 文件中 import&#x2F;require 了一个 B.js 文件，那么这个 A 文件是将 B.js 代码复制了一份，还是以“引用”的形式引入进来的？<br><br>如果是“引用”的形式，那会不会产生我在 A 中修改了 B.js 中的某个变量数据，导致 C 文件引用的 B.js 也发生变化？</p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-1"><a href="#amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-1" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; 不同的文件得到的是不同的实例对象，内存地址不同</p>
</blockquote>
<h5 id="的小鸟："><a href="#的小鸟：" class="headerlink" title="**的小鸟："></a>**的小鸟：</h5><blockquote>
<p>讲得很好，对js发展有了整体的理解。</p>
</blockquote>
<h5 id="哲："><a href="#哲：" class="headerlink" title="**哲："></a>**哲：</h5><blockquote>
<p>优秀</p>
</blockquote>
<h5 id="森："><a href="#森：" class="headerlink" title="**森："></a>**森：</h5><blockquote>
<p>涨知识</p>
</blockquote>
<h5 id="锋："><a href="#锋：" class="headerlink" title="**锋："></a>**锋：</h5><blockquote>
<p>很正规，新手学习路</p>
</blockquote>
<h5 id="佳："><a href="#佳：" class="headerlink" title="**佳："></a>**佳：</h5><blockquote>
<p>对前端打包工具的由来有了了解，点赞，打卡</p>
</blockquote>
<h5 id="颖："><a href="#颖：" class="headerlink" title="**颖："></a>**颖：</h5><blockquote>
<p>简单明了</p>
</blockquote>
<h5 id="兴："><a href="#兴：" class="headerlink" title="**兴："></a>**兴：</h5><blockquote>
<p>带我入门的老师</p>
</blockquote>
<h5 id="周："><a href="#周：" class="headerlink" title="*周："></a>*周：</h5><blockquote>
<p>讲的特好，普通话也不错，看的出经验丰富！</p>
</blockquote>
<h5 id="超："><a href="#超：" class="headerlink" title="**超："></a>**超：</h5><blockquote>
<p>很棒</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/11/02/Webpack-%E7%A9%B6%E7%AB%9F%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F/" data-id="claxeer9s000iv8w195et9uiv" data-title="Webpack 究竟解决了什么问题？" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Webpack-现代化前端应用的基石" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/11/02/Webpack-%E7%8E%B0%E4%BB%A3%E5%8C%96%E5%89%8D%E7%AB%AF%E5%BA%94%E7%94%A8%E7%9A%84%E5%9F%BA%E7%9F%B3/" class="article-date">
  <time class="dt-published" datetime="2022-11-02T11:33:29.000Z" itemprop="datePublished">2022-11-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/11/02/Webpack-%E7%8E%B0%E4%BB%A3%E5%8C%96%E5%89%8D%E7%AB%AF%E5%BA%94%E7%94%A8%E7%9A%84%E5%9F%BA%E7%9F%B3/">Webpack 现代化前端应用的基石</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p data-nodeid="7871" class="te-preview-highlight">你好，我是行痴，前端浸润十年，之前在一家电商企业任技术总监，主要负责 C 端产品开发和技术规划，后来躬身入局，投入前端技术研发与教学培训工作，希望通过技术去影响更多人。</p>

<p data-nodeid="418">经过最近几年的爆炸式发展，前端已经绝不再是简简单单的页面开发了，从早期只是配合后端“切图”，到现在已经能够独立驱动整个业务，这背后就需要引入更多的思想、框架和工具。比如：</p>
<ul data-nodeid="419">
<li data-nodeid="420">
<p data-nodeid="421">现阶段的大型应用就要求前端必须要有独立的项目，独立的项目想要有足够的效率就必须进行工程化。</p>
</li>
<li data-nodeid="422">
<p data-nodeid="423">具有复杂数据状态的应用开发过程就必须要有合适的框架，采用数据驱动开发的方式增强可维护性。</p>
</li>
<li data-nodeid="424">
<p data-nodeid="425">复杂项目结构必须进行模块化管理，一来提高部分公共内容的可复用性，二来增强团队并行协作能力。</p>
</li>
<li data-nodeid="426">
<p data-nodeid="427">重复规律性的工作必须采用自动化工具实现，一来提高效率，二来避免人为出错。</p>
</li>
</ul>
<p data-nodeid="428">这里的大多数问题现如今都有很成熟的解法，那我今天要跟你分享的主题就是其中最具有代表性的 Webpack。因为想要在现代化前端开发工作中有足够的开发效率，你一定离不开 Webpack 相关技术栈，不管是对于项目代码的模块化，还是一些规律性的重复工作，甚至是整个前端项目的工程化，Webpack 都能够帮你轻松搞定。</p>
<h3 data-nodeid="429">Webpack：提升前端生产力的利器</h3>
<p data-nodeid="430">我个人觉得 <strong data-nodeid="477">Webpack 应该是现代化前端开发的基石，也是目前前端生产力的代名词</strong>。</p>
<p data-nodeid="431">当然在日常工作中，确实有奉行“够用就行”工作态度的开发者，但我认为这是他们还没有意识到这些新技术新方案可能带来的成效。</p>
<p data-nodeid="432">最近正在招募一个前端研发团队，看了很多简历，也面试了很多前端开发者，发现基本上每一个人的简历上都洋洋洒洒写着 Vue.js、React 这样的主流框架，但是一旦问及使用这类框架进行开发时用到的一些基础设施，却开始支支吾吾，甚至直接表示“我只要用官方 CLI 就好了啊”。</p>
<p data-nodeid="433">确实，这些框架的官方推出这种高度集成的 CLI 工具，目的就是降低开发者的使用成本，但是对于一个优秀的开发人员而言，只会使用这种“黑盒工具”是远远不够的，因为这种“黑盒工具”大多数采用的都是通用的配置，而优秀的开发人员应该学会“因地制宜”，根据实际情况更灵活地去使用每一个工具。</p>
<p data-nodeid="434">当然，仔细想想，这个问题也好理解，毕竟很多前端开发者都是在这些框架和工具的成熟期（2017 年以后）才进入的这个行业，所以对它们背后的事情自然是要陌生一些。而我有幸经历了整个前端工程化工具生态的发展过程，加上在这之前很长的开发经历，所以对这个过程中诞生的工具和思想自然会理解地更为深刻。</p>
<p data-nodeid="435">我深知这些内容对你日常开发工作中解决问题能力的影响，很多开发者在日常工作中遇到问题不能快速地定位和解决，就是因为缺乏对这种底层或者基础的足够了解。因此，很多时候我会把对 Webpack 这类工具的认知程度，当作辨别开发人员优秀与否的分水岭。</p>
<h3 data-nodeid="436">Webpack 与模块化开发</h3>
<p data-nodeid="437">那说到 Webpack，就不得不提模块化开发，因为 Webpack 最早的出发点就是去实践前端方向的模块化开发。想要搞明白 Webpack，就先得搞明白它所要解决的问题，所以我这里先唠叨两句模块化的事情。</p>
<p data-nodeid="438">模块化，可以说是当下最重要的前端开发范式之一。<strong data-nodeid="490">随着前端应用的日益复杂化，我们的项目已经逐渐膨胀到了不得不花大量时间去管理的程度。而模块化就是一种最主流的项目组织方式，它通过把复杂的代码按照功能划分为不同的模块单独维护，从而提高开发效率、降低维护成本</strong>。</p>
<p data-nodeid="439"><img src="https://s0.lgstatic.com/i/image3/M01/10/C6/Ciqah16YeJeAfoJGABkKafi2Mt4307.gif" alt="" data-nodeid="492"></p>
<p data-nodeid="440">但是“模块化”，本身仅仅是一个思想或者说是一个理论，并不包含具体的实现。所以接下来，<strong data-nodeid="497">我们会一起学习如何使用 Webpack 在前端项目中实践模块化思想，以及目前行业中其他的一些优秀方案。</strong></p>
<p data-nodeid="441">可能你会问：Webpack 不应该是一个构建工具么？怎么还扯上了这么多东西？这也是目前绝大多数前端开发者都会有的疑问。你如果会有这种疑问，一多半还是因为你还不够了解 Webpack，或者所了解的内容还停留在表象层面。毕竟，Webpack 太强大了，强大到很容易让你忽略了它的本质。</p>
<p data-nodeid="442">Webpack 本质上仍然还是一个模块化打包工具，它通过“万物皆模块”这种设计思想，巧妙地实现了整个前端项目的模块化。在 Webpack 的理念中，前端项目中的任何资源都可以作为一个模块，任何模块都可以经过 Loader 机制的处理，最终再被打包到一起。</p>
<p data-nodeid="443">Webpack 本身的架构中有两个很核心的特性，分别是 Loader 机制和插件机制。正是因为它的插件机制形成了非常繁荣的生态，所以造就了它现在“无所不能”的现状，所以让 Webpack 慢慢发展成了现在很多前端开发者眼中的构建系统。</p>
<h3 data-nodeid="444">我是如何设计这个专栏的？</h3>
<p data-nodeid="445">如果你现在每天都只是在使用 Vue CLI 或者 create-react-app 这样高度集成的 CLI，面对特殊资源加载、打包过程优化、资源代码分块、Tree-shaking 这样相对复杂的需求无从下手；又或是你初入前端行业，只有一些简单的前端开发经验，我都诚意推荐你跟着这个专栏好好学习一下 Webpack 以及对前端模块的实践，这对你日后掌握 React 和 Vue.js 这类框架的高级用法非常有帮助。</p>
<p data-nodeid="446">专栏整体基于 Webpack 最新的 v4.42.1 版本展开，按照我一贯深入浅出、全面体系化的风格进行介绍，内容主要分为 4 个模块：</p>
<ul data-nodeid="447">
<li data-nodeid="448">
<p data-nodeid="449">Webpack 背景介绍：包括模块化所解决的问题、模块化标准的演进过程、ES Modules 标准规范。希望你通过这个模块，能够了解 Webpack 这类工具解决的到底是什么问题。</p>
</li>
<li data-nodeid="450">
<p data-nodeid="451">Webpack 核心特性：包括基本特性、配置方式、工作模式、基本工作原理、Loader 机制、插件机制。希望你学习完这个模块，能够完全掌握 Webpack 的基本使用，理解 Webpack 打包过程和打包结果的工作原理，同时也能够自己开发 Webpack 的 Loader 和插件。</p>
</li>
<li data-nodeid="452">
<p data-nodeid="453">Webpack 高阶内容：包括 Source Map、模块热替换（HMR）机制、Proxy、Webpack Dev Server 等周边技能的使用，以及 Tree-shaking、sideEffects、Code Spliting 等高级特性的实践，再有就是常用优化插件、三种 hash 的最佳实践、打包速度优化，以更于你能更熟练地使用 Webpack 的高级特性，为开发效率添砖加瓦。</p>
</li>
<li data-nodeid="454">
<p data-nodeid="455">其他同类优秀方案：Rollup、Parcel。希望通过这个模块的介绍，让你能够了解到一些 Webpack 同类的优秀方案，以及它们设计上的不同，这些都能够让你在工作中应对不同的项目、不同的需求时可以有更多的选择。</p>
</li>
</ul>
<p data-nodeid="456">这个专栏对你的知识储备要求不会太高，主要就是掌握 JavaScript 编程，了解一些 Node.js 基础，当然最好还能了解一些 Vue.js 之类主流框架的基本使用，这样可以帮助你更快速地定位我所描述的一些问题场景。</p>
<h3 data-nodeid="457">写作最后</h3>
<p data-nodeid="458">最后，我还是想再次强调一个点：一个合格的前端开发者必须夯实基础，深入地理解所使用的技术，而不是浮于表面，保持“够用就行”的技术认知；在这之后，才是去丰富自己的技术栈。就好像我们经常说的，马步扎不稳，学会再多的招数也只是花拳绣腿。</p>
<p data-nodeid="459">相信经过这个专栏的学习，你一定可以更深度、更全面地认识 Webpack，建立对 Webpack 整体的知识体系，掌握自定义和扩展 Webpack 的方法和技巧，更高效地使用 Webpack 解决实际项目开发中的需求和问题。</p>
<p data-nodeid="460">此外，我也希望专栏中所提出的一些问题和思考能够引起你的注意，因为设计的动机和思想才是学习每一个技术的关键所在：只掌握技术的使用，你的理解可能只能达到 6～7 成；只有真正搞明白新事物为什么这么设计，才能做到一通百通。这也正是近几年，技术圈很多人经常吐槽“学不动了”的根本原因。</p>
<p data-nodeid="461">正所谓“悟则通，通则达”，单纯地学习前人的做法而不去思考为什么，你就永远只能做最“累”的人。特别是在技术日新月异的时代，所有人都在持续学习，只有掌握核心精髓，更快更忧，你才能跑得最远。</p>
<p data-nodeid="462">好的学习，需要实践，也需要沟通和反馈，欢迎你在留言区给我分享你的学习感悟，以及成长过程中的经验与成就。</p>
<p data-nodeid="463" class=""><span style="color:#3f3f3f"><span class="font" style="font-family:微软雅黑, &quot;Microsoft YaHei&quot;"><span class="size" style="font-size:16px"></span></span></span></p>

<hr>
<h3 id="精选评论"><a href="#精选评论" class="headerlink" title="精选评论"></a>精选评论</h3><h5 id="9050："><a href="#9050：" class="headerlink" title="**9050："></a>**9050：</h5><blockquote>
<p>立个flag 学好 webpack</p>
</blockquote>
<h5 id="强："><a href="#强：" class="headerlink" title="**强："></a>**强：</h5><blockquote>
<p>作者用心了，开篇就讲了这么多道理，用心良苦啊。相成为顶级赛车手，不仅要会开车，还要会修车，不仅要会修车还要会造车。现在很多人都只是会开车，大多数人只不过是换了一辆跑得更快的车而已，换着换着就力不从心。AE86跑得比GTR快为啥，细品</p>
</blockquote>
<h5 id="琪："><a href="#琪：" class="headerlink" title="**琪："></a>**琪：</h5><blockquote>
<p>听完来评论，我买过慕课和极客时间的webpack课，这套课是目前为止我听到的最适合教学webpack课程，单元结构清晰，深入浅出，划分合理。老师讲的也很赞，很多老师可能自身技术是很厉害的，但是教学能力一般般。这套课老师非常懂教学，感谢老师。</p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-编辑回复："><a href="#amp-nbsp-amp-nbsp-amp-nbsp-编辑回复：" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 编辑回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 编辑回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; 感谢小伙伴的认可！比心～</p>
</blockquote>
<h5 id="8082："><a href="#8082：" class="headerlink" title="**8082："></a>**8082：</h5><blockquote>
<p>以前只知道有AMD CMD规范，却不知道它们是怎么来的，今天终于明白了</p>
</blockquote>
<h5 id="鹏："><a href="#鹏：" class="headerlink" title="**鹏："></a>**鹏：</h5><blockquote>
<p>娓娓道来，听着很舒服</p>
</blockquote>
<h5 id="react："><a href="#react：" class="headerlink" title="react："></a>react：</h5><blockquote>
<p>第一次买课程，支持</p>
</blockquote>
<h5 id="冰："><a href="#冰：" class="headerlink" title="**冰："></a>**冰：</h5><blockquote>
<p>老师声音好听</p>
</blockquote>
<h5 id="喆："><a href="#喆：" class="headerlink" title="**喆："></a>**喆：</h5><blockquote>
<p>汪老师加油，入行以来跟着你学到了很多东西，你出课我必买～顺便求一个催更群😁</p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-编辑回复：-1"><a href="#amp-nbsp-amp-nbsp-amp-nbsp-编辑回复：-1" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 编辑回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 编辑回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; 可以关注 拉勾教育 公众号 找小助手入群哈</p>
</blockquote>
<h5 id="峰："><a href="#峰：" class="headerlink" title="**峰："></a>**峰：</h5><blockquote>
<p>单就这篇开篇就写的很有条理，结构化，清楚表达了整个课程</p>
</blockquote>
<h5 id="盛-web前端开发工："><a href="#盛-web前端开发工：" class="headerlink" title="**盛 web前端开发工："></a>**盛 web前端开发工：</h5><blockquote>
<p>在这条路越走越深</p>
</blockquote>
<h5 id="丽："><a href="#丽：" class="headerlink" title="*丽："></a>*丽：</h5><blockquote>
<p>写的真好，谢谢大佬</p>
</blockquote>
<h5 id="武："><a href="#武：" class="headerlink" title="**武："></a>**武：</h5><blockquote>
<p>这种文字也有，视频也有的教程，牛啊，666</p>
</blockquote>
<h5 id="用户："><a href="#用户：" class="headerlink" title="**用户："></a>**用户：</h5><blockquote>
<p>后端程序员前来报道</p>
</blockquote>
<h5 id="道："><a href="#道：" class="headerlink" title="*道："></a>*道：</h5><blockquote>
<p>整个课程学完了，质量挺好的，比较适合有经验的来学习。</p>
</blockquote>
<h5 id="琪：-1"><a href="#琪：-1" class="headerlink" title="**琪："></a>**琪：</h5><blockquote>
<p>是时候好好梳理下自己的webpack知识了，准备面试快手；</p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-编辑回复：-2"><a href="#amp-nbsp-amp-nbsp-amp-nbsp-编辑回复：-2" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 编辑回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 编辑回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; 加油哦</p>
</blockquote>
<h5 id="宁："><a href="#宁：" class="headerlink" title="*宁："></a>*宁：</h5><blockquote>
<p>受益匪浅🙌</p>
</blockquote>
<h5 id="菲："><a href="#菲：" class="headerlink" title="**菲："></a>**菲：</h5><blockquote>
<p>打卡🙋</p>
</blockquote>
<h5 id="银："><a href="#银：" class="headerlink" title="*银："></a>*银：</h5><blockquote>
<p>冲冲冲！2020915</p>
</blockquote>
<h5 id="民："><a href="#民：" class="headerlink" title="**民："></a>**民：</h5><blockquote>
<p>开始第一天</p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-编辑回复：-3"><a href="#amp-nbsp-amp-nbsp-amp-nbsp-编辑回复：-3" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 编辑回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 编辑回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; 期待能够持续看到你的打卡身影哦，加油～</p>
</blockquote>
<h5 id="民：-1"><a href="#民：-1" class="headerlink" title="**民："></a>**民：</h5><blockquote>
<p>今天开始学习，15天学完一遍</p>
</blockquote>
<h5 id="前："><a href="#前：" class="headerlink" title="**前："></a>**前：</h5><blockquote>
<p>webpack 第二天</p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-编辑回复：-4"><a href="#amp-nbsp-amp-nbsp-amp-nbsp-编辑回复：-4" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 编辑回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 编辑回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; 加油<del>.</del></p>
</blockquote>
<h5 id="6125："><a href="#6125：" class="headerlink" title="**6125："></a>**6125：</h5><blockquote>
<p>一起加油</p>
</blockquote>
<h5 id="6835："><a href="#6835：" class="headerlink" title="**6835："></a>**6835：</h5><blockquote>
<p>老师，codeSplit和按需加载都是优化代码包体积，针对项目如何选择呢</p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-讲师回复："><a href="#amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; Code splitting 大多数情况都是按需加载的哇，两者不是并列关系，而是因果关系</p>
</blockquote>
<h5 id="盾："><a href="#盾：" class="headerlink" title="*盾："></a>*盾：</h5><blockquote>
<p>学习了，谢谢大佬</p>
</blockquote>
<h5 id="杰："><a href="#杰：" class="headerlink" title="**杰："></a>**杰：</h5><blockquote>
<p>立个小目标，掌握webpack</p>
</blockquote>
<h5 id="宇："><a href="#宇：" class="headerlink" title="**宇："></a>**宇：</h5><blockquote>
<p>能否提供 一个 已经配置好的项目 模板，包含dev,prod的配置文件 供参考呢</p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-1"><a href="#amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-1" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; 你可以去 GitHub 上检索，因为不同需求下配置起来都不一样，比如有没有用框架？用那个框架？CSS 怎么处理？等等</p>
</blockquote>
<h5 id="坚："><a href="#坚：" class="headerlink" title="**坚："></a>**坚：</h5><blockquote>
<p>催更</p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-编辑回复：-5"><a href="#amp-nbsp-amp-nbsp-amp-nbsp-编辑回复：-5" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 编辑回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 编辑回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; 感谢反馈，留言收到，我们后续会继续优化专栏上新与更节奏。</p>
</blockquote>
<h5 id="1560："><a href="#1560：" class="headerlink" title="**1560："></a>**1560：</h5><blockquote>
<p>老师是个有深度的人，不只是使用技术，而且懂得后面的设计精髓</p>
</blockquote>
<h5 id="博："><a href="#博：" class="headerlink" title="**博："></a>**博：</h5><blockquote>
<p>这个是永久观看吗？</p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-编辑回复：-6"><a href="#amp-nbsp-amp-nbsp-amp-nbsp-编辑回复：-6" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 编辑回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 编辑回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; 是的哈</p>
</blockquote>
<h5 id="彬："><a href="#彬：" class="headerlink" title="*彬："></a>*彬：</h5><blockquote>
<p>啃webpack不止一次两次了，一直拿不下啊，希望这次有根本的认识</p>
</blockquote>
<h5 id="光芒的女孩："><a href="#光芒的女孩：" class="headerlink" title="**光芒的女孩："></a>**光芒的女孩：</h5><blockquote>
<p>这次非得把webpack搞清楚不可</p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-编辑回复：-7"><a href="#amp-nbsp-amp-nbsp-amp-nbsp-编辑回复：-7" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 编辑回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 编辑回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; 加油！</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/11/02/Webpack-%E7%8E%B0%E4%BB%A3%E5%8C%96%E5%89%8D%E7%AB%AF%E5%BA%94%E7%94%A8%E7%9A%84%E5%9F%BA%E7%9F%B3/" data-id="claxeer9r000gv8w15wlf4vyf" data-title="Webpack 现代化前端应用的基石" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-为什么说-JavaScript-不适合大型项目？" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/11/02/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4-JavaScript-%E4%B8%8D%E9%80%82%E5%90%88%E5%A4%A7%E5%9E%8B%E9%A1%B9%E7%9B%AE%EF%BC%9F/" class="article-date">
  <time class="dt-published" datetime="2022-11-02T03:02:59.000Z" itemprop="datePublished">2022-11-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/11/02/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4-JavaScript-%E4%B8%8D%E9%80%82%E5%90%88%E5%A4%A7%E5%9E%8B%E9%A1%B9%E7%9B%AE%EF%BC%9F/">为什么说 JavaScript 不适合大型项目？</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p data-nodeid="473184">随着前端快速发展，JavaScript 语言的设计缺陷在大型项目中逐渐显露。</p>
<p data-nodeid="473185">第 10 课时提到的模块问题就是其中之一，但庆幸的是，ES6 模块在原生层面解决了这个问题，不同环境下的兼容性问题也可以由工具转化代码来解决。</p>
<p data-nodeid="473186">这一课时要提到的<strong data-nodeid="473272">类型问题</strong>，是一个需要依赖第三方规范和工具来解决的缺陷。JavaScript 的类型问题具体表现在下面 3 个方面。</p>
<p data-nodeid="473187"><strong data-nodeid="473280">1.</strong> <strong data-nodeid="473281">类型声明</strong></p>
<p data-nodeid="473188">前面在第 08 课时中已经提过命名的提升特性，如果某个变量命名提升到全局，那么将是危险的。比如下面的代码，函数 fn 内部使用了一个变量 c，由于忘记使用关键字来声明，结果导致覆盖了全局变量 c。</p>
<pre class="lang-javascript" data-nodeid="473189"><code data-language="javascript"><span class="hljs-keyword">var</span> c = <span class="hljs-number">0</span>
...
function fn() &#123;
&nbsp; ...
&nbsp; c = <span class="hljs-number">30</span>;
&#125;
fn();
</code></pre>
<p data-nodeid="473190"><strong data-nodeid="473290">2.</strong> <strong data-nodeid="473291">动态类型</strong></p>
<p data-nodeid="473191">动态类型是指在运行期间才做数据类型检查的语言，即动态类型语言编程时，不用给任何变量指定数据类型。</p>
<p data-nodeid="473192">下面是一个简单的例子，定义了一个函数  printId 来返回某个对象的 id 属性。如果我们在调用函数 printId 时要想了解参数 user 的数据结构和返回值类型，只能通过查看源码，或者运行时调试、打印来获取。当函数结构复杂，参数较多时这个过程就会大大降低代码的可维护性。虽然添加注释能在一定程度上缓解问题，但为函数编写注释并不是强制性约束，能否及时同步注释也可能会成为新的问题。</p>
<p data-nodeid="473193">就函数 printId 本身而言，也无法在编译时校验参数的合法性，只能在运行时添加校验逻辑，这也大大增加了程序出现 bug 的概率。</p>
<pre class="lang-javascript" data-nodeid="473194"><code data-language="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printId</span>(<span class="hljs-params">user</span>) </span>&#123;
  <span class="hljs-keyword">return</span> user.id
&#125;
</code></pre>
<p data-nodeid="473195"><strong data-nodeid="473302">3.</strong> <strong data-nodeid="473303">弱类型</strong></p>
<p data-nodeid="473196">弱类型是指一个变量可以被赋予不同数据类型的值。这也是一个既灵活又可怕的特性，编写代码的时候非常方便，不用考虑变量的数据类型，但这也很容易出现 bug，调试起来会变得相当困难。</p>
<pre class="lang-javascript" data-nodeid="473197"><code data-language="javascript"><span class="hljs-keyword">var</span> tmp = []
...
tmp = <span class="hljs-literal">null</span>
...
<span class="hljs-comment">// tmp 到底会变成什么？</span>
</code></pre>
<p data-nodeid="473198">为了解决上面 3 个问题，开源社区提供了解决方案——TypeScript。它是基于 JavaScript 的语法糖，也就是说 TypeScript 代码没有单独的运行环境，需要编译成 JavaScript 代码之后才能运行。<br>
从它的名字不难看出，它的核心特性是类型“Type”。具体工作原理就是在代码编译阶段进行类型检测，这样就能在代码部署运行之前及时发现问题。</p>
<h3 data-nodeid="473199">类型与接口</h3>
<p data-nodeid="473200">TypeScript 让 JavaScript 变成了<strong data-nodeid="473324">静态强类型****、变量</strong>需要严格声明的语言，为此定义了两个重要概念：<strong data-nodeid="473326">类型（type）<strong data-nodeid="473325">和</strong>接口（interface）</strong>。</p>
<p data-nodeid="473201">TypeScript 在 JavaScript 原生类型的基础上进行了扩展，但为了和基础类型对象进行区分，采用了小写的形式，比如 Number 类型对应的是 number。类型之间可以互相组合形成新的类型。</p>
<p data-nodeid="473202">一些数据类型在前面第 07 课时中已经提过，这里不再赘述。下面补充一下 TypeScript 扩展的类型。</p>
<p data-nodeid="473203"><strong data-nodeid="473336">1.</strong> <strong data-nodeid="473337">元组</strong></p>
<p data-nodeid="473204">元组可以看成是具有固定长度的数组，其中数组元素类型可以不同。比如下面的代码声明了一个元组变量 x，x 的第一个元素是字符串，第二个是数字；又比如 react hooks 就是用到了元组类型。</p>
<pre class="lang-typescript" data-nodeid="473205"><code data-language="typescript"><span class="hljs-keyword">let</span> x: [<span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span>];
</code></pre>
<p data-nodeid="473206"><strong data-nodeid="473346">2.</strong> <strong data-nodeid="473347">枚举</strong></p>
<p data-nodeid="473207">枚举指的是带有名字的常量，可以分为<strong data-nodeid="473361">数字枚举</strong>、<strong data-nodeid="473362">字符串枚举</strong>和<strong data-nodeid="473363">异构枚举</strong>（字符串和数字的混合）3 种。比较适用于前后端通用的枚举值，比如通过 AJAX 请求获取的数据状态，对于仅在前端使用的枚举值还是推荐使用 Symbol。</p>
<p data-nodeid="473208">下面是一个异构枚举的例子，定义了数字枚举值 0 和字符串枚举值 "YES"。</p>
<pre class="lang-typescript" data-nodeid="473209"><code data-language="typescript"><span class="hljs-built_in">enum</span> example &#123;
    No = <span class="hljs-number">0</span>,
    Yes = <span class="hljs-string">"YES"</span>,
&#125;
</code></pre>
<p data-nodeid="473210">也可以使用 const 修饰符来定义枚举值，通过这种定义方式，TypeScript 会在编译的时候，直接把枚举引用替换成对应的枚举值而非创建枚举对象。</p>
<pre class="lang-typescript" data-nodeid="473211"><code data-language="typescript"><span class="hljs-built_in">enum</span> example &#123;
&nbsp; &nbsp; No = <span class="hljs-number">0</span>,
&nbsp; &nbsp; Yes = <span class="hljs-string">"YES"</span>,
&#125;
<span class="hljs-built_in">console</span>.log(example.No)
<span class="hljs-comment">// 编译成</span>
<span class="hljs-keyword">var</span> example;
(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">example</span>) </span>&#123;
&nbsp; &nbsp; example[example[<span class="hljs-string">"No"</span>] = <span class="hljs-number">0</span>] = <span class="hljs-string">"No"</span>;
&nbsp; &nbsp; example[<span class="hljs-string">"Yes"</span>] = <span class="hljs-string">"YES"</span>;
&#125;)(example || (example = &#123;&#125;));
<span class="hljs-built_in">console</span>.log(example.No);
<span class="hljs-comment">////////////</span>
<span class="hljs-keyword">const</span> <span class="hljs-built_in">enum</span> example &#123;
&nbsp; &nbsp; No = <span class="hljs-number">0</span>,
&nbsp; &nbsp; Yes = <span class="hljs-string">"YES"</span>,
&#125;
<span class="hljs-built_in">console</span>.log(example.No)
<span class="hljs-comment">//  编译成</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-number">0</span> <span class="hljs-comment">/* No */</span>);
</code></pre>
<p data-nodeid="473212"><strong data-nodeid="473377">3.</strong> <strong data-nodeid="473378">any</strong></p>
<p data-nodeid="473213">any 类型代表可以是任何一种类型，所以会跳过类型检查，相当于让变量或返回值又变成弱类型。因此建议尽量减少 any 类型的使用。</p>
<p data-nodeid="473214"><strong data-nodeid="473387">4.</strong> <strong data-nodeid="473388">void</strong></p>
<p data-nodeid="473215">void 表示没有任何类型，常用于描述无返回值的函数。</p>
<p data-nodeid="473216"><strong data-nodeid="473397">5.</strong> <strong data-nodeid="473398">never</strong></p>
<p data-nodeid="473217">never 类型表示的是那些永不存在的值的类型，对于一些特殊的校验场景比较有用，比如代码的完整性检查。下面的示例代码通过穷举判断变量 u 的值来执行对应逻辑，如果此时变量 u 的可选值新增了字符串 "c"，那么这段代码并不会给出提示告诉开发者还有一种  u 等于字符串 "c" 的场景，但如果增加 never 类型赋值的话在编译时就可以给出提示。</p>
<pre class="lang-typescript" data-nodeid="473218"><code data-language="typescript"><span class="hljs-keyword">let</span> u: <span class="hljs-string">'a'</span>|<span class="hljs-string">'b'</span>
<span class="hljs-comment">//...</span>
<span class="hljs-keyword">if</span>(u === <span class="hljs-string">'a'</span>) &#123;
&nbsp; <span class="hljs-comment">//...</span>
&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (u === <span class="hljs-string">'b'</span>) &#123;
&nbsp; <span class="hljs-comment">//...</span>
&#125;
</code></pre>
<p data-nodeid="473219">增加了 never 类型变量赋值：</p>
<pre class="lang-typescript" data-nodeid="473220"><code data-language="typescript"><span class="hljs-keyword">let</span> u: <span class="hljs-string">'a'</span>|<span class="hljs-string">'b'</span>|<span class="hljs-string">'c'</span>
<span class="hljs-comment">//...</span>
<span class="hljs-keyword">if</span>(u === <span class="hljs-string">'a'</span>) &#123;
&nbsp; <span class="hljs-comment">//...</span>
&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (u === <span class="hljs-string">'b'</span>) &#123;
&nbsp; <span class="hljs-comment">//...</span>
&#125; <span class="hljs-keyword">else</span> &#123;
&nbsp; <span class="hljs-keyword">let</span> trmp: <span class="hljs-built_in">never</span> = u&nbsp;<span class="hljs-comment">// Type '"c"' is not assignable to type 'never'.</span>
&#125;
</code></pre>
<p data-nodeid="473221">接口的作用和类型非常相似，在大多数情况下可以通用，只存在一些细小的区别（比如同名接口可以自动合并，而类型不能；在编译器中将鼠标悬停在接口上显示的是接口名称，悬停在类型上显示的是字面量类型），最明显的区别还是在写法上。</p>
<pre class="lang-typescript" data-nodeid="473222"><code data-language="typescript"><span class="hljs-comment">/* 声明 */</span>
<span class="hljs-keyword">interface</span> IA &#123;
  id: <span class="hljs-built_in">string</span>
&#125;
<span class="hljs-keyword">type</span> TA = &#123;
  id: <span class="hljs-built_in">string</span>
&#125;
<span class="hljs-comment">/* 继承 */</span>
<span class="hljs-keyword">interface</span> IA2 <span class="hljs-keyword">extends</span> IA &#123;
&nbsp; &nbsp; name: <span class="hljs-built_in">string</span>
&#125;
<span class="hljs-keyword">type</span> TA2 = TA &amp; &#123; name: <span class="hljs-built_in">string</span> &#125;
<span class="hljs-comment">/* 实现 */</span>
<span class="hljs-keyword">class</span> A <span class="hljs-keyword">implements</span> IA &#123;
&nbsp; &nbsp; id: <span class="hljs-built_in">string</span> = <span class="hljs-string">''</span>
&#125;
<span class="hljs-keyword">class</span> A2 <span class="hljs-keyword">implements</span> TA &#123;
&nbsp; &nbsp; id: <span class="hljs-built_in">string</span> = <span class="hljs-string">''</span>
&#125;
</code></pre>
<h3 data-nodeid="473223">类型抽象</h3>
<p data-nodeid="473224"><strong data-nodeid="473415">泛型</strong>是对类型的一种抽象，一般用于函数，能让调用者动态地指定部分数据类型。这一点和 any 类型有些像，对于类型的定义具有不确定性，可以指代多种类型，但最大区别在于泛型可以对函数成员或类成员产生约束关系。</p>
<p data-nodeid="473225">下面代码是 react 的钩子函数 useState 的类型定义，就用到了泛型。</p>
<pre class="lang-typescript" data-nodeid="473226"><code data-language="typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">useState</span>&lt;<span class="hljs-title">S</span>&gt;(<span class="hljs-params">initialState: S | (() =&gt; S)</span>): [<span class="hljs-title">S</span>, <span class="hljs-title">Dispatch</span>&lt;<span class="hljs-title">SetStateAction</span>&lt;<span class="hljs-title">S</span>&gt;&gt;]</span>;
</code></pre>
<p data-nodeid="473227">这段代码中 S 称为<strong data-nodeid="473424">泛型变量</strong>。从这个定义可看出，useState 可以接收任何类型的参数或回调函数，但返回的元组数据第一个值必定和参数类型或者回调函数返回值类型相同，都为 S。<br>
如果使用 any 类型来取代泛型，那么我们只能知道允许传入任何参数或回调函数，而无法知道返回值与入参的对应关系。</p>
<p data-nodeid="473228">在使用泛型的时候，我们可以通过尖括号来手动指定泛型变量的类型，这个指定操作称之为**类型断言，**也可以不指定，让 TypeScript 自行推断类型。比如下面的代码就通过类型断言，将范型变量指定为 string 类型。</p>
<pre class="lang-typescript" data-nodeid="473229"><code data-language="typescript"><span class="hljs-keyword">const</span> [id, setId] = useState&lt;<span class="hljs-built_in">string</span>&gt;(<span class="hljs-string">''</span>);
</code></pre>
<h3 data-nodeid="473230">类型组合</h3>
<p data-nodeid="473231">类型组合就是把现有的多种类型叠加到一起，组合成一种新的类型，具体有两种方式。</p>
<h4 data-nodeid="473232"><strong data-nodeid="473435">交叉</strong></h4>
<p data-nodeid="473233">交叉就是将多个类型合并为一个类型，操作符为 “&amp;” 。下面的代码定义了一个 Admin 类型，它同时是类型 Student 和类型 Teacher 的交叉类型。 就是说 Admin 类型的对象同时拥有了这 2 种类型的成员。</p>
<pre class="lang-typescript" data-nodeid="473234"><code data-language="typescript"><span class="hljs-keyword">type</span> Admin = Student &amp; Teacher
</code></pre>
<h4 data-nodeid="473235"><strong data-nodeid="473442">联合</strong></h4>
<p data-nodeid="473236">联合就是表示符合多种类型中的任意一个，不同类型通过操作符“|”连接。下面代码定义的类型是 AorB，表示该类型值可以是类型 A，也可以是类型 B。</p>
<pre class="lang-typescript" data-nodeid="473237"><code data-language="typescript"><span class="hljs-keyword">type</span> A = &#123;
  a: <span class="hljs-built_in">string</span>
&#125;
<span class="hljs-keyword">type</span> B = &#123;
  b: <span class="hljs-built_in">number</span>
&#125;
<span class="hljs-keyword">type</span> AorB = A | B
</code></pre>
<p data-nodeid="473238">对于联合类型 AorB，我们能够确定的是它包含了 A 和 B 中共有的成员。如果我们想确切地了解值是否为类型 A，只能通过检查值的方法是否存在来进行判断。例如，下面的变量 v 属于 AorB 类型，在需要确认其具体类型时，先将变量 v 的类型断言为 A，然后再调用其属性 a 进行判断。</p>
<pre class="lang-typescript" data-nodeid="473239"><code data-language="typescript"><span class="hljs-keyword">let</span> v: AorB
<span class="hljs-comment">// ...</span>
<span class="hljs-keyword">if</span> ((&lt;A&gt;v).a) &#123;
&nbsp; <span class="hljs-comment">//...</span>
&#125; <span class="hljs-keyword">else</span> &#123;
&nbsp; (&lt;B&gt;v).b
&nbsp; <span class="hljs-comment">//...</span>
&#125;
</code></pre>
<h3 data-nodeid="473240">类型引用</h3>
<h4 data-nodeid="477306" class="">索引</h4>



<p data-nodeid="473242">索引类型的目的是让 TypeScript 编译器检查出使用了动态属性名的类型，需要通过<strong data-nodeid="473459">索引类型查询</strong>和<strong data-nodeid="473460">索引类型访问</strong>来实现。</p>
<p data-nodeid="473243">下面的示例代码实现了一个简单的函数 getValue ，传入对象和对象属性名获取对应的值。</p>
<pre class="lang-typescript" data-nodeid="473244"><code data-language="typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getValue</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">K</span> <span class="hljs-title">extends</span> <span class="hljs-title">keyof</span> <span class="hljs-title">T</span>&gt;(<span class="hljs-params">o: T, name: K</span>): <span class="hljs-title">T</span>[<span class="hljs-title">K</span>] </span>&#123;
&nbsp; &nbsp; <span class="hljs-keyword">return</span> o[name]; <span class="hljs-comment">// o[name] is of type T[K]</span>
&#125;
<span class="hljs-keyword">let</span> com = &#123;
&nbsp; &nbsp; name: <span class="hljs-string">'lagou'</span>,
&nbsp; &nbsp; id: <span class="hljs-number">123</span>
&#125;
<span class="hljs-keyword">let</span> id: <span class="hljs-built_in">number</span> = getValue(com, <span class="hljs-string">'id'</span>)
<span class="hljs-keyword">let</span> no = getValue(com, <span class="hljs-string">'no'</span>) <span class="hljs-comment">//报错：Argument of type '"no"' is not assignable to parameter of type '"id" | "name"'.</span>
</code></pre>
<p data-nodeid="477932">其中，泛型变量 K 继承了泛型变量 T 的属性名联合，这里的 keyof 就是索引类型查询操作符；返回值 T[K] 就是索引访问操作符的使用方式。</p>
<p data-nodeid="477933">前面提到的 Pick 类型就是通过索引类型来实现的。</p>
<h4 data-nodeid="473246">映射</h4>
<p data-nodeid="473247">映射类型是指从已有类型中创建新的类型。TypeScript 预定义了一些类型，比如最常用的 Pick 和 Omit。</p>
<p data-nodeid="473248">下面是 Pick 类型的使用示例及源码，可以看到类型 Pick 从类型 task 中选择属性 "title" 和 "description" 生成了新的类型 simpleTask。</p>
<pre class="lang-typescript" data-nodeid="473249"><code data-language="typescript"><span class="hljs-keyword">type</span> Pick&lt;T, K <span class="hljs-keyword">extends</span> keyof T&gt; = &#123;
&nbsp; [P <span class="hljs-keyword">in</span> K]: T[P];
&#125;;
<span class="hljs-keyword">interface</span> task &#123;
&nbsp; title: <span class="hljs-built_in">string</span>;
&nbsp; description: <span class="hljs-built_in">string</span>;
  status: <span class="hljs-built_in">string</span>;
&#125;
<span class="hljs-keyword">type</span> simpleTask = Pick&lt;task, <span class="hljs-string">'title'</span> | <span class="hljs-string">'description'</span>&gt;<span class="hljs-comment">// &#123;title: string;description: string&#125;</span>
</code></pre>
<p data-nodeid="478564">类型 Pick 的实现，先用到了索引类型查询，获取了类型 T 的属性名联合 K，然后通过操作符 in 对其进行遍历，同时又用到了索引类型访问来表示属性值。</p>
<p data-nodeid="478565">由于篇幅所限，更多的预定义类型这里就不一一讲解了，对实现原理感兴趣的同学可以参看其<a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/blob/master/lib/lib.es5.d.ts" data-nodeid="478570">源码</a>。</p>
<h3 data-nodeid="473251">实践：编写类型声明</h3>
<p data-nodeid="473252">结合上面所说的内容，再通过一个例子来加深理解。我们以第 03 课时的代码 2 的 debounce 函数为例，为这段代码添加类型声明，转换成 TeypScript 语法。</p>
<p data-nodeid="473253">需要添加类型声明的地方通常是<strong data-nodeid="473494">变量和函数</strong>。</p>
<p data-nodeid="473254">首先给函数 debounce 添加类型，包括参数类型和返回值类型。参数类型使用泛型变量，在调用函数 debounce 的时候手动指定，泛型变量有 3 个：函数 T 、函数 T 的返回值 U 和 函数 T 的参数 V。</p>
<p data-nodeid="473255">然后是变量 timeout ，当定时器存在时它的值为 number，定时器不存在时值为 null。</p>
<p data-nodeid="473256">最后按照之前定义的泛型变量给函数 debounced 和函数 flush 添加类型声明。</p>
<p data-nodeid="473257">具体代码如下：</p>
<pre class="lang-typescript" data-nodeid="473258"><code data-language="typescript"><span class="hljs-keyword">const</span> debounce = &lt;T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">Function</span>, U, V <span class="hljs-keyword">extends</span> <span class="hljs-built_in">any</span>[]&gt;<span class="hljs-function">(<span class="hljs-params">func: T, wait: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span></span>) =&gt;</span> &#123;
&nbsp; <span class="hljs-keyword">let</span> timeout: <span class="hljs-built_in">number</span> | <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>
&nbsp; <span class="hljs-keyword">let</span> args: V
&nbsp; <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">debounced</span>(<span class="hljs-params">...arg: V</span>): <span class="hljs-title">Promise</span>&lt;<span class="hljs-title">U</span>&gt; </span>&#123;
&nbsp; &nbsp; args = arg
&nbsp; &nbsp; <span class="hljs-keyword">if</span>(timeout) &#123;
&nbsp; &nbsp; &nbsp; <span class="hljs-built_in">clearTimeout</span>(timeout)
&nbsp; &nbsp; &nbsp; timeout = <span class="hljs-literal">null</span>
&nbsp; &nbsp; &#125;
&nbsp; &nbsp; <span class="hljs-comment">// 以 Promise 的形式返回函数执行结果</span>
&nbsp; &nbsp; <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">res, rej</span>) =&gt;</span> &#123;
&nbsp; &nbsp; &nbsp; timeout = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">async</span> () =&gt; &#123;
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">try</span> &#123;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">const</span> result: U = <span class="hljs-keyword">await</span> func.apply(<span class="hljs-built_in">this</span>, args)
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res(result)
&nbsp; &nbsp; &nbsp; &nbsp; &#125; <span class="hljs-keyword">catch</span>(e) &#123;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rej(e)
&nbsp; &nbsp; &nbsp; &nbsp; &#125;
&nbsp; &nbsp; &nbsp; &#125;, wait)
&nbsp; &nbsp; &#125;)
&nbsp; &#125;
&nbsp; <span class="hljs-comment">// 允许取消</span>
&nbsp; <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cancel</span>(<span class="hljs-params"></span>) </span>&#123;
&nbsp; &nbsp; <span class="hljs-built_in">clearTimeout</span>(timeout)
&nbsp; &nbsp; timeout = <span class="hljs-literal">null</span>
&nbsp; &#125;
&nbsp; <span class="hljs-comment">// 允许立即执行</span>
&nbsp; <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flush</span>(<span class="hljs-params"></span>): <span class="hljs-title">U</span> </span>&#123;
&nbsp; &nbsp; cancel()
&nbsp; &nbsp; <span class="hljs-keyword">return</span> func.apply(<span class="hljs-built_in">this</span>, args)
&nbsp; &#125;
&nbsp; debounced.cancel = cancel
&nbsp; debounced.flush = flush
&nbsp; <span class="hljs-keyword">return</span> debounced
&#125;
</code></pre>
<h3 data-nodeid="473259">总结</h3>
<p data-nodeid="473260">这一课时重点讲述了如何通过 TypeScript 来解决 JavaScript 的类型问题，TypeScript 在原有的基础类型上进行了扩展，理解 TypeScript 的基本类型并不难，重点需要掌握如何通过泛型来对类型进行抽象，如何通过组合及引用来对已有的类型创建新的类型。</p>
<p data-nodeid="473261">最后布置一道思考题：TypeScript 能较好地解决编译时类型校验的问题，但无法对运行时的数据（比如通过 AJAX 请求获得的数据）进行校验，你能想到有什么好的方法解决这个问题吗？</p>

<hr>
<h3 id="精选评论"><a href="#精选评论" class="headerlink" title="精选评论"></a>精选评论</h3><h5 id="磊："><a href="#磊：" class="headerlink" title="**磊："></a>**磊：</h5><blockquote>
<p>有些项目做着做着就变成了anyscript</p>
</blockquote>
<h5 id="霄："><a href="#霄：" class="headerlink" title="*霄："></a>*霄：</h5><blockquote>
<p>看到 never，发现看完 never 的解释仍然不清楚，于是看 TS 文档，非常清楚，never 表示用于永远不会发生的值类型，一般用作执行不到 return 的函数返回值类型。never 是任意类型的子类型，却没有任意类型是 never 的子类型。&#96;&#96;&#96;js&#x2F;&#x2F; Function returning never must have unreachable end point<br>function error(message: string): never {<br>throw new Error(message);<br>}</p>
</blockquote>
<p>&#x2F;&#x2F; Inferred return type is never<br>function fail() {<br>    return error(“Something failed”);<br>}</p>
<p>&#x2F;&#x2F; Function returning never must have unreachable end point<br>function infiniteLoop(): never {<br>    while (true) {<br>    }<br>}&#96;&#96;&#96;</p>
<h5 id="道："><a href="#道：" class="headerlink" title="*道："></a>*道：</h5><blockquote>
<p>思考题：可以利用泛型化请求响应类型来解决</p>
</blockquote>
<h5 id="飞："><a href="#飞：" class="headerlink" title="**飞："></a>**飞：</h5><blockquote>
<p>命名提升，还用let可以解决这个问题吗？还是打包转换之后，都会变成var?</p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-讲师回复："><a href="#amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; let 可以避免命名提升；如果在打包时转换成ES5语法，是会变成var的。</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/11/02/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4-JavaScript-%E4%B8%8D%E9%80%82%E5%90%88%E5%A4%A7%E5%9E%8B%E9%A1%B9%E7%9B%AE%EF%BC%9F/" data-id="claxeer9t000lv8w16lg68m05" data-title="为什么说 JavaScript 不适合大型项目？" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-怎么复用你的代码？" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/11/02/%E6%80%8E%E4%B9%88%E5%A4%8D%E7%94%A8%E4%BD%A0%E7%9A%84%E4%BB%A3%E7%A0%81%EF%BC%9F/" class="article-date">
  <time class="dt-published" datetime="2022-11-02T03:02:31.000Z" itemprop="datePublished">2022-11-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/11/02/%E6%80%8E%E4%B9%88%E5%A4%8D%E7%94%A8%E4%BD%A0%E7%9A%84%E4%BB%A3%E7%A0%81%EF%BC%9F/">怎么复用你的代码？</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p data-nodeid="3527" class="">作为前端工程师的你，或许早已习惯了在编写浏览器组件时使用 import 和 from 来管理代码模块，在编写 Node.js 服务时通过 require 和 module.exports 来复用代码。但 JavaScript 模块化之路充满了坎坷。这一课时就带你由近及远，看看 JavaScript 模块发展史上那些著名的模块规范与实现。</p>
<h3 data-nodeid="3528">ES6 模块</h3>
<p data-nodeid="3529">目前最主流的模块化方案应该是 ECMAScript 2015 提出的模块化规范（也称“<strong data-nodeid="3658">ES6 模块</strong>”），这个规范同时适用于 JavaScript 的前后端环境。</p>
<h4 data-nodeid="3530">定义和引用</h4>
<p data-nodeid="3531">由于目前大多数项目都使用了 ES6 模块规范，大家对用法应该比较熟悉，这里就不多介绍了，只补充 3 个小知识：</p>
<ul data-nodeid="3532">
<li data-nodeid="3533">
<p data-nodeid="3534">ES6 模块<strong data-nodeid="3666">强制自动采用严格模式</strong>，所以说不管有没有“user strict”声明都是一样的，换言之，编写代码的时候不必再刻意声明了；</p>
</li>
<li data-nodeid="3535">
<p data-nodeid="3536">虽然大部分主流浏览器支持 ES6 模块，但是和引入普通 JS 的方式略有不同，需要在对应 script 标签中将属性 type 值设置为“module”才能被正确地解析为 ES6 模块；</p>
</li>
<li data-nodeid="3537">
<p data-nodeid="3538">在 Node.js 下使用 ES6 模块则需要将文件名后缀改为“.mjs”，用来和 Node.js 默认使用的 CommonJS 规范模块作区分。</p>
</li>
</ul>
<h4 data-nodeid="3539">特性</h4>
<p data-nodeid="3540">ES6 模块有两个重要特性一定要掌握，一个是<strong data-nodeid="3679">值引用</strong>，另一个是<strong data-nodeid="3680">静态声明</strong>。</p>
<p data-nodeid="3541">值引用是指 export 语句输出的接口，<strong data-nodeid="3686">与其对应的值是动态绑定关系</strong>。即通过该接口，可以取到模块内部实时的值，可以简单地理解为变量浅拷贝。</p>
<p data-nodeid="3542">下面是一个简单的例子，模块 a 导出变量 a，初始值为空字符串，500 毫秒后赋值为字符串 'a'；模块 b 引用模块 a 并打印，控制台输出空字符串，1 秒后继续打印，控制台输出字符串 'a'。</p>
<pre class="lang-javascript" data-nodeid="3543"><code data-language="javascript"><span class="hljs-comment">// a.js</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">var</span> a = <span class="hljs-string">''</span>;
setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> a = <span class="hljs-string">'a'</span>, <span class="hljs-number">500</span>);
<span class="hljs-comment">// b.js</span>
<span class="hljs-keyword">import</span> &#123; a &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./a.js'</span>
<span class="hljs-built_in">console</span>.log(a) <span class="hljs-comment">// ''</span>
setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(a), <span class="hljs-number">1000</span>) <span class="hljs-comment">// 'a'</span>
</code></pre>
<p data-nodeid="3544">ES6 模块对于引用声明有严格的要求，首先必须在文件的首部，不允许使用变量或表达式，不允许被嵌入到其他语句中。所以下面 3 种引用模块方式都会报错。</p>
<pre class="lang-javascript" data-nodeid="3545"><code data-language="javascript"><span class="hljs-comment">// 必须首部声明</span>
<span class="hljs-keyword">let</span> a = <span class="hljs-number">1</span>
<span class="hljs-keyword">import</span> &#123; app &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./app'</span>;
<span class="hljs-comment">// 不允许使用变量或表达式</span>
<span class="hljs-keyword">import</span> &#123; <span class="hljs-string">'a'</span> + <span class="hljs-string">'p'</span> + <span class="hljs-string">'p'</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./app'</span>;
<span class="hljs-comment">// 不允许被嵌入语句逻辑</span>
<span class="hljs-keyword">if</span> (moduleName === <span class="hljs-string">'app'</span>) &#123;
&nbsp; <span class="hljs-keyword">import</span> &#123; init &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./app'</span>;
&#125; <span class="hljs-keyword">else</span> &#123;
&nbsp; <span class="hljs-keyword">import</span> &#123; init &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./bpp'</span>;
&#125;
</code></pre>
<p data-nodeid="3546">定义这些严格的要求可不仅仅是为了代码的可读性，更重要的是可以对代码进行静态分析。</p>
<p data-nodeid="3547"><strong data-nodeid="3702">静态分析</strong>是指不需要执行代码，只从字面量上对代码进行分析。例如，在上面的错误代码中，有一段代码需要通过判断变量 moduleName 的值来加载对应的模块，这就意味着需要执行代码之后才能判断加载哪个模块，而 ES6 模块则不需要。这样做的好处是方便优化代码体积，比如通过 Tree-shaking 操作消除模块中没有被引用或者执行结果不会被用到的无用代码。</p>
<h3 data-nodeid="3548">延伸 1：import 的动态模块提案</h3>
<p data-nodeid="3549">虽然 ES6 模块设计在 90% 情况下是很有用的，特别是配合一些工具使用，但是却无法应付某些特殊场景。比如，出于性能原因对代码进行动态加载，所以在 ES2020 规范提案中，希望通过 <a target="_blank" rel="noopener" href="https://github.com/tc39/proposal-dynamic-import" data-nodeid="3707">import()</a> 函数来支持动态引入模块。</p>
<p data-nodeid="3550">具体用法如下所示，调用 import() 函数传入模块路径，得到一个 Promise 对象。</p>
<pre class="lang-javascript" data-nodeid="3551"><code data-language="javascript"><span class="hljs-keyword">import</span>(<span class="hljs-string">`./section-modules/<span class="hljs-subst">$&#123;link.dataset.entryModule&#125;</span>.js`</span>)
.then(<span class="hljs-function"><span class="hljs-params">module</span> =&gt;</span> &#123;
  <span class="hljs-built_in">module</span>.loadPageInto(main);
&#125;)
.catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;
  main.textContent = err.message;
&#125;);
</code></pre>
<p data-nodeid="3552">import() 函数违反了上面静态声明的所有要求，并且提供了其他更强大的功能特性。</p>
<ul data-nodeid="3553">
<li data-nodeid="3554">
<p data-nodeid="3555">违反首部声明要求，那么就意味着可以在代码运行时<strong data-nodeid="3716">按需加载</strong>模块，这个特性就可以用于首屏优化，根据路由和组件只加载依赖的模块。</p>
</li>
<li data-nodeid="3556">
<p data-nodeid="3557">违反变量或表达式要求，则意味着可以根据参数<strong data-nodeid="3722">动态加载</strong>模块。</p>
</li>
<li data-nodeid="3558">
<p data-nodeid="3559">违反嵌入语句逻辑规则，可想象空间更大，比如可以通过 Promise.race 方式同时加载多个模块，选择加载速度最优模块来使用，从而提升性能。</p>
</li>
</ul>
<h3 data-nodeid="3560">CommonJS</h3>
<p data-nodeid="3561">CommonJS 最初名为 Server.js，是为浏览器之外的 JavaScript 运行环境提供的模块规范，最终被 Node.js 采用。</p>
<h4 data-nodeid="3562">定义和引用</h4>
<p data-nodeid="3563">CommonJS 规定每个文件就是一个模块，有独立的作用域。每个模块内部，都有一个 module 对象，代表当前模块。通过它来导出 API，它有以下属性：</p>
<ul data-nodeid="3564">
<li data-nodeid="3565">
<p data-nodeid="3566">id 模块的识别符，通常是带有绝对路径的模块文件名；</p>
</li>
<li data-nodeid="3567">
<p data-nodeid="3568">filename 模块的文件名，带有绝对路径；</p>
</li>
<li data-nodeid="3569">
<p data-nodeid="3570">loaded 返回一个布尔值，表示模块是否已经完成加载；</p>
</li>
<li data-nodeid="3571">
<p data-nodeid="3572">parent 返回一个对象，表示调用该模块的模块；</p>
</li>
<li data-nodeid="3573">
<p data-nodeid="3574">children 返回一个数组，表示该模块要用到的其他模块；</p>
</li>
<li data-nodeid="3575">
<p data-nodeid="3576">exports 表示模块对外输出的值。</p>
</li>
</ul>
<p data-nodeid="3577">引用模块则需要通过 require 函数，它的基本功能是，读入并执行一个 JavaScript 文件，然后返回该模块的 exports 对象。</p>
<h4 data-nodeid="3578">特性</h4>
<p data-nodeid="7121" class="te-preview-highlight">CommonJS 特性和 ES6 恰恰相反，它采用的是<strong data-nodeid="7135">值拷贝</strong>和<strong data-nodeid="7136">动态声明</strong>。值拷贝和值引用相反，一旦输出一个值，模块内部的变化就影响不到这个值了，可以简单地理解为<strong data-nodeid="7137">变量浅拷贝</strong>。</p>





<p data-nodeid="3580">仍然使用上面的例子，改写成 CommonJS 模块，在 Node.js 端运行，控制台会打印两个空字符串。</p>
<pre class="lang-java" data-nodeid="3581"><code data-language="java"><span class="hljs-comment">// a.js</span>
<span class="hljs-keyword">var</span> a = <span class="hljs-string">''</span>;
setTimeout(() =&gt; a = <span class="hljs-string">'a'</span>, <span class="hljs-number">500</span>);
<span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = a
<span class="hljs-comment">// b.js</span>
<span class="hljs-keyword">var</span> a = require(<span class="hljs-string">'./a.js'</span>)
console.log(a) <span class="hljs-comment">// ''</span>
setTimeout(() =&gt; console.log(a), <span class="hljs-number">1000</span>) <span class="hljs-comment">// ''</span>
</code></pre>
<p data-nodeid="3582">动态声明就很好理解了，就是消除了静态声明的限制，可以“自由”地在表达式语句中引用模块。</p>
<h3 data-nodeid="3583">AMD</h3>
<p data-nodeid="3584">在 ES6 模块出现之前，AMD（Asynchronous Module Definition，异步模块定义）是一种很热门的浏览器模块化方案。</p>
<h4 data-nodeid="3585">定义和引用</h4>
<p data-nodeid="3586">AMD 规范只定义了一个全局函数 define，通过它就可以定义和引用模块，它有 3 个参数：</p>
<pre class="lang-javascript" data-nodeid="3587"><code data-language="javascript">define(id?, dependencies?, factory);
</code></pre>
<p data-nodeid="3588">第 1 个参数 id 为模块的名称，该参数是可选的。如果没有提供该参数，模块的名字应该默认为模块加载器请求的指定脚本的名字；如果提供了该参数，模块名必须是“顶级”的和绝对的（不允许相对名字）。</p>
<p data-nodeid="3589">第 2 个参数 dependencies 是个数组，它定义了所依赖的模块。依赖模块必须根据模块的工厂函数优先级执行，并且执行的结果应该按照依赖数组中的位置顺序以参数的形式传入（定义中模块的）工厂函数中。</p>
<p data-nodeid="3590">第 3 个参数 factory 为模块初始化要执行的函数或对象。如果是函数，那么该函数是单例模式，只会被执行一次；如果是对象，此对象应该为模块的输出值。</p>
<p data-nodeid="3591">下面是一个简单的例子，创建一个名为“alpha”的模块，依赖了 require、exports、beta 3 个模块，并导出了 verb 函数。</p>
<pre class="lang-javascript" data-nodeid="3592"><code data-language="javascript"> define(<span class="hljs-string">"alpha"</span>, [<span class="hljs-string">"require"</span>, <span class="hljs-string">"exports"</span>, <span class="hljs-string">"beta"</span>], <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">require, exports, beta</span>) </span>&#123;
     exports.verb = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
         <span class="hljs-keyword">return</span> beta.verb();
     &#125;
 &#125;);
</code></pre>
<h4 data-nodeid="3593">特性</h4>
<p data-nodeid="3594">它的重要特性就是<strong data-nodeid="3768">异步加载</strong>。所谓异步加载，就是指同时并发加载所依赖的模块，当所有依赖模块都加载完成之后，再执行当前模块的回调函数。这种加载方式和浏览器环境的性能需求刚好吻合。</p>
<p data-nodeid="3595">由于 AMD 并不是浏览器原生支持的模块规范，所以需要借助第三方库来实现，其中最有名的就是 <a target="_blank" rel="noopener" href="https://requirejs.org/" data-nodeid="3772">RequireJS</a>。它的核心是两个全局函数 define 和 require，define 函数可以将依赖注入队列中，并将回调函数定义成模块；require 函数主要作用是创建 script 标签请求对应的模块，然后加载和执行模块。下面是部分源码，有兴趣的同学可以看完整的<a target="_blank" rel="noopener" href="https://requirejs.org/docs/release/2.3.6/comments/require.js" data-nodeid="3776">源码</a>。</p>
<pre class="lang-javascript" data-nodeid="3596"><code data-language="javascript"><span class="hljs-keyword">var</span> requirejs, <span class="hljs-built_in">require</span>, define;
(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">global, setTimeout</span>) </span>&#123;
  ...
  define = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name, deps, callback</span>) </span>&#123;
    ...
    if (context) &#123;
      context.defQueue.push([name, deps, callback]);
      context.defQueueMap[name] = <span class="hljs-literal">true</span>;
    &#125; <span class="hljs-keyword">else</span> &#123;
      globalDefQueue.push([name, deps, callback]);
    &#125;
  &#125;;
  ...
  req.load = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">context, moduleName, url</span>) </span>&#123;
    ...
  &nbsp; if (isBrowser) &#123;
  &nbsp; &nbsp; node = req.createNode(config, moduleName, url);
  &nbsp;   ...
  &nbsp; &nbsp; if (baseElement) &#123;
  &nbsp; &nbsp; &nbsp; head.insertBefore(node, baseElement)
  &nbsp; &nbsp; &#125; <span class="hljs-keyword">else</span> &#123;
  &nbsp; &nbsp; &nbsp; head.appendChild(node)
  &nbsp; &nbsp; &#125;
  &nbsp; &nbsp; currentlyAddingScript = <span class="hljs-literal">null</span>;
  &nbsp; &nbsp; <span class="hljs-keyword">return</span> node
  &nbsp; &#125;
  &#125;;
  ...
&#125;(<span class="hljs-keyword">this</span>, (<span class="hljs-keyword">typeof</span> setTimeout === <span class="hljs-string">'undefined'</span> ? <span class="hljs-literal">undefined</span> : setTimeout)));
</code></pre>
<h3 data-nodeid="3597">CMD</h3>
<p data-nodeid="3598">CMD（Common Module Definition，通用模块定义）是基于浏览器环境制定的模块规范。</p>
<h4 data-nodeid="3599">定义和引用</h4>
<p data-nodeid="3600">CMD 定义模块也是通过一个全局函数 define 来实现的，但只有一个参数，该参数既可以是函数也可以是对象：</p>
<pre class="lang-javascript" data-nodeid="3601"><code data-language="javascript">define(factory);
</code></pre>
<p data-nodeid="3602">如果这个参数是对象，那么模块导出的就是对象；如果这个参数为函数，那么这个函数会被传入 3 个参数 require 、 exports 和 module。</p>
<pre class="lang-javascript" data-nodeid="3603"><code data-language="javascript">define(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">require, exports, module</span>) </span>&#123;
  <span class="hljs-comment">//...</span>
&#125;);
</code></pre>
<p data-nodeid="3604">第 1 个参数 require 是一个函数，通过调用它可以引用其他模块，也可以调用 require.async 函数来异步调用模块。</p>
<p data-nodeid="3605">第 2 个参数 exports 是一个对象，当定义模块的时候，需要通过向参数 exports 添加属性来导出模块 API。</p>
<p data-nodeid="3606">第 3 个参数 module 是一个对象，它包含 3 个属性：</p>
<ul data-nodeid="3607">
<li data-nodeid="3608">
<p data-nodeid="3609">uri，模块完整的 URI 路径；</p>
</li>
<li data-nodeid="3610">
<p data-nodeid="3611">dependencies，模块的依赖；</p>
</li>
<li data-nodeid="3612">
<p data-nodeid="3613">exports，模块需要被导出的 API，作用同第二个参数 exports。</p>
</li>
</ul>
<p data-nodeid="3614">下面是一个简单的例子，定义了一个名为 increment 的模块，引用了 math 模块的 add 函数，经过封装后导出成 increment 函数。</p>
<pre class="lang-javascript" data-nodeid="3615"><code data-language="javascript">define(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">require, exports, module</span>) </span>&#123;
  <span class="hljs-keyword">var</span> add = <span class="hljs-built_in">require</span>(<span class="hljs-string">'math'</span>).add;
  exports.increment = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>) </span>&#123;
    <span class="hljs-keyword">return</span> add(val, <span class="hljs-number">1</span>);
  &#125;;
  <span class="hljs-built_in">module</span>.id = <span class="hljs-string">"increment"</span>;
&#125;);
</code></pre>
<h4 data-nodeid="3616">特性</h4>
<p data-nodeid="3617">CMD 最大的特点就是<strong data-nodeid="3796">懒加载</strong>，和上面示例代码一样，不需要在定义模块的时候声明依赖，可以在模块执行时动态加载依赖。当然还有一点不同，那就是 CMD 同时支持同步加载模块和异步加载模块。</p>
<p data-nodeid="3618">用一句话来形容就是，它<strong data-nodeid="3806">整合了 CommonJS 和 AMD 规范的特点</strong>。遵循 CMD 规范的代表开源项目是 sea.js ，它的实现和 requirejs 没有本质差别，有兴趣的同学可以看其<a target="_blank" rel="noopener" href="https://github.com/seajs/seajs" data-nodeid="3804">源码</a>。</p>
<h3 data-nodeid="3619">UMD</h3>
<p data-nodeid="3620">UMD（Universal Module Definition，统一模块定义）其实并不是模块管理规范，而是带有前后端同构思想的模块封装工具。通过 UMD 可以在合适的环境选择对应的模块规范。比如在 Node.js 环境中采用 CommonJS 模块管理，在浏览器端且支持 AMD 的情况下采用 AMD 模块，否则导出为全局函数。</p>
<p data-nodeid="3621">它的实现原理也比较简单：</p>
<ul data-nodeid="3622">
<li data-nodeid="3623">
<p data-nodeid="3624">先判断是否支持 Node.js 模块格式（exports 是否存在），存在则使用 Node.js 模块格式；</p>
</li>
<li data-nodeid="3625">
<p data-nodeid="3626">再判断是否支持 AMD（define 是否存在），存在则使用 AMD 方式加载模块；</p>
</li>
<li data-nodeid="3627">
<p data-nodeid="3628">若前两个都不存在，则将模块公开到全局（Window 或 Global）。</p>
</li>
</ul>
<p data-nodeid="3629">大致实现如下：</p>
<pre class="lang-javascript" data-nodeid="3630"><code data-language="javascript">(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">root, factory</span>) </span>&#123;
&nbsp; <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> define === <span class="hljs-string">'function'</span> &amp;&amp; define.amd) &#123;
&nbsp; &nbsp; define([], factory);
&nbsp; &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> exports === <span class="hljs-string">'object'</span>) &#123;
<span class="hljs-built_in">module</span>.exports,
&nbsp; &nbsp; <span class="hljs-built_in">module</span>.exports = factory();
&nbsp; &#125; <span class="hljs-keyword">else</span> &#123;
&nbsp; &nbsp; root.returnExports = factory();
&nbsp; &#125;
&#125;(<span class="hljs-keyword">this</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-comment">//。。。</span>
&nbsp; <span class="hljs-keyword">return</span> &#123;&#125;;
&#125;));
</code></pre>
<h3 data-nodeid="3631">延伸 2：ES5 标准下如何编写模块</h3>
<p data-nodeid="3632"><strong data-nodeid="3819">模块的核心就是创建独立的作用域</strong>，要实现这个目的，我们在第 08 课时中提到过，可以通过函数来实现。</p>
<p data-nodeid="3633">如果直接在全局作用域下定义函数会很容易因为命名冲突而导致代码覆盖，为了避免这种情况可以通过对象创建“命名空间”。但是它有个缺点，就是无法创建私有变量，并不符合“高内聚、低耦合”的编码原则，也容易出现 bug。</p>
<pre class="lang-javascript" data-nodeid="3634"><code data-language="javascript"><span class="hljs-keyword">var</span> mod = &#123;
&nbsp;&nbsp;<span class="hljs-attr">a</span>: <span class="hljs-string">''</span>,
&nbsp;&nbsp;<span class="hljs-attr">f</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
     ...
  &#125;,
&#125;
</code></pre>
<p data-nodeid="3635">为了解决这个问题，立即执行函数的形式也就出现了，这种形式就是在定义函数的时候就调用它并导出模块 API。</p>
<pre class="lang-javascript" data-nodeid="3636"><code data-language="javascript"><span class="hljs-keyword">var</span> mod = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">w</span>)</span>&#123;
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;
    ...
  &#125;
  <span class="hljs-keyword">var</span> a = <span class="hljs-string">''</span>
  ... 
  return &#123;
  　　f,
  　　a
  &#125;;
&#125;)(<span class="hljs-built_in">window</span>);
</code></pre>
<p data-nodeid="3637">有了这两个基础知识点，我们再通过 webpack 编译 ES6 模块的例子加深理解。</p>
<p data-nodeid="3638">下面的代码定义了 2 个 ES6 模块，分别是 index.js、m.js，其中模块 index.js 依赖 m.js 模块的 API：</p>
<pre class="lang-javascript" data-nodeid="3639"><code data-language="javascript"><span class="hljs-comment">// index.js</span>
<span class="hljs-keyword">import</span> &#123; text, write &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./m'</span>
write(<span class="hljs-string">`&lt;h1&gt;<span class="hljs-subst">$&#123;text&#125;</span> <span class="hljs-subst">$&#123;text2&#125;</span>&lt;/h1&gt;`</span>)
<span class="hljs-comment">// m.js</span>
<span class="hljs-keyword">const</span> write = <span class="hljs-function"><span class="hljs-params">content</span> =&gt;</span> <span class="hljs-built_in">document</span>.write(content)
<span class="hljs-keyword">var</span> text = <span class="hljs-string">'hello'</span>
<span class="hljs-keyword">export</span> &#123; text, write&nbsp;&#125;
</code></pre>
<p data-nodeid="3640">查看编译后的代码我们发现，整个代码就是一个立即执行函数，这个立即执行函数的参数就是对象形式的模块定义。</p>
<pre class="lang-javascript" data-nodeid="3641"><code data-language="javascript"><span class="hljs-comment">// bundle.js</span>
(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">modules</span>) </span>&#123;
  ...
&#125;)(&#123;
  <span class="hljs-string">"./index.js"</span>: (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, __webpack_exports__, __webpack_require__</span>) </span>&#123;
    ...
  &#125;,
  <span class="hljs-string">"./m.js"</span>: (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, __webpack_exports__, __webpack_require__</span>) </span>&#123;
    ...
  &#125;
&#125;)
</code></pre>
<p data-nodeid="3642">这个立即执行函数会加载一个初始模块，也就是 webpack 配置的 entry 模块，按照依赖关系调用模块对应的函数并缓存。</p>
<pre class="lang-javascript" data-nodeid="3643"><code data-language="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">modules</span>) </span>&#123;&nbsp;
&nbsp; <span class="hljs-keyword">var</span> installedModules = &#123;&#125;;
&nbsp; <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__webpack_require__</span>(<span class="hljs-params">moduleId</span>) </span>&#123;
&nbsp; &nbsp; <span class="hljs-keyword">if</span> (installedModules[moduleId]) &#123;
&nbsp; &nbsp; &nbsp; <span class="hljs-keyword">return</span> installedModules[moduleId].exports;
&nbsp; &nbsp; &#125;
&nbsp; &nbsp; <span class="hljs-keyword">var</span> <span class="hljs-built_in">module</span> = installedModules[moduleId] = &#123;
&nbsp; &nbsp; &nbsp; <span class="hljs-attr">i</span>: moduleId,
&nbsp; &nbsp; &nbsp; <span class="hljs-attr">l</span>: <span class="hljs-literal">false</span>,
&nbsp; &nbsp; &nbsp; <span class="hljs-attr">exports</span>: &#123;&#125;
&nbsp; &nbsp; &#125;;
&nbsp; &nbsp; modules[moduleId].call(<span class="hljs-built_in">module</span>.exports, <span class="hljs-built_in">module</span>, <span class="hljs-built_in">module</span>.exports, __webpack_require__);
&nbsp; &nbsp; <span class="hljs-built_in">module</span>.l = <span class="hljs-literal">true</span>;
&nbsp; &nbsp; <span class="hljs-keyword">return</span> <span class="hljs-built_in">module</span>.exports;
&nbsp; &#125;
&nbsp; ...
&nbsp; return __webpack_require__(__webpack_require__.s = <span class="hljs-string">"./index.js"</span>);
&#125;
</code></pre>
<p data-nodeid="3644">那么这些 ES6 模块是怎么转化成函数的呢？</p>
<p data-nodeid="3645">从上面的代码我们可以看到，每个模块定义函数都会传入 3 个参数，其中参数 module 可以理解为当前模块的配置参数，包含模块 id 等信息。参数 <strong data-nodeid="3840">webpack_exports</strong> 是一个对象，模块需要导出的 API 都可以添加到这个对象上；参数 <strong data-nodeid="3841">webpack_require</strong> 是一个函数，负责引用依赖的模块。</p>
<pre class="lang-javascript" data-nodeid="3646"><code data-language="javascript"><span class="hljs-comment">// index.js 中引入 m.js 模块</span>
<span class="hljs-keyword">var</span> _m__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( <span class="hljs-comment">/*! ./m */</span> <span class="hljs-string">"./m.js"</span>);
<span class="hljs-comment">// m.js 中导出字符串 text 和函数 write</span>
__webpack_require__.d(__webpack_exports__, <span class="hljs-string">"text"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
&nbsp; <span class="hljs-keyword">return</span> text;
&#125;);
__webpack_require__.d(__webpack_exports__, <span class="hljs-string">"write"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
&nbsp; <span class="hljs-keyword">return</span> write;
&#125;);
<span class="hljs-keyword">const</span> write = <span class="hljs-function"><span class="hljs-params">content</span> =&gt;</span> <span class="hljs-built_in">document</span>.write(content)
<span class="hljs-keyword">var</span> text = <span class="hljs-string">'hello'</span>
</code></pre>
<p data-nodeid="3647">这就是通过对象和立即执行函数来实现代码模块化的基本方法，对实现细节有兴趣的同学可以找一段编译后的代码进行研究。</p>
<h3 data-nodeid="3648">总结</h3>
<p data-nodeid="3649">本课时主要介绍了 JavaScript 模块化规范，包括原生规范 ES6 模块、Node.js 采用的 CommonJS，以及开源社区早期为浏览器提供的规范 AMD，具有 CommonJS 特性和 AMD 特性的 CMD，让 CommonJS 和 AMD 模块跨端运行的 UMD。希望你对模块系统有更全面地认识，从而加深对 JavaScript 的理解。</p>
<p data-nodeid="3650" class="">最后留一道思考题：如果要实现一个支持动态加载的 import() 函数，该怎么做呢？</p>

<hr>
<h3 id="精选评论"><a href="#精选评论" class="headerlink" title="精选评论"></a>精选评论</h3><h5 id="磊："><a href="#磊：" class="headerlink" title="**磊："></a>**磊：</h5><blockquote>
<p>首先实现一个配置表，当需要某个JS时 去匹配配置表，然后用JSONP请求过来，eveal执行</p>
</blockquote>
<h5 id="鑫："><a href="#鑫：" class="headerlink" title="*鑫："></a>*鑫：</h5><blockquote>
<p>commonjs是值的深拷贝吧，上面有点问题</p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-讲师回复："><a href="#amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; 属于浅拷贝，被不同模块引用时指向同一个内存空间。</p>
</blockquote>
<h5 id="道："><a href="#道：" class="headerlink" title="*道："></a>*道：</h5><blockquote>
<p>使用 Promise 来实现 动态加载的 import()。</p>
</blockquote>
<h5 id="用户7763："><a href="#用户7763：" class="headerlink" title="**用户7763："></a>**用户7763：</h5><blockquote>
<p>直接请求js文件可还行，像script标签的src一样</p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-1"><a href="#amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-1" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; 建议封装成统一的模块，便于模块之间的隔离和引用~</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/11/02/%E6%80%8E%E4%B9%88%E5%A4%8D%E7%94%A8%E4%BD%A0%E7%9A%84%E4%BB%A3%E7%A0%81%EF%BC%9F/" data-id="claxeera40019v8w13y04ff39" data-title="怎么复用你的代码？" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-为什么代码没有按照编写顺序执行？" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/11/02/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BB%A3%E7%A0%81%E6%B2%A1%E6%9C%89%E6%8C%89%E7%85%A7%E7%BC%96%E5%86%99%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C%EF%BC%9F/" class="article-date">
  <time class="dt-published" datetime="2022-11-02T03:01:52.000Z" itemprop="datePublished">2022-11-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/11/02/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BB%A3%E7%A0%81%E6%B2%A1%E6%9C%89%E6%8C%89%E7%85%A7%E7%BC%96%E5%86%99%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C%EF%BC%9F/">为什么代码没有按照编写顺序执行？</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p data-nodeid="1281" class="">前端工程师算是最幸运的软件工程师，因为从一开始就可以接触到“异步”这种高级特性，比如 DOM 事件、AJAX 请求及定时器；同时也是最不幸的软件工程师，因为入门 JavaScript 的时候就要习惯<strong data-nodeid="1393">异步</strong>这种高难度的开发方式，比如上一课时提到的那道经典的笔试题，就是异步造成的输出结果与预期不一致。</p>
<p data-nodeid="1282">这一课时我们就来深入讲解前端工程师熟悉但并不完全了解的 JavaScript 异步。</p>
<h3 data-nodeid="1283">了解异步</h3>
<h4 data-nodeid="1284">异步和同步</h4>
<p data-nodeid="1285">相比<strong data-nodeid="1406">异步</strong>而言，大多数工程师可能更熟悉的是<strong data-nodeid="1407">同步</strong>。</p>
<p data-nodeid="1286">要比较同步和异步，可以将调用函数的过程分成两部分：<strong data-nodeid="1413">执行操作和返回结果</strong>。</p>
<p data-nodeid="1287">程序在同步调用函数的时候，会<strong data-nodeid="1423">立即执行操作并等待得到返回结果后再继续运行</strong>，也就是说<strong data-nodeid="1424">同步执行是阻塞的</strong>。</p>
<p data-nodeid="1288">而异步会将操作和结果在时间上分隔开来，在当下执行操作，在未来某个时刻返回结果，在这个等待返回结果的过程中，程序将继续执行后面的代码。也就是说<strong data-nodeid="1430">异步执行是非阻塞的</strong>。</p>
<p data-nodeid="1289">再举个简单的例子来说明同步和异步。</p>
<p data-nodeid="1290">下面的代码定义了同步函数 syncAdd 和异步函数 asyncAdd，调用 syncAdd(1,2) 函数时会等待得到结果之后再执行后面的代码。而调用 asyncAdd(1,2,console.log) 时则会在得到结果之前继续执行，直到 1 秒后得到结果并打印。</p>
<pre class="lang-javascript" data-nodeid="1291"><code data-language="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">syncAdd</span>(<span class="hljs-params">a, b</span>) </span>&#123;
&nbsp; <span class="hljs-keyword">return</span> a + b;
&#125;
syncAdd(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) <span class="hljs-comment">// 立即得到结果 3</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">asyncAdd</span>(<span class="hljs-params">a, b, cb</span>) </span>&#123;
&nbsp; <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
&nbsp; &nbsp; cb(a + b);
&nbsp; &#125;, <span class="hljs-number">1000</span>)
&#125;
asyncAdd(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-built_in">console</span>.log) <span class="hljs-comment">// 1s后打印结果 3</span>
</code></pre>
<h4 data-nodeid="1292">异步与回调</h4>
<p data-nodeid="1293">如果你经常调用 JavaScript 的异步函数可能会形成一个结论：<strong data-nodeid="1439">异步操作都采用回调函数的形式</strong>。</p>
<p data-nodeid="1294">毕竟从浏览器端的 DOM 事件、AJAX 请求、定时器到 Node.js 端的文件读写、多进程，都是采用的回调形式。但事实真是如此吗？</p>
<p data-nodeid="1295">下面是一段简单的代码，定义了一个 JSON 对象 a，然后把它打印到控制台，最后再将对象 a 的 couter.index 属性值自增 1。</p>
<pre class="lang-javascript" data-nodeid="1296"><code data-language="javascript"><span class="hljs-keyword">var</span> a = &#123;
  <span class="hljs-attr">counter</span>: &#123;
    <span class="hljs-attr">index</span>: <span class="hljs-number">1</span>
  &#125;
&#125;;
<span class="hljs-built_in">console</span>.log( a ); <span class="hljs-comment">// ?</span>
a.counter.index++;
</code></pre>
<p data-nodeid="1297">如果你把上面的代码复制粘贴到浏览器控制台中运行，应该可以看到控制台打印了一个可能和你预期不一致的 JSON 对象：{conter:{index: 2}}。<br>
原因在于浏览器在运行代码的时候，把控制台打印这种涉及 I/O 的操作进行了延迟执行。可能你会猜想是不是控制台打印的只是将对象 a 进行了类似“浅拷贝”的操作，否定这种猜想很简单，此时再执行一次自增操作，就会发现被打印的对象值并没有发生变化。</p>
<p data-nodeid="1298">既然并非所有异步都回调，那么反过来，是否所有回调函数都是异步执行的呢？答案也是否定的。</p>
<p data-nodeid="1299">在上一课时中我们就提到过回调形式的同步函数，比如数组原型函数 forEach，又比如改变 this 指向的 call。</p>
<h3 data-nodeid="1300">异步原理</h3>
<p data-nodeid="1301">回顾了异步的基础概念，下面就来深入讲解异步的原理。</p>
<h4 data-nodeid="1302">事件循环</h4>
<p data-nodeid="1303">对于大多数语言而言，实现异步会通过启动额外的进程、线程或协程来实现，而我们在前面已经提到过，JavaScript 是单线程的。</p>
<p data-nodeid="1304"><strong data-nodeid="1455">为什么单线程还能实现异步呢</strong>？</p>
<p data-nodeid="1305">其实也没有什么特殊的黑魔法，只是把一些操作交给了其他线程处理，然后采用了一种称之为“<strong data-nodeid="1461">事件循环</strong>”（也称“事件轮询”）的机制来处理返回结果。</p>
<p data-nodeid="1306">下面用一段简化的代码，来帮助你快速地理解事件循环机制。</p>
<p data-nodeid="1307">数组 eventLoop 表示<strong data-nodeid="1468">事件队列</strong>（也有称作“任务队列”），用来存放需要执行的任务事件（可以理解为回调函数），对象 event 变量表示当前需要执行的任务事件。</p>
<p data-nodeid="1308">用一个永不停止的 while 循环来表示事件循环，每一次循环称为一个 tick。</p>
<p data-nodeid="1309">对每个 tick 而言，如果在队列中有等待事件，那么就会从队列中获取一个事件并执行，这些事件通常是回调函数的形式。</p>
<pre class="lang-javascript" data-nodeid="1310"><code data-language="javascript"><span class="hljs-keyword">var</span> eventLoop = []; <span class="hljs-comment">// 事件队列，先进先出</span>
<span class="hljs-keyword">var</span> event; <span class="hljs-comment">// 事件执行成功的回调回调函数</span>
<span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;
  <span class="hljs-comment">// 一次tick</span>
  <span class="hljs-keyword">if</span> (eventLoop.length &gt; <span class="hljs-number">0</span>) &#123;
    <span class="hljs-comment">// 队列中取出回调函数</span>
    event = eventLoop.shift();
    <span class="hljs-keyword">try</span> &#123;
      event();
    &#125; <span class="hljs-keyword">catch</span> (err) &#123;
      reportError(err);&nbsp;
    &#125;
  &#125;
&#125;
</code></pre>
<p data-nodeid="1311">那么这个事件队列里的事件是怎么来的呢？</p>
<p data-nodeid="1312">以 AJAX 请求为例，当我们发出一个 AJAX 请求时，浏览器会将请求任务分派给网络线程来进行处理，当对应的网络线程拿到返回的数据之后，就会把回调函数插入到事件队列中。</p>
<p data-nodeid="1313">setTimeout 和 setInterval 也是同样的道理，当我们执行 setTimeout 的时候并不是直接把回调函数放入事件队列中。它所做的是交给定时器线程来处理，当定时器到时后，再把回调函数放在事件队列中，这样，在未来的某轮 tick 中获取并执行这个回调函数。</p>
<p data-nodeid="1314">这么做有一个隐性的问题，如果事件队列中已经有其他事件，那么这个回调就会排队等待。</p>
<p data-nodeid="1315">所以说 setTimeout/setInterval 定时器的精度并不高。准确地说，它只能确保回调函数不会在指定的时间间隔之前运行，但可能会在那个时刻运行，也可能在那之后运行，这就要根据事件队列的状态而定。</p>
<h4 data-nodeid="1316">事件队列</h4>
<p data-nodeid="1317">在讲述 setTimeout/setInterval 原理的时候也暴露了事件队列的一个缺陷：<strong data-nodeid="1481">事件队列按照先进先出的顺序执行，那么如果队列较长时，排在后面的事件即使较为“紧急”，也得需要等待前面的任务先执行完成。</strong></p>
<p data-nodeid="1318">JavaScript 解决这个问题的思路就是：<strong data-nodeid="1487">设置多个队列，按照优先级来执行</strong>。</p>
<p data-nodeid="1319">下面这段代码可以验证 JavaScript 内部拥有优先级不同的 2 个队列，在下图中分别用绿色和红色表示，其中红色队列优先级高于绿色队列。</p>
<p data-nodeid="1320">这段代码定义了 4 个异步函数 f1、f2、f3、f4，其中：</p>
<ul data-nodeid="1321">
<li data-nodeid="1322">
<p data-nodeid="1323">函数 f1 通过定时器 setTimeout 向绿色队列中插入一个控制台打印任务，输出数字 1；</p>
</li>
<li data-nodeid="1324">
<p data-nodeid="1325">函数 f2 通过 Promise 向红色队列中插入一个控制台打印任务，输出数字 2；</p>
</li>
<li data-nodeid="1326">
<p data-nodeid="1327">函数 f3 通过定时器 setTimeout 向绿色队列中插入一个回调函数，该回调函数会调用控制台打印数字 3，并且调用函数 f2；</p>
</li>
<li data-nodeid="1328">
<p data-nodeid="1329">函数 f4 通过 Promise 向红色队列中插入一个回调函数，该回调函数会调用控制台打印数字 4，并且调用函数 f1。</p>
</li>
</ul>
<pre class="lang-javascript" data-nodeid="4016"><code data-language="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span>(<span class="hljs-params"></span>) </span>&#123;
&nbsp; <span class="hljs-built_in">setTimeout</span>(<span class="hljs-built_in">console</span>.log.bind(<span class="hljs-literal">null</span>,<span class="hljs-number">1</span>), <span class="hljs-number">0</span>)
&#125;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f2</span>(<span class="hljs-params"></span>) </span>&#123;
&nbsp; <span class="hljs-built_in">Promise</span>.resolve().then(<span class="hljs-built_in">console</span>.log.bind(<span class="hljs-literal">null</span>,<span class="hljs-number">2</span>))
&#125;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f3</span>(<span class="hljs-params"></span>) </span>&#123;
&nbsp; <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;
&nbsp; &nbsp; <span class="hljs-built_in">console</span>.log(<span class="hljs-number">3</span>)
&nbsp; &nbsp; f2()
&nbsp; &#125;, <span class="hljs-number">0</span>)
&#125;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f4</span>(<span class="hljs-params"></span>) </span>&#123;
&nbsp; <span class="hljs-built_in">Promise</span>.resolve().then(<span class="hljs-function">() =&gt;</span> &#123;
&nbsp; &nbsp; <span class="hljs-built_in">console</span>.log(<span class="hljs-number">4</span>)
&nbsp; &nbsp; f1()
&nbsp; &#125;
&#125;
f3()
f4()
</code></pre>
<p data-nodeid="4017">这段代码的执行过程和结果可以查看下图，当调用函数 f3 和函数 f4 之后，绿色队列和红色队列都会被插入一个匿名回调函数。</p>
<ul data-nodeid="4018">
<li data-nodeid="4019">
<p data-nodeid="4020">第 1 次 tick，由于红色队列优先级高，所以先执行红色匿名函数，控制台打印数字 4，然后调用函数 f1，向绿色队列中插入一个打印函数；</p>
</li>
<li data-nodeid="4021">
<p data-nodeid="4022">第 2 次 tick，按照先进先出原则，此时调用匿名函数打印数字 3，并调用函数 f2，向红色队列中插入一个打印函数；</p>
</li>
<li data-nodeid="4023">
<p data-nodeid="4024">第 3 次 tick，调用红色队列中的打印函数，控制台打印数字 2；</p>
</li>
<li data-nodeid="4025">
<p data-nodeid="4026">第 4 次 tick，调用绿色队列中的打印函数，控制台打印数字 1。</p>
</li>
</ul>
<p data-nodeid="4027"><img src="https://s0.lgstatic.com/i/image/M00/1F/41/CgqCHl7m1W-AUWjTAAGFy-O9UzA843.png" alt="image" data-nodeid="4081"></p>
<p data-nodeid="4028">关于红色队列和绿色队列，一般称为“<strong data-nodeid="4100">宏任务队列</strong>（Macro Task Queue）”和“<strong data-nodeid="4101">微任务队列</strong>（Micro Task Queue）”，也有的称为“Task Queue”和“Job Queue”。不管如何称呼，我们需要记住的是，<strong data-nodeid="4103">不同队列优先级不同，每次事件循环时会从优先级高的队列中获取事件，只有当优先级高的队列为空时才会从优先级<b><strong data-nodeid="4102">低</strong></b>的队列中获取事件，同级队列之间的事件不存在优先级，只遵循先进先出的原则。</strong></p>
<p data-nodeid="4029">常见的异步函数优先级如下，从上到下优先级逐层降低：</p>
<pre class="lang-java" data-nodeid="4030"><code data-language="java">process.nextTick(Node.js) &gt; 
MutationObserver(浏览器)/promise.then(<span class="hljs-keyword">catch</span>、finnally)&gt;
setImmediate(IE) &gt; 
setTimeout/setIntervalrequestAnimationFrame &gt;
其他 I/O 操作 / 浏览器 DOM 事件
</code></pre>
<h3 data-nodeid="4031">处理异步</h3>
<p data-nodeid="4032">由于回调函数这种形式的代码可读性非常差，所以在编写代码的时候要尽量将回调形式转化成返回 Promise 对象的形式，一方面由于 ES6 标准下提供了原生 Promise 对象及方法，另一方面 Promise 的可操作性也更强，比如可以配合 async/await 关键字使用，也可以转换成 <a target="_blank" rel="noopener" href="https://rxjs.dev/api/index/function/from" data-nodeid="4109">Observable</a> 对象。所以越来越多的第三方库异步函数都开始返回 Promise 对象。</p>
<p data-nodeid="4033">下面我们就以 Promise 形式的异步函数为例，讲解几个常见的异步场景。</p>
<h4 data-nodeid="4034">异步串行</h4>
<p data-nodeid="4035">将异步转化为串行执行是非常常见的操作，先通过一个简单的例子来回顾基本实现方式。</p>
<p data-nodeid="4036">考虑异步函数 asyncF1 和 asyncF2，且 asyncF2 依赖 asyncF1 的返回结果执行。使用 Promise 提供的 then 函数可以直接实现，伪代码如下：</p>
<pre class="lang-javascript" data-nodeid="4037"><code data-language="javascript">asyncF1()
.then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> asyncF2(data))
.then(<span class="hljs-function">() =&gt;</span> &#123;
  ...
&#125;)
.catch(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> <span class="hljs-built_in">console</span>.error(e))
</code></pre>
<p data-nodeid="4038">如果使用 async/await 可以摆脱链式调用，代码可读性更好：</p>
<pre class="lang-javascript" data-nodeid="4039"><code data-language="javascript">(<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-keyword">try</span> &#123;
    <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> asyncFn1()
    <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> asyncFn2(data)
    ...
  &#125; <span class="hljs-keyword">catch</span>(e) &#123;
    <span class="hljs-built_in">console</span>.error(e)
  &#125;
&#125;)()
</code></pre>
<p data-nodeid="4040">回顾完基础用法，来提升一下难度。假设现在要按照顺序执行调用 asyncF 函数 n 次，该怎么实现呢？</p>
<p data-nodeid="4041">对于这种场景可以通过数组函数 reduce 来实现，而不是简单地使用 for 循环或数组的 forEach 函数，比如像下面这样：</p>
<pre class="lang-javascript" data-nodeid="4042"><code data-language="javascript">[<span class="hljs-number">1.</span>..n].reduce(<span class="hljs-keyword">async</span> (lastPromise, i) =&gt; &#123;
&nbsp; <span class="hljs-keyword">try</span> &#123;
&nbsp; &nbsp; <span class="hljs-keyword">await</span> lastPromise
&nbsp; &nbsp; <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">await</span> asyncF())
&nbsp; &#125; <span class="hljs-keyword">catch</span>(e) &#123;
&nbsp; &nbsp; <span class="hljs-built_in">console</span>.error(e)
&nbsp; &#125;
&#125;, <span class="hljs-built_in">Promise</span>.resolve())
</code></pre>
<p data-nodeid="4043">再升级一下难度，通过一道笔试题来加深理解。</p>
<p data-nodeid="4044">现在需要延迟打印数组 [1,2,3,4,5]，每一次打印的初始延迟为 1000ms，增长延迟为 500ms。打印结果如下所示：</p>
<pre class="lang-javascript" data-nodeid="4045"><code data-language="javascript"><span class="hljs-number">0</span>s:    <span class="hljs-number">1</span>
<span class="hljs-number">1</span>s:    <span class="hljs-number">2</span>
<span class="hljs-number">2.5</span>s: <span class="hljs-number">3</span>
<span class="hljs-number">4.5</span>s: <span class="hljs-number">4</span>
<span class="hljs-number">7</span>s:    <span class="hljs-number">5</span>
</code></pre>
<p data-nodeid="4046">这道题也是将多个异步函数改为串行执行的典型例子，所以也可以通过 reduce 函数来实现。由于引入了递增的延迟执行，所以都需要得到上一次执行的延迟时间。具体代码如下：</p>
<pre class="lang-javascript" data-nodeid="4047"><code data-language="javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]
arr.reduce(<span class="hljs-keyword">async</span> (prs, cur, index) =&gt; &#123;
  <span class="hljs-keyword">const</span> t = <span class="hljs-keyword">await</span> prs
  <span class="hljs-keyword">const</span> time = index === <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : <span class="hljs-number">1000</span> + (index - <span class="hljs-number">1</span>) * <span class="hljs-number">500</span>
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;
      <span class="hljs-built_in">console</span>.log(cur);
      res(time)
    &#125;, time)
  &#125;)
&#125;, <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">0</span>))
</code></pre>
<h4 data-nodeid="4048">异步并行</h4>
<p data-nodeid="4049">并行也是异步常用的场景，重点掌握下面 3 个静态函数。</p>
<p data-nodeid="4050">（1）<strong data-nodeid="4135">Promise.all([promise1 ...... promiseN])</strong></p>
<p data-nodeid="4051">调用函数 Promise.all 会返回一个新的 Promise 实例，该实例在参数内所有的 promise 都完成 (resolved) 时回调完成 (resolve)；如果参数中&nbsp; promise 有一个失败（rejected），那么此实例返回第一个失败 promise 的结果。</p>
<p data-nodeid="4052">当执行的异步函数具有强一致性时可以使用它，比如要更新一个较大的表单数据，会发送多个请求分别更新不同的数据，如果一个请求更新失败则放弃本次提交。</p>
<p data-nodeid="4053">（2）<strong data-nodeid="4146">Promise.allSettled([promise1......promiseN])</strong></p>
<p data-nodeid="4054">调用函数 Promise.allsellted 会返回一个新的 Promise 实例，该实例会在所有给定的 promise 已经执行完成时返回一个对象数组，每个对象表示对应的 promise 结果。</p>
<p data-nodeid="4055">这个函数适用于需要并发执行多个异步函数，这些异步函数的执行结果相互独立。比如同时发送多个 AJAX 请求来分别更新多条数据。</p>
<p data-nodeid="4056">（3）<strong data-nodeid="4157">Promise.race([promise1......promiseN])</strong></p>
<p data-nodeid="4057">调用函数 Promise.race 会返回一个新的 promise 实例，一旦参数中的某个 promise 执行完成，新的 promise 实例就会返回对应 promise 的执行结果。</p>
<p data-nodeid="4058">这个函数会让多个并发函数产生“竞争”，从而挑选出最先执行完成的。比如尝试从多个网址加载图片资源。</p>
<h4 data-nodeid="4059">异常处理</h4>
<p data-nodeid="4060">Promise 有一个隐藏的“坑”，那就是内部的异常不能在外部通过 try/catch 所捕获，当内部发生异常时，会自动进入失败状态（rejected）。所以下面的代码是等价的：</p>
<pre class="lang-javascript" data-nodeid="4061"><code data-language="javascript"><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-number">0</span>) <span class="hljs-comment">// 等价于&nbsp; reject(new Error(0))&nbsp;</span>
&#125;)
</code></pre>
<p data-nodeid="4062">所以建议尽量使用 catch 子句而不是在 then 子句中捕获 Promise 异常，因为这样可以捕获 then 子句中的异常信息。</p>
<pre class="lang-javascript" data-nodeid="4063"><code data-language="javascript"><span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">1</span>)
.then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;
  <span class="hljs-keyword">const</span> arr = data.split(<span class="hljs-string">''</span>)
  <span class="hljs-comment">//...</span>
&#125;, <span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;  <span class="hljs-comment">// 这里捕获不到</span>
  <span class="hljs-comment">// ...</span>
&#125;)
<span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">1</span>)
.then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;
  <span class="hljs-keyword">const</span> arr = data.split(<span class="hljs-string">''</span>)
  <span class="hljs-comment">// ...</span>
&#125;)
.catch(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123; <span class="hljs-comment">// 这里可以捕获</span>
  <span class="hljs-comment">// ...</span>
&#125;)
</code></pre>
<h3 data-nodeid="4064">补充：Promise 的局限性</h3>
<p data-nodeid="4065">虽然 Promise 相对于回调具有明显的优势，但其仍然有一些局限性，至少有下面 2 个方面的问题。</p>
<h4 data-nodeid="4066">立即执行</h4>
<p data-nodeid="4067">当一个 Promise 实例被创建时，内部的代码就会立即被执行，而且无法从外部停止。比如无法取消超时或消耗性能的异步调用，容易导致资源的浪费。</p>
<h4 data-nodeid="4068">单次执行</h4>
<p data-nodeid="4069">Promise 处理的问题都是“一次性”的，因为一个 Promise 实例只能 resolve 或 reject 一次，所以面对某些需要持续响应的场景时就会变得力不从心。比如上传文件获取进度时，默认采用的就是通过事件监听的方式来实现。</p>
<p data-nodeid="4070">所以说 Promise 并不是万能的，全面了解其优缺点能帮助我们更好地使用 Promise。上述这些问题其实都有解决方案，比如使用 <a target="_blank" rel="noopener" href="https://rxjs.dev/" data-nodeid="4172">RxJS</a>，期待你在工作中多思考、多积累，找到更多更好的解决方案。</p>
<h3 data-nodeid="4071">总结</h3>
<p data-nodeid="4072">这一课时涉及了 JavaScript 的核心特性——异步，先从异步概念说起，然后深入异步原理讲述了事件循环和事件队列，最后列举了 3 个常见异步场景的处理方法。异步属于笔试题必考的考点，比如任务队列部分，将 setTimeout/Promise/nextTick 这些异步函数和对象进行任意组合即可出题，所以一定要理解原理。</p>
<p data-nodeid="4073">最后布置一道思考题：尝试使用 <a target="_blank" rel="noopener" href="https://rxjs.dev/" data-nodeid="4179">RxJS</a> 实现多个 Promise 的串行和并行，并说说它在处理异步方面的优缺点。</p>

<hr>
<h3 id="精选评论"><a href="#精选评论" class="headerlink" title="精选评论"></a>精选评论</h3><h5 id="郎："><a href="#郎：" class="headerlink" title="**郎："></a>**郎：</h5><blockquote>
<p>老师，你说js是单线程，异步用的方法又是轮询交给其他线程，这也算多线程么？只不过js的主线工作体现单线程</p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-讲师回复："><a href="#amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; 是的，同学你的理解是对的</p>
</blockquote>
<h5 id="锋："><a href="#锋：" class="headerlink" title="**锋："></a>**锋：</h5><blockquote>
<p>老师，事件队列那里的函数打印出来为什么是4 ，3 ，2 undefined ，1。这个undefined怎么回事呢。</p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-1"><a href="#amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-1" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; 这是因为你在控制台执行了函数没有返回值，所以打印出 undefined</p>
</blockquote>
<h5 id="荣："><a href="#荣：" class="headerlink" title="**荣："></a>**荣：</h5><blockquote>
<p>开发三年了，重新来学学基础，老师讲的不错，没有废话，迫不及待后面章节快点出来！！</p>
</blockquote>
<h5 id="松："><a href="#松：" class="headerlink" title="*松："></a>*松：</h5><blockquote>
<p>console就是同步吧，只是浏览器把打印对象中需要展开的做了延迟加载，展开的时候才加载</p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-2"><a href="#amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-2" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; 控制台会同步接收到对象的引用，同时打印出对象引用。只有点击展开时才会计算并显示对象当时的属性值，这是一个异步延迟操作。</p>
</blockquote>
<h5 id="学："><a href="#学：" class="headerlink" title="**学："></a>**学：</h5><blockquote>
<p>var a &#x3D; { counter: { index: 1 }};console.log( a ); &#x2F;&#x2F;{conter:{index: 2}}console.log( a.counter.index ); &#x2F;&#x2F; 1 老师，此处为啥是1？求解释。a.counter.index++;</p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-3"><a href="#amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-3" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; 对于基础类型的数据，浏览器直接在控制台进行了打印，没有通过异步实现。</p>
</blockquote>
<h5 id="levin："><a href="#levin：" class="headerlink" title="levin："></a>levin：</h5><blockquote>
<p>while无限循环事件队列是js主线程中的吗</p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-4"><a href="#amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-4" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; 嗯，是的</p>
</blockquote>
<h5 id="银："><a href="#银：" class="headerlink" title="**银："></a>**银：</h5><blockquote>
<p>老师，我能把这些课程文章弄到自己博客上面去吗，😁</p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-编辑回复："><a href="#amp-nbsp-amp-nbsp-amp-nbsp-编辑回复：" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 编辑回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 编辑回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; 不可以喔，复制到其他网站属于侵权，如果想分享，可分享拉勾专栏链接。</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/11/02/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BB%A3%E7%A0%81%E6%B2%A1%E6%9C%89%E6%8C%89%E7%85%A7%E7%BC%96%E5%86%99%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C%EF%BC%9F/" data-id="claxeer9v000pv8w1h52b51ju" data-title="为什么代码没有按照编写顺序执行？" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-为什么说函数是-JavaScript-的一等公民？" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/11/02/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4%E5%87%BD%E6%95%B0%E6%98%AF-JavaScript-%E7%9A%84%E4%B8%80%E7%AD%89%E5%85%AC%E6%B0%91%EF%BC%9F/" class="article-date">
  <time class="dt-published" datetime="2022-11-02T03:01:20.000Z" itemprop="datePublished">2022-11-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/11/02/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4%E5%87%BD%E6%95%B0%E6%98%AF-JavaScript-%E7%9A%84%E4%B8%80%E7%AD%89%E5%85%AC%E6%B0%91%EF%BC%9F/">为什么说函数是 JavaScript 的一等公民？</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p data-nodeid="1361" class=""><strong data-nodeid="1526">数据类型与函数是很多高级语言中最重要的两个概念</strong>，前者用来存储数据，后者用来存储代码。JavaScript 中的函数相对于数据类型而言更加复杂，它可以有属性，也可以被赋值给一个变量，还可以作为参数被传递......正是这些强大特性让它成了 JavaScript 的“一等公民”。</p>
<p data-nodeid="1362">下面我们就来详细了解函数的重要特性。</p>
<h3 data-nodeid="1363">this 关键字</h3>
<p data-nodeid="1364">什么是 this？this 是 JavaScript 的一个关键字，一般指向<strong data-nodeid="1534">调用它的对象</strong>。</p>
<p data-nodeid="1365">这句话其实有两层意思，首先 this 指向的应该是一个对象，更具体地说是函数执行的“上下文对象”。其次这个对象指向的是“调用它”的对象，如果调用它的不是对象或对象不存在，则会指向全局对象（严格模式下为 undefined）。</p>
<p data-nodeid="1366">下面举几个例子来进行说明。</p>
<ul data-nodeid="1367">
<li data-nodeid="1368">
<p data-nodeid="1369">当代码 1 执行 fn() 函数时，实际上就是通过对象 o 来调用的，所以 this 指向对象 o。</p>
</li>
<li data-nodeid="1370">
<p data-nodeid="1371">代码 2 也是同样的道理，通过实例 a 来调用，this 指向类实例 a。</p>
</li>
<li data-nodeid="1372">
<p data-nodeid="1373">代码 3 则可以看成是通过全局对象来调用，this 会指向全局对象（需要注意的是，严格模式下会是 undefined）。</p>
</li>
</ul>
<pre class="lang-javascript" data-nodeid="1374"><code data-language="javascript"><span class="hljs-comment">// 代码 1</span>
<span class="hljs-keyword">var</span> o = &#123;
  fn() &#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>)
  &#125;
&#125;
o.fn() <span class="hljs-comment">// o</span>
<span class="hljs-comment">// 代码 2</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;
  fn() &#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>)
  &#125;
&#125;
<span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> A() 
a.fn()<span class="hljs-comment">// a</span>
<span class="hljs-comment">// 代码 3</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>)
&#125;
fn() <span class="hljs-comment">// 浏览器：Window；Node.js：global</span>
</code></pre>
<p data-nodeid="1375">是不是觉得 this 的用法很简单？别着急，我们再来看看其他例子以加深理解。</p>
<p data-nodeid="1376">（1）如果在函数 fn2() 中调用函数 fn()，那么当调用函数 fn2() 的时候，函数 fn() 的 this 指向哪里呢？</p>
<pre class="lang-javascript" data-nodeid="1377"><code data-language="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>)&#125;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn2</span>(<span class="hljs-params"></span>) </span>&#123;fn()&#125;
fn2() <span class="hljs-comment">// ?</span>
</code></pre>
<p data-nodeid="1378"><strong data-nodeid="1546">由于没有找到调用 fn 的对象，所以 this 会指向全局对象</strong>，答案就是 window（Node.js 下是 global）。</p>
<p data-nodeid="1379">（2）再把这段代码稍稍改变一下，让函数 fn2() 作为对象 obj 的属性，通过 obj 属性来调用 fn2，此时函数 fn() 的 this 指向哪里呢？</p>
<pre class="lang-javascript" data-nodeid="1380"><code data-language="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>)&#125;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn2</span>(<span class="hljs-params"></span>) </span>&#123;fn()&#125;
<span class="hljs-keyword">var</span> obj = &#123;fn2&#125;
obj.fn2() <span class="hljs-comment">// ?</span>
</code></pre>
<p data-nodeid="1381">这里需要注意，调用函数 fn() 的是函数 fn2() 而不是 obj。虽然 fn2() 作为 obj 的属性调用，但 <strong data-nodeid="1555">fn2()中的 this 指向并不会传递给函数 fn()，</strong> 所以答案也是 window（Node.js 下是 global）。<br>
（3）对象 dx 拥有数组属性 arr，在属性 arr 的 forEach 回调函数中输出 this，指向的是什么呢？</p>
<pre class="lang-javascript" data-nodeid="1382"><code data-language="javascript"><span class="hljs-keyword">var</span> dx = &#123;
  <span class="hljs-attr">arr</span>: [<span class="hljs-number">1</span>]
&#125;
dx.arr.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>)&#125;) <span class="hljs-comment">// ?</span>
</code></pre>
<p data-nodeid="1383">按照之前的说法，很多同学可能会觉得输出的应该是对象 dx 的属性 arr 数组。但其实仍然是全局对象。</p>
<p data-nodeid="1384">如果你看过 forEach 的说明文档便会知道，它有两个参数，第一个是回调函数，第二个是 this 指向的对象，这里只传入了回调函数，第二个参数没有传入，默认为 undefined，所以正确答案应该是输出全局对象。</p>
<p data-nodeid="1385">类似的，需要传入 this 指向的函数还有：every()、find()、findIndex()、map()、some()，在使用的时候需要特别注意。</p>
<p data-nodeid="1386">（4）前面提到通过类实例来调用函数时，this 会指向实例。那么如果像下面的代码，创建一个 fun 变量来引用实例 b 的 fn() 函数，当调用 fun() 的时候 this 会指向什么呢？</p>
<pre class="lang-javascript" data-nodeid="1387"><code data-language="javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> </span>&#123;
  fn() &#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>)
  &#125;
&#125;
<span class="hljs-keyword">var</span> b = <span class="hljs-keyword">new</span> B()
<span class="hljs-keyword">var</span> fun = b.fn
fun() <span class="hljs-comment">// ?</span>
</code></pre>
<p data-nodeid="1388">这道题你可能会很容易回答出来：fun 是在全局下调用的，所以 this 应该指向的是全局对象。这个思路没有没问题，但是这里有个隐藏的知识点。那就是 ES6 下的 class 内部默认采用的是严格模式，实际上面代码的类定义部分可以理解为下面的形式。</p>
<pre class="lang-javascript" data-nodeid="1389"><code data-language="javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> </span>&#123;
<span class="hljs-meta">  'use strict'</span>;
  fn() &#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>)
  &#125;
&#125;
</code></pre>
<p data-nodeid="1390">而严格模式下不会指定全局对象为默认调用对象，所以答案是 undefined。</p>
<p data-nodeid="1391">（5）ES6 新加入的箭头函数不会创建自己的 this，它只会从自己的作用域链的上一层继承 this。可以简单地理解为<strong data-nodeid="1567">箭头函数的 this 继承自上层的 this</strong>，但在全局环境下定义仍会指向全局对象。</p>
<pre class="lang-javascript" data-nodeid="1392"><code data-language="javascript"><span class="hljs-keyword">var</span> arrow = &#123;<span class="hljs-attr">fn</span>: <span class="hljs-function">() =&gt;</span> &#123;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>)
&#125;&#125;
arrow.fn() <span class="hljs-comment">// ?</span>
</code></pre>
<p data-nodeid="1393">所以虽然通过对象 arrow 来调用箭头函数 fn()，那么 this 指向不是 arrow 对象，而是全局对象。如果要让 fn() 箭头函数指向 arrow 对象，我们还需要再加一层函数，让箭头函数的上层 this 指向 arrow 对象。</p>
<pre class="lang-javascript" data-nodeid="1394"><code data-language="javascript"><span class="hljs-keyword">var</span> arrow = &#123;
  fn() &#123;
  &nbsp; <span class="hljs-keyword">const</span> a = <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>)
&nbsp;   a()
  &#125;
&#125;
arrow.fn()  <span class="hljs-comment">// arrow</span>
</code></pre>
<p data-nodeid="1395">（6）前面提到 this 指向的要么是调用它的对象，要么是 undefined，那么如果将 this 指向一个基础类型的数据会发生什么呢？</p>
<p data-nodeid="1396">比如下面的代码将 this 指向数字 0，打印出的 this 是什么呢？</p>
<pre class="lang-javascript" data-nodeid="1397"><code data-language="javascript">[<span class="hljs-number">0</span>].forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>)&#125;, <span class="hljs-number">0</span>) <span class="hljs-comment">// ?</span>
</code></pre>
<p data-nodeid="1398">结合上一讲关于数据类型的知识，我们知道基础类型也可以转换成对应的引用对象。所以这里 this 指向的是一个值为 0 的 Number 类型对象。</p>
<p data-nodeid="1399">（7）改变 this 指向的常见 3 种方式有 bind、call 和 apply。call 和 apply 用法功能基本类似，都是通过传入 this 指向的对象以及参数来调用函数。区别在于传参方式，前者为逐个参数传递，后者将参数放入一个数组，以数组的形式传递。bind 有些特殊，它不但可以绑定 this 指向也可以绑定函数参数并返回一个新的函数，当 c 调用新的函数时，绑定之后的 this 或参数将无法再被改变。</p>
<pre class="lang-javascript" data-nodeid="1400"><code data-language="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getName</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name)&#125;
<span class="hljs-keyword">var</span> b = getName.bind(&#123;<span class="hljs-attr">name</span>: <span class="hljs-string">'bind'</span>&#125;)
b()
getName.call(&#123;<span class="hljs-attr">name</span>: <span class="hljs-string">'call'</span>&#125;)
getName.apply(&#123;<span class="hljs-attr">name</span>: <span class="hljs-string">'apply'</span>&#125;)
</code></pre>
<p data-nodeid="1401">由于 this 指向的不确定性，所以很容易在调用时发生意想不到的情况。在编写代码时，应尽量避免使用 this，比如可以写成纯函数的形式，也可以通过参数来传递上下文对象。实在要使用 this 的话，可以考虑使用 bind 等方式将其绑定。</p>
<h3 data-nodeid="1402">补充 1：箭头函数</h3>
<p data-nodeid="1403">箭头函数和普通函数相比，有以下几个区别，在开发中应特别注意：</p>
<ul data-nodeid="1404">
<li data-nodeid="1405">
<p data-nodeid="1406">不绑定 arguments 对象，也就是说在箭头函数内访问 arguments 对象会报错；</p>
</li>
<li data-nodeid="1407">
<p data-nodeid="1408">不能用作构造器，也就是说不能通过关键字 new 来创建实例；</p>
</li>
<li data-nodeid="1409">
<p data-nodeid="1410">默认不会创建 prototype 原型属性；</p>
</li>
<li data-nodeid="1411">
<p data-nodeid="1412">不能用作 Generator() 函数，不能使用 yeild 关键字。</p>
</li>
</ul>
<h3 data-nodeid="1413">函数的转换</h3>
<p data-nodeid="1414">在讲函数转化之前，先来看一道题：编写一个 add() 函数，支持对多个参数求和以及多次调用求和。示例如下：</p>
<pre class="lang-javascript" data-nodeid="1415"><code data-language="javascript">add(<span class="hljs-number">1</span>) <span class="hljs-comment">// 1</span>
add(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>)<span class="hljs-comment">// 3</span>
add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)(<span class="hljs-number">6</span>) <span class="hljs-comment">// 21</span>
</code></pre>
<p data-nodeid="1416">对于不定参数的求和处理比较简单，很容易想到通过 arguments 或者扩展符的方式获取数组形式的参数，然后通过 reduce 累加求和。但如果直接返回结果那么后面的调用肯定会报错，所以每次返回的必须是函数，才能保证可以连续调用。也就是说 add 返回值既是一个可调用的函数又是求和的数值结果。</p>
<p data-nodeid="1417">要实现这个要求，我们必须知道函数相关的两个隐式转换函数 toString() 和 valueOf()。toString() 函数会在打印函数的时候调用，比如 console.log、valueOf 会在获取函数原始值时调用，比如加法操作。</p>
<p data-nodeid="1418">具体代码实现如下，在 add() 函数内部定义一个 fn() 函数并返回。fn() 函数的主要职能就是拼接参数并返回自身，当调用 toString() 和 valueOf() 函数时对拼接好的参数进行累加求和并返回。</p>
<pre class="lang-javascript" data-nodeid="3063"><code data-language="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">...args</span>) </span>&#123;
&nbsp; <span class="hljs-keyword">let</span> arr = args
&nbsp; <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params">...newArgs</span>) </span>&#123;
&nbsp; &nbsp; arr = [...arr, ...newArgs]
&nbsp; &nbsp; <span class="hljs-keyword">return</span> fn;
&nbsp; &#125;
&nbsp; fn.toString = fn.valueOf = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
&nbsp; &nbsp; <span class="hljs-keyword">return</span> arr.reduce(<span class="hljs-function">(<span class="hljs-params">acc, cur</span>) =&gt;</span> acc + <span class="hljs-built_in">parseInt</span>(cur))
&nbsp; &#125;
&nbsp; <span class="hljs-keyword">return</span> fn
&#125;
</code></pre>



<h3 data-nodeid="1420">原型</h3>
<p data-nodeid="1421">原型是 JavaScript 的重要特性之一，可以让对象从其他对象继承功能特性，所以 JavaScript 也被称为“<strong data-nodeid="1591">基于原型的语言</strong>”。</p>
<p data-nodeid="1422">严格地说，原型应该是对象的特性，但函数其实也是一种特殊的对象。例如，我们对自定义的函数进行 instanceof Object 操作时，其结果是 true。</p>
<pre class="lang-javascript" data-nodeid="1423"><code data-language="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>)</span>&#123;&#125; 
fn <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Object</span> <span class="hljs-comment">// true</span>
</code></pre>
<p data-nodeid="1424">而且我们为了实现类的特性，更多的是在函数中使用它，所以在函数这一课时中来深入讲解原型。</p>
<h4 data-nodeid="1425">什么是原型和原型链？</h4>
<p data-nodeid="1426">简单地理解，原型就是对象的属性，包括<strong data-nodeid="1605">被称为隐式原型的 <strong data-nodeid="1604">proto</strong> 属性和被称为显式原型的 prototype 属性</strong>。</p>
<p data-nodeid="1427">隐式原型通常在创建实例的时候就会自动指向构造函数的显式原型。例如，在下面的示例代码中，当创建对象 a 时，a 的隐式原型会指向构造函数 Object() 的显式原型。</p>
<pre class="lang-javascript" data-nodeid="1428"><code data-language="javascript"><span class="hljs-keyword">var</span> a = &#123;&#125;
a.__proto__ === <span class="hljs-built_in">Object</span>.prototype <span class="hljs-comment">// true</span>
<span class="hljs-keyword">var</span> b= <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>()
b.__proto__ === a.__proto__ <span class="hljs-comment">// true</span>
</code></pre>
<p data-nodeid="1429">显式原型是内置函数（比如 Date() 函数）的默认属性，在自定义函数时（箭头函数除外）也会默认生成，生成的显式原型对象只有一个属性 constructor ，该属性指向函数自身。通常配合 new 关键字一起使用，当通过 new 关键字创建函数实例时，会将实例的隐式原型指向构造函数的显式原型。</p>
<pre class="lang-javascript" data-nodeid="1430"><code data-language="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>&#123;&#125; 
fn.prototype.constructor === fn <span class="hljs-comment">// true</span>
</code></pre>
<p data-nodeid="1431">看到这里，不少同学可能会产生一种错觉，那就是隐式原型必须和显式原型配合使用，这种想法是错误的。</p>
<p data-nodeid="1432">下面的代码声明了 parent 和 child 两个对象，其中对象 child 定义了属性 name 和隐式原型 <strong data-nodeid="1614">proto</strong>，隐式原型指向对象 parent，对象 parent 定义了 code 和 name 两个属性。</p>
<p data-nodeid="1433">当打印 child.name 的时候会输出对象 child 的 name 属性值，当打印 child.code 时由于对象 child 没有属性 code，所以会找到原型对象 parent 的属性 code，将 parent.code 的值打印出来。同时可以通过打印结果看到，对象 parent 并没有显式原型属性。如果要区分对象 child 的属性是否继承自原型对象，可以通过 hasOwnProperty() 函数来判断。</p>
<pre class="lang-javascript" data-nodeid="1434"><code data-language="javascript"><span class="hljs-keyword">var</span> parent = &#123;<span class="hljs-attr">code</span>:<span class="hljs-string">'p'</span>,<span class="hljs-attr">name</span>:<span class="hljs-string">'parent'</span>&#125;
<span class="hljs-keyword">var</span> child = &#123;<span class="hljs-attr">__proto__</span>: parent, <span class="hljs-attr">name</span>: <span class="hljs-string">'child'</span>&#125;
<span class="hljs-built_in">console</span>.log(parent.prototype) <span class="hljs-comment">// undefined</span>
<span class="hljs-built_in">console</span>.log(child.name) <span class="hljs-comment">// "child"</span>
<span class="hljs-built_in">console</span>.log(child.code) <span class="hljs-comment">// "p"</span>
child.hasOwnProperty(<span class="hljs-string">'name'</span>) <span class="hljs-comment">// true</span>
child.hasOwnProperty(<span class="hljs-string">'code'</span>) <span class="hljs-comment">// false</span>
</code></pre>
<p data-nodeid="1435">在这个例子中，如果对象 parent 也没有属性 code，那么会继续在对象 parent 的原型对象中寻找属性 code，以此类推，逐个原型对象依次进行查找，直到找到属性 code 或原型对象没有指向时停止。</p>
<p data-nodeid="1436">这种类似递归的链式查找机制被称作“原型链”。</p>
<h4 data-nodeid="1437">new 操作符实现了什么？</h4>
<p data-nodeid="1438">前面提到显式原型对象在使用 new 关键字的时候会被自动创建。现在再来具体分析通过 new 关键字创建函数实例时到底发生了什么。</p>
<p data-nodeid="1439">下面的代码通过 new 关键字创建了一个函数 F() 的实例。</p>
<pre class="lang-javascript" data-nodeid="1440"><code data-language="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">F</span>(<span class="hljs-params">init</span>) </span>&#123;&#125;
<span class="hljs-keyword">var</span> f = <span class="hljs-keyword">new</span> F(args)
</code></pre>
<p data-nodeid="1441">其中主要包含了 3 个步骤：</p>
<ol data-nodeid="1442">
<li data-nodeid="1443">
<p data-nodeid="1444">创建一个临时的空对象，为了表述方便，我们命名为 fn，让对象 fn 的隐式原型指向函数 F 的显式原型；</p>
</li>
<li data-nodeid="1445">
<p data-nodeid="1446">执行函数 F()，将 this 指向对象 fn，并传入参数 args，得到执行结果 result；</p>
</li>
<li data-nodeid="1447">
<p data-nodeid="1448">判断上一步的执行结果 result，如果 result 为非空对象，则返回 result，否则返回 fn。</p>
</li>
</ol>
<p data-nodeid="1449">具体可以表述为下面的代码：</p>
<pre class="lang-javascript" data-nodeid="1450"><code data-language="javascript"><span class="hljs-keyword">var</span> fn = <span class="hljs-built_in">Object</span>.create(F.prototype)
<span class="hljs-keyword">var</span> obj = F.apply(fn, args)
<span class="hljs-keyword">var</span> f = obj &amp;&amp; <span class="hljs-keyword">typeof</span> obj === <span class="hljs-string">'object'</span> ? obj : fn;
</code></pre>
<h4 data-nodeid="1451">怎么通过原型链实现多层继承？</h4>
<p data-nodeid="1452">结合原型链和 new 操作符的相关知识，就可以实现多层继承特性了。下面通过一个简单的例子进行说明。</p>
<p data-nodeid="1453">假设构造函数 B() 需要继承构造函数 A()，就可以通过将函数 B() 的显式原型指向一个函数 A() 的实例，然后再对 B 的显式原型进行扩展。那么通过函数 B() 创建的实例，既能访问用函数 B() 的属性 b，也能访问函数 A() 的属性 a，从而实现了多层继承。</p>
<pre class="lang-javascript" data-nodeid="1454"><code data-language="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">A</span>(<span class="hljs-params"></span>) </span>&#123;
&#125;
A.prototype.a = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
&nbsp; <span class="hljs-keyword">return</span> <span class="hljs-string">'a'</span>;
&#125;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">B</span>(<span class="hljs-params"></span>) </span>&#123;
&#125;
B.prototype = <span class="hljs-keyword">new</span> A()
B.prototype.b = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
&nbsp; <span class="hljs-keyword">return</span> <span class="hljs-string">'b'</span>;
&#125;
<span class="hljs-keyword">var</span> c = <span class="hljs-keyword">new</span> B()
c.b() <span class="hljs-comment">// 'b'</span>
c.a() <span class="hljs-comment">// 'a'</span>
</code></pre>
<h3 data-nodeid="1455">补充 2：typeof 和 instanceof</h3>
<p data-nodeid="1456"><strong data-nodeid="1633">typeof</strong></p>
<p data-nodeid="1457">用来获取一个值的类型，可能的结果有下面几种：</p>
<table data-nodeid="1459">
<thead data-nodeid="1460">
<tr data-nodeid="1461">
<th data-org-content="类型" data-nodeid="1463">类型</th>
<th data-org-content="结果" data-nodeid="1464">结果</th>
</tr>
</thead>
<tbody data-nodeid="1467">
<tr data-nodeid="1468">
<td data-org-content="Undefined" data-nodeid="1469">Undefined</td>
<td data-org-content="&quot;undefined&quot;" data-nodeid="1470">"undefined"</td>
</tr>
<tr data-nodeid="1471">
<td data-org-content="Boolean" data-nodeid="1472">Boolean</td>
<td data-org-content="&quot;boolean&quot;" data-nodeid="1473">"boolean"</td>
</tr>
<tr data-nodeid="1474">
<td data-org-content="Number" data-nodeid="1475">Number</td>
<td data-org-content="&quot;number&quot;" data-nodeid="1476">"number"</td>
</tr>
<tr data-nodeid="1477">
<td data-org-content="BigInt" data-nodeid="1478">BigInt</td>
<td data-org-content="&quot;bigint&quot;" data-nodeid="1479">"bigint"</td>
</tr>
<tr data-nodeid="1480">
<td data-org-content="String" data-nodeid="1481">String</td>
<td data-org-content="&quot;string&quot;" data-nodeid="1482">"string"</td>
</tr>
<tr data-nodeid="1483">
<td data-org-content="Symbol" data-nodeid="1484">Symbol</td>
<td data-org-content="&quot;symbol&quot;" data-nodeid="1485">"symbol"</td>
</tr>
<tr data-nodeid="1486">
<td data-org-content="函数对象" data-nodeid="1487">函数对象</td>
<td data-org-content="&quot;function&quot;" data-nodeid="1488">"function"</td>
</tr>
<tr data-nodeid="1489">
<td data-org-content="其他对象及 null" data-nodeid="1490">其他对象及 null</td>
<td data-org-content="&quot;object&quot;" data-nodeid="1491">"object"</td>
</tr>
</tbody>
</table>
<p data-nodeid="1492"><strong data-nodeid="1672">instanceof</strong></p>
<p data-nodeid="1493">用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上。例如，在表达式 left instanceof right 中，会沿着 left 的原型链查找，看看是否存在 right 的 prototype 对象。</p>
<pre class="lang-javascript" data-nodeid="1494"><code data-language="javascript">left.__proto__.__proto__... =?= right.prototype
</code></pre>
<h3 data-nodeid="1495">作用域</h3>
<p data-nodeid="1496">作用域是指赋值、取值操作的执行范围，通过作用域机制可以有效地防止变量、函数的重复定义，以及控制它们的可访问性。</p>
<p data-nodeid="1497">虽然在浏览器端和 Node.js 端作用域的处理有所不同，比如对于全局作用域，浏览器会自动将未主动声明的变量提升到全局作用域，而 Node.js 则需要显式的挂载到 global 对象上。又比如在 ES6 之前，浏览器不提供模块级别的作用域，而 Node.js 的 CommonJS 模块机制就提供了模块级别的作用域。但在类型上，可以分为全局作用域（window/global）、块级作用域（let、const、try/catch）、模块作用域（ES6 Module、CommonJS）及本课时重点讨论的函数作用域。</p>
<h4 data-nodeid="1498">命名提升</h4>
<p data-nodeid="1499">对于使用 var 关键字声明的变量以及创建命名函数的时候，JavaScript 在解释执行的时候都会将其声明内容提升到作用域顶部，这种机制称为“<strong data-nodeid="1683">命名提升</strong>”。</p>
<p data-nodeid="1500">变量的命名提升允许我们在同（子）级作用域中，在变量声明之前进行引用，但要注意，得到的是未赋值的变量。而且仅限 var 关键字声明的变量，对于 let 和 const 在定义之前引用会报错。</p>
<pre class="lang-javascript" data-nodeid="1501"><code data-language="javascript"><span class="hljs-built_in">console</span>.log(a) <span class="hljs-comment">// undefined</span>
<span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>
<span class="hljs-built_in">console</span>.log(b) <span class="hljs-comment">// 报错</span>
<span class="hljs-keyword">let</span> b = <span class="hljs-number">2</span>
</code></pre>
<p data-nodeid="1502">函数的命名提升则意味着可以在同级作用域或者子级作用域里，在函数定义之前进行调用。</p>
<pre class="lang-javascript" data-nodeid="1503"><code data-language="javascript">fn() <span class="hljs-comment">// 2</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>
&#125;
</code></pre>
<p data-nodeid="1504">结合以上两点我们再来看看下面两种函数定义的区别，方式 1 将函数赋值给变量 f；方式 2 定义了一个函数 f()。</p>
<pre class="lang-javascript" data-nodeid="1505"><code data-language="javascript"><span class="hljs-comment">// 方式1</span>
<span class="hljs-keyword">var</span> f = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;...&#125;
<span class="hljs-comment">// 方式2</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;...&#125;
</code></pre>
<p data-nodeid="1506">两种方式对于调用函数方式以及返回结果而言是没有区别的，但根据命名提升的规则，我们可以得知方式 1 创建了一个匿名函数，让变量 f 指向它，这里会发生变量的命名提升；如果我们在定义函数之前调用会报错，而方式 2 则不会。</p>
<h4 data-nodeid="1507">闭包</h4>
<p data-nodeid="1508">在函数内部访问外部函数作用域时就会产生闭包。闭包很有用，因为它允许将函数与其所操作的某些数据（环境）关联起来。这种关联不只是跨作用域引用，也可以实现数据与函数的隔离。</p>
<p data-nodeid="1509">比如下面的代码就通过闭包来实现单例模式。</p>
<pre class="lang-javascript" data-nodeid="1510"><code data-language="javascript"><span class="hljs-keyword">var</span> SingleStudent = (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&nbsp;
&nbsp; &nbsp; <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Student</span>(<span class="hljs-params"></span>) </span>&#123;&#125;
&nbsp; &nbsp; <span class="hljs-keyword">var</span> _student;&nbsp;
&nbsp; &nbsp; <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">if</span> (_student) <span class="hljs-keyword">return</span> _student;
&nbsp; &nbsp; &nbsp; &nbsp; _student = <span class="hljs-keyword">new</span> Student()
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">return</span> _student;
&nbsp; &nbsp; &#125;
&#125;())
<span class="hljs-keyword">var</span> s = <span class="hljs-keyword">new</span> SingleStudent()
<span class="hljs-keyword">var</span> s2 = <span class="hljs-keyword">new</span> SingleStudent()
s === s2 <span class="hljs-comment">// true</span>
</code></pre>
<p data-nodeid="1511">函数 SingleStudent 内部通过闭包创建了一个私有变量 _student，这个变量只能通过返回的匿名函数来访问，匿名函数在返回变量时对其进行判断，如果存在则直接返回，不存在则在创建保存后返回。</p>
<h3 data-nodeid="1512">补充 3：经典笔试题</h3>
<pre class="lang-javascript" data-nodeid="1513"><code data-language="javascript"><span class="hljs-keyword">for</span>( <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++ ) &#123;
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;
        <span class="hljs-built_in">console</span>.log( i );
    &#125;, <span class="hljs-number">1000</span> * i)
&#125;
</code></pre>
<p data-nodeid="1514">这是一道作用域相关的经典笔试题，需要实现的功能是每隔 1 秒控制台打印数字 0 到 4。但实际执行效果是每隔一秒打印的数字都是 5，为什么会这样呢？</p>
<p data-nodeid="1515">如果把这段代码转换一下，手动对变量 i 进行命名提升，你就会发现 for 循环和打印函数共享了同一个变量 i，这就是问题所在。</p>
<pre class="lang-javascript" data-nodeid="1516"><code data-language="javascript"><span class="hljs-keyword">var</span> i;
<span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++ ) &#123;
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;
        <span class="hljs-built_in">console</span>.log(i);
    &#125;, <span class="hljs-number">1000</span> * i)
&#125;
</code></pre>
<p data-nodeid="1517">要修复这段代码方法也有很多，比如将 var 关键字替换成 let，从而创建块级作用域。</p>
<pre class="lang-javascript" data-nodeid="1518"><code data-language="javascript"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++ ) &#123;
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;
        <span class="hljs-built_in">console</span>.log(i);
    &#125;, <span class="hljs-number">1000</span> * i)
&#125;
<span class="hljs-comment">/**
等价于
for(var i = 0; i &lt; 5; i++ ) &#123;
    let _i = i
    setTimeout(() =&gt; &#123;
        console.log(_i);
    &#125;, 1000 * i)
&#125;
 */</span>
</code></pre>
<h3 data-nodeid="1519">总结</h3>
<p data-nodeid="1520">本课时介绍了函数相关的重要内容，包括 this 关键字的指向、原型与原型链的使用、函数的隐式转换、函数和作用域的关系，希望大家能理解并记忆。</p>
<p data-nodeid="1521" class="">最后布置一道思考题：结合本课时的内容，思考一下修改函数的 this 指向，到底有多少种方式呢？</p>

<hr>
<h3 id="精选评论"><a href="#精选评论" class="headerlink" title="精选评论"></a>精选评论</h3><h5 id="Warn："><a href="#Warn：" class="headerlink" title="Warn："></a>Warn：</h5><blockquote>
<p>this指向、原型链这些真的是概念一看都懂，看完又啥都不懂</p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-编辑回复："><a href="#amp-nbsp-amp-nbsp-amp-nbsp-编辑回复：" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 编辑回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 编辑回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; 哈哈哈哈哈哈，加油</p>
</blockquote>
<h5 id="忠："><a href="#忠：" class="headerlink" title="*忠："></a>*忠：</h5><blockquote>
<p>不存在隐式原型，显式原型吧，<strong>proto</strong> 本身就不是ECMA的标准，是浏览器自己实现的。</p>
</blockquote>
<h5 id="道："><a href="#道：" class="headerlink" title="*道："></a>*道：</h5><blockquote>
<p>根据 MDN 文档”&gt;someObject.Prototype ，property <strong>proto</strong> 是非标准而被浏览器支持的属性。</p>
</blockquote>
<h5 id="道：-1"><a href="#道：-1" class="headerlink" title="*道："></a>*道：</h5><blockquote>
<p>这一节看得稍辛苦，补了一下基础。</p>
</blockquote>
<h5 id="聪："><a href="#聪：" class="headerlink" title="*聪："></a>*聪：</h5><blockquote>
<p>鄙人写的关于原型链相关的一篇博文：<a target="_blank" rel="noopener" href="https://chen-cong.blog.csdn.net/article/details/81211729%EF%BC%8C%E7%9B%B8%E4%BF%A1%E4%BD%A0%E7%9C%8B%E4%BA%86%E4%B8%80%E5%AE%9A%E4%BC%9A%E6%9C%89%E6%94%B6%E8%8E%B7">https://chen-cong.blog.csdn.net/article/details/81211729，相信你看了一定会有收获</a></p>
</blockquote>
<h5 id="飞："><a href="#飞：" class="headerlink" title="**飞："></a>**飞：</h5><blockquote>
<p>不太理解，显示原型，和隐式原型这两个概念😔😇</p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-讲师回复："><a href="#amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; 可以简单地理解为显式原型是隐式原型的别名。</p>
</blockquote>
<h5 id="默："><a href="#默：" class="headerlink" title="*默："></a>*默：</h5><blockquote>
<p>绑定this，有bind，apply，call。还有箭头函数</p>
</blockquote>
<h5 id="用户5887："><a href="#用户5887：" class="headerlink" title="**用户5887："></a>**用户5887：</h5><blockquote>
<p>已知this指向调用它的对象，函数是特殊的对象，为什么全局函数b中调用函数a，指向的还是全局呢？函数自身为什么不能作为对象，有上下文呢</p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-1"><a href="#amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-1" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; 这个问题我想了很久，下面是个人思考，并不一定是正确答案。从js工作原理上来看，如果每次调用函数都去祖先函数去查找上下文，你想想函数调用栈的入栈出栈会有多么频繁，而这种性能损耗是完全可以避免的，因为开发者可以创建一个变量保存状态；从执行结果上来看，也会带来很大麻烦，函数的执行结果就变成不可预期，因为放到不同函数中继承的的上下文不同。</p>
</blockquote>
<h5 id="5741："><a href="#5741：" class="headerlink" title="**5741："></a>**5741：</h5><blockquote>
<p>所以看到最后还是没看出来题目“为什么说函数是 JavaScript 的一等公民？”这个问题的官方解答</p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-2"><a href="#amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-2" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; “一等公民”可以理解为有很多权利，对应到语言JavaScript就是说可以实现很多功能，比如课程中提到的模拟类的实现、创建作用域。</p>
</blockquote>
<h5 id="ty："><a href="#ty：" class="headerlink" title="ty："></a>ty：</h5><blockquote>
<p>其实我不太理解隐式原型存在的意义是什么，如果本来就可以通过prototype追溯到原型上去那多增加一个__proto__其实也用不到吧？</p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-3"><a href="#amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-3" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; 严格意义上来说，只有一个原型，那就是隐式原型 __proto__，显示原型 prototype 你可以理解为 <strong>proto</strong> 的语法糖，它的作用就是在创建实例的时候把实例的 _<em>proto</em> 指向当前的 prototype。</p>
</blockquote>
<h5 id="鸿："><a href="#鸿：" class="headerlink" title="*鸿："></a>*鸿：</h5><blockquote>
<p>修改this指向 bind ，call，apply&amp;nbsp; &amp;nbsp;bind在绑定this函数后不会立即执行，call和apply会，还有闭包不应该是外部访问内部变量吗</p>
</blockquote>
<h5 id="用户1028："><a href="#用户1028：" class="headerlink" title="**用户1028："></a>**用户1028：</h5><blockquote>
<p>var arrow &#x3D; {fn: () &#x3D;&gt; console.log(this)} 箭头函数改成function写法就从this指向window改成arrow对象呀, 没理解包一层函数 var arrow &#x3D; {fn(){ console.log(this)}}</p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-4"><a href="#amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-4" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; 函数 a 继承了函数 fn 的this，指向 arrow</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/11/02/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4%E5%87%BD%E6%95%B0%E6%98%AF-JavaScript-%E7%9A%84%E4%B8%80%E7%AD%89%E5%85%AC%E6%B0%91%EF%BC%9F/" data-id="claxeer9u000mv8w18l8k235g" data-title="为什么说函数是 JavaScript 的一等公民？" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-关于-JavaScript-的数据类型，你知多少？" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/11/02/%E5%85%B3%E4%BA%8E-JavaScript-%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%8C%E4%BD%A0%E7%9F%A5%E5%A4%9A%E5%B0%91%EF%BC%9F/" class="article-date">
  <time class="dt-published" datetime="2022-11-02T03:00:37.000Z" itemprop="datePublished">2022-11-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/11/02/%E5%85%B3%E4%BA%8E-JavaScript-%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%8C%E4%BD%A0%E7%9F%A5%E5%A4%9A%E5%B0%91%EF%BC%9F/">关于 JavaScript 的数据类型，你知多少？</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>数据类型通常是一门编程语言的基础知识，JavaScript 的数据类型可以分为 7 种：空（Null）、未定义（Undefined）、数字（Number）、字符串（String）、布尔值（Boolean）、符号（Symbol）、对象（Object）。</p>
<p>其中前 6 种类型为<strong>基础类型</strong>，最后 1 种为<strong>引用类型</strong>。这两者的区别在于，基础类型的数据在被引用或拷贝时，是值传递，也就是说会创建一个完全相等的变量；而引用类型只是创建一个指针指向原有的变量，实际上两个变量是“共享”这个数据的，并没有重新创建一个新的数据。</p>
<p>下面我们就来分别介绍这 7 种数据类型的重要概念及常见操作。</p>
<h3>Undefined</h3>
<p>Undefined 是一个很特殊的数据类型，它只有一个值，也就是 undefined。可以通过下面几种方式来得到 undefined：</p>
<ul>
<li>引用已声明但未初始化的变量；</li>
<li>引用未定义的对象属性；</li>
<li>执行无返回值函数；</li>
<li>执行 void 表达式；</li>
<li>全局常量 window.undefined 或 undefined。</li>
</ul>
<p>对应代码如下：</p>
<pre><code data-language="javascript" class="lang-javascript"><span class="hljs-keyword">var</span> a; <span class="hljs-comment">// undefined</span>
<span class="hljs-keyword">var</span> o = &#123;&#125;
o.b <span class="hljs-comment">// undefined</span>
(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;&#125;)() <span class="hljs-comment">// undefined</span>
<span class="hljs-keyword">void</span> <span class="hljs-number">0</span> <span class="hljs-comment">// undefined</span>
<span class="hljs-built_in">window</span>.undefined <span class="hljs-comment">// undefined</span>
</code></pre>
<p>其中比较推荐通过 void 表达式来得到 undefined 值，因为这种方式既简便（window.undefined 或 undefined 常量的字符长度都大于 "void 0" 表达式）又不需要引用额外的变量和属性；同时它作为表达式还可以配合三目运算符使用，代表不执行任何操作。</p>
<p>如下面的代码就表示满足条件 x 大于 0 且小于 5 的时候执行函数 fn，否则不进行任何操作：</p>
<pre><code data-language="javascript" class="lang-javascript">x&gt;<span class="hljs-number">0</span> &amp;&amp; x&lt;<span class="hljs-number">5</span> ? fn() : <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>;
</code></pre>
<p>如何判断一个变量的值是否为 undefined 呢？<br>
下面的代码给出了 3 种方式来判断变量 x 是否为 undefined，你可以先思考一下哪一种可行。</p>
<p>方式 1 直接通过<strong>逻辑取非</strong>操作来将变量 x 强制转换为布尔值进行判断；方式 2 通过 3 个等号将变量 x 与 undefined 做<strong>真值比较</strong>；方式 3 通过 typeof 关键字获取变量 x 的类型，然后与 'undefined' 字符串做<strong>真值比较：</strong></p>
<pre><code data-language="javascript" class="lang-javascript"><span class="hljs-comment">// 方式1</span>
<span class="hljs-keyword">if</span>(!x) &#123;
  ...
&#125;
<span class="hljs-comment">// 方式2</span>
<span class="hljs-keyword">if</span>(x===<span class="hljs-literal">undefined</span>) &#123;
  ...
&#125;
<span class="hljs-comment">// 方式2</span>
<span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> x === <span class="hljs-string">'undefined'</span>) &#123;
  ...
&#125;
</code></pre>
<p>现在来揭晓答案，方式 1 不可行，因为只要变量 x 的值为 undefined、空字符串、数值 0、null 时都会判断为真。方式 2 也存在一些问题，虽然通过 “===” 和 undefined 值做比较是可行的，但如果 x 未定义则会抛出错误 “ReferenceError: x is not defined” 导致程序执行终止，这对于代码的健壮性显然是不利的。方式 3 则解决了这一问题。</p>
<h3>Null</h3>
<p>Null 数据类型和 Undefined 类似，只有唯一的一个值 null，都可以表示空值，甚至我们通过 “==” 来比较它们是否相等的时候得到的结果都是 true，但 null 是 JavaScript 保留关键字，而 undefined 只是一个常量。</p>
<p>也就是说我们可以声明名称为 undefined 的变量（虽然只能在老版本的 IE 浏览器中给它重新赋值），但将 null 作为变量使用时则会报错。</p>
<h3>Boolean</h3>
<p>Boolean 数据类型只有两个值：true 和 false，分别代表真和假，理解和使用起来并不复杂。但是我们常常会将各种表达式和变量转换成 Boolean 数据类型来当作判断条件，这时候就要注意了。</p>
<p>下面是一个简单地将星期数转换成中文的函数，比如输入数字 1，函数就会返回“星期一”，输入数字 2 会返回“星期二”，以此类推，如果未输入数字则返回 undefined。</p>
<pre><code data-language="javascript" class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getWeek</span>(<span class="hljs-params">week</span>) </span>&#123;
  <span class="hljs-keyword">const</span> dict = [<span class="hljs-string">'日'</span>, <span class="hljs-string">'一'</span>, <span class="hljs-string">'二'</span>, <span class="hljs-string">'三'</span>, <span class="hljs-string">'四'</span>, <span class="hljs-string">'五'</span>, <span class="hljs-string">'六'</span>];
  <span class="hljs-keyword">if</span>(week) <span class="hljs-keyword">return</span> <span class="hljs-string">`星期<span class="hljs-subst">$&#123;dict[week]&#125;</span>`</span>;
&#125;
</code></pre>
<p>这里在 if 语句中就进行了类型转换，将 week 变量转换成 Boolean 数据类型，而 0、空字符串、null、undefined 在转换时都会返回 false。所以这段代码在输入 0 的时候不会返回“星期日”，而返回 undefined。<br>
我们在做强制类型转换的时候一定要考虑这个问题。</p>
<h3>Number</h3>
<h4>两个重要值</h4>
<p>Number 是数值类型，有 2 个特殊数值得注意一下，即 NaN 和 Infinity。</p>
<ul>
<li>NaN（Not a Number）通常在计算失败的时候会得到该值。要判断一个变量是否为 NaN，则可以通过 Number.isNaN 函数进行判断。</li>
<li>Infinity 是无穷大，加上负号 “-” 会变成无穷小，在某些场景下比较有用，比如通过数值来表示权重或者优先级，Infinity 可以表示最高优先级或最大权重。</li>
</ul>
<h4>进制转换</h4>
<p>当我们需要将其他进制的整数转换成十进制显示的时候可以使用 parseInt 函数，该函数第一个参数为数值或字符串，第二个参数为进制数，默认为 10，当进制数转换失败时会返回 NaN。所以，如果在数组的 map 函数的回调函数中直接调用 parseInt，那么会将数组元素和索引值都作为参数传入。</p>
<pre><code data-language="javascript" class="lang-javascript">[<span class="hljs-string">'0'</span>, <span class="hljs-string">'1'</span>, <span class="hljs-string">'2'</span>].map(<span class="hljs-built_in">parseInt</span>) <span class="hljs-comment">// [0, NaN, NaN]</span>
</code></pre>
<p>而将十进制转换成其他进制时，可以通过 toString 函数来实现。</p>
<pre><code data-language="javascript" class="lang-javascript">(<span class="hljs-number">10</span>).toString(<span class="hljs-number">2</span>) <span class="hljs-comment">// "1010"</span>
</code></pre>
<h4>精度问题</h4>
<p>对于数值类型的数据，还有一个比较值得注意的问题，那就是<strong>精度问题</strong>，在进行浮点数运算时很容易碰到。比如我们执行简单的运算 0.1 + 0.2，得到的结果是 0.30000000000000004，如果直接和 0.3 作相等判断时就会得到 false。</p>
<pre><code data-language="javascript" class="lang-javascript"><span class="hljs-number">0.1</span> + <span class="hljs-number">0.2</span> <span class="hljs-comment">// 0.30000000000000004</span>
</code></pre>
<p>出现这种情况的原因在于计算的时候，JavaScript 引擎会先将十进制数转换为二进制，然后进行加法运算，再将所得结果转换为十进制。在进制转换过程中如果小数位是无限的，就会出现误差。同样的，对于下面的表达式，将数字 5 开方后再平方得到的结果也和数字 5 不相等。</p>
<pre><code data-language="javascript" class="lang-javascript"><span class="hljs-built_in">Math</span>.pow(<span class="hljs-built_in">Math</span>.pow(<span class="hljs-number">5</span>, <span class="hljs-number">1</span>/<span class="hljs-number">2</span>), <span class="hljs-number">2</span>) <span class="hljs-comment">// 5.000000000000001</span>
</code></pre>
<p>对于这个问题的解决方法也很简单，那就是消除无限小数位。</p>
<ul>
<li>一种方式是先转换成整数进行计算，然后再转换回小数，这种方式适合在小数位不是很多的时候。比如一些程序的支付功能 API 以“分”为单位，从而避免使用小数进行计算。</li>
<li>还有另一种方法就是舍弃末尾的小数位。比如对上面的加法就可以先调用 toPrecision 截取 12 位，然后调用 parseFloat 函数转换回浮点数。</li>
</ul>
<pre><code data-language="javascript" class="lang-javascript"><span class="hljs-built_in">parseFloat</span>((<span class="hljs-number">0.1</span> + <span class="hljs-number">0.2</span>).toPrecision(<span class="hljs-number">12</span>)) <span class="hljs-comment">// 0.3</span>
</code></pre>
<h3>String</h3>
<p>String 类型是最常用的数据类型了，关于它的基础 API 函数大家应该比较熟悉了，这里我就不多介绍了。下面通过一道笔试题来重点介绍它的使用场景。</p>
<p><strong>千位分隔符</strong>是指为了方便识别较大数字，每隔三位数会加入 1 个逗号，该逗号就是千位分隔符。如果要编写一个函数来为输入值的数字添加千分位分隔符，该怎么实现呢？</p>
<p>一种很容易想到的方法就是从右往左遍历数值每一位，每隔 3 位添加分隔符。为了操作方便，我们可以将数值转换成字符数组，而要实现从右往左遍历，一种实现方式是通过 for 循环的索引值找到对应的字符；而另一种方式是通过数组反转，从而变成从左到右操作。</p>
<pre><code data-language="javascript" class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sep</span>(<span class="hljs-params">n</span>) </span>&#123;
&nbsp; <span class="hljs-keyword">let</span> [i, c] = n.toString().split(<span class="hljs-regexp">/(\.\d+)/</span>)
&nbsp; <span class="hljs-keyword">return</span> i.split(<span class="hljs-string">''</span>).reverse().map(<span class="hljs-function">(<span class="hljs-params">c, idx</span>) =&gt;</span> (idx+<span class="hljs-number">1</span>) % <span class="hljs-number">3</span> === <span class="hljs-number">0</span> ? <span class="hljs-string">','</span> + c: c).reverse().join(<span class="hljs-string">''</span>).replace(<span class="hljs-regexp">/^,/</span>, <span class="hljs-string">''</span>) + c
&#125;
</code></pre>
<p>这种方式就是将字符串数据转化成引用类型数据，即用数组来实现。</p>
<p>第二种方式则是通过引用类型，即用正则表达式对字符进行替换来实现。</p>
<pre><code data-language="javascript" class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sep2</span>(<span class="hljs-params">n</span>)</span>&#123;
&nbsp; <span class="hljs-keyword">let</span> str = n.toString()
&nbsp; str.indexOf(<span class="hljs-string">'.'</span>) &lt; <span class="hljs-number">0</span> ? str+= <span class="hljs-string">'.'</span> : <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>
&nbsp; <span class="hljs-keyword">return</span> str.replace(<span class="hljs-regexp">/(\d)(?=(\d&#123;3&#125;)+\.)/g</span>, <span class="hljs-string">'$1,'</span>).replace(<span class="hljs-regexp">/\.$/</span>, <span class="hljs-string">''</span>)
&#125;
</code></pre>
<h3>Symbol</h3>
<p>Symbol 是 ES6 中引入的新数据类型，它表示一个唯一的常量，通过 Symbol 函数来创建对应的数据类型，创建时可以添加变量描述，该变量描述在传入时会被强行转换成字符串进行存储。</p>
<pre><code data-language="javascript" class="lang-javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">'1'</span>)
<span class="hljs-keyword">var</span> b = <span class="hljs-built_in">Symbol</span>(<span class="hljs-number">1</span>)
a.description === b.description <span class="hljs-comment">// true</span>
<span class="hljs-keyword">var</span> c = <span class="hljs-built_in">Symbol</span>(&#123;<span class="hljs-attr">id</span>: <span class="hljs-number">1</span>&#125;)
c.description <span class="hljs-comment">// [object Object]</span>
<span class="hljs-keyword">var</span> _a = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">'1'</span>)
_a == a <span class="hljs-comment">// false</span>
</code></pre>
<p>基于上面的特性，Symbol 属性类型比较适合用于两类场景中：<strong>常量值和对象属性</strong>。</p>
<h4>避免常量值重复</h4>
<p>假设有个 getValue 函数，根据传入的字符串参数 key 执行对应代码逻辑。代码如下所示：</p>
<pre><code data-language="javascript" class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getValue</span>(<span class="hljs-params">key</span>) </span>&#123;
&nbsp; <span class="hljs-keyword">switch</span>(key)&#123;
&nbsp; &nbsp; <span class="hljs-keyword">case</span> <span class="hljs-string">'A'</span>:
&nbsp; &nbsp; &nbsp; ...
&nbsp; &nbsp; ...
&nbsp; &nbsp; case <span class="hljs-string">'B'</span>:
      ...
&nbsp; &#125;
&#125;
getValue(<span class="hljs-string">'B'</span>);
</code></pre>
<p>这段代码对调用者而言非常不友好，因为代码中使用了魔术字符串（魔术字符串是指在代码之中多次出现、与代码形成强耦合的某一个具体的字符串或者数值），导致调用 getValue 函数时需要查看函数源码才能找到参数 key 的可选值。所以可以将参数 key 的值以常量的方式声明出来。</p>
<pre><code data-language="javascript" class="lang-javascript"><span class="hljs-keyword">const</span> KEY = &#123;
&nbsp; <span class="hljs-attr">alibaba</span>: <span class="hljs-string">'A'</span>,
&nbsp; <span class="hljs-attr">baidu</span>: <span class="hljs-string">'B'</span>,
&nbsp; ...
&#125;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getValue</span>(<span class="hljs-params">key</span>) </span>&#123;
&nbsp; <span class="hljs-keyword">switch</span>(key)&#123;
&nbsp; &nbsp; <span class="hljs-keyword">case</span> KEY.alibaba:
&nbsp; &nbsp; &nbsp; ...
&nbsp; &nbsp; ...
&nbsp; &nbsp; case KEY.baidu:
&nbsp; &nbsp; &nbsp; ...
&nbsp; &#125;
&#125;
getValue(KEY.baidu);
</code></pre>
<p>但这样也并非完美，假设现在我们要在 KEY 常量中加入一个 key，根据对应的规则，很有可能会出现值重复的情况：</p>
<pre><code data-language="javascript" class="lang-javascript"><span class="hljs-keyword">const</span> KEY = &#123;
  <span class="hljs-attr">alibaba</span>: <span class="hljs-string">'A'</span>,
  <span class="hljs-attr">baidu</span>: <span class="hljs-string">'B'</span>,
  ...
  bytedance: <span class="hljs-string">'B'</span>
&#125;
</code></pre>
<p>这显然会出现问题：</p>
<pre><code data-language="javascript" class="lang-javascript">getValue(KEY.baidu) <span class="hljs-comment">// 等同于 getValue(KEY.bytedance)</span>
</code></pre>
<p>所以在这种场景下更适合使用 Symbol，我们不关心值本身，只关心值的唯一性。</p>
<pre><code data-language="javascript" class="lang-javascript"><span class="hljs-keyword">const</span> KEY = &#123;
&nbsp; <span class="hljs-attr">alibaba</span>: <span class="hljs-built_in">Symbol</span>(),
&nbsp; <span class="hljs-attr">baidu</span>: <span class="hljs-built_in">Symbol</span>(),
&nbsp; ...
&nbsp; bytedance: <span class="hljs-built_in">Symbol</span>()
&#125;
</code></pre>
<h4>避免对象属性覆盖</h4>
<p>假设有这样一个函数 fn，需要对传入的对象参数添加一个临时属性 user，但可能该对象参数中已经有这个属性了，如果直接赋值就会覆盖之前的值。此时就可以使用 Symbol 来避免这个问题。</p>
<p>创建一个 Symbol 数据类型的变量，然后将该变量作为对象参数的属性进行赋值和读取，这样就能避免覆盖的情况，示例代码如下：</p>
<pre><code data-language="javascript" class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params">o</span>) </span>&#123; <span class="hljs-comment">// &#123;user: &#123;id: xx, name: yy&#125;&#125;</span>
&nbsp; <span class="hljs-keyword">const</span> s = <span class="hljs-built_in">Symbol</span>()
&nbsp; o[s] = <span class="hljs-string">'zzz'</span>
&nbsp; ...
&#125;
</code></pre>
<h3>补充：类型转换</h3>
<h4>什么是类型转换？</h4>
<p>JavaScript 这种弱类型的语言，相对于其他高级语言有一个特点，那就是在处理不同数据类型运算或逻辑操作时会强制转换成同一数据类型。如果我们不理解这个特点，就很容易在编写代码时产生 bug。</p>
<p>通常强制转换的目标数据类型为 String、Number、Boolean 这三种。下面的表格中显示了 6 种基础数据类型转换关系。</p>
<p><img src="https://s0.lgstatic.com/i/image/M00/17/C1/CgqCHl7XaNOAOR-5AAC7iyHcEyQ034.png" alt="前端07.png"></p>
<p>除了不同类型的转换之外，操作同种数据类型也会发生转换。把基本类型的数据换成对应的对象过程称之为“<strong>装箱转换</strong>”，反过来，把数据对象转换为基本类型的过程称之为“<strong>拆箱转换</strong>”。</p>
<p>对于装箱和拆箱转换操作，我们既可以显示地手动实现，比如将 Number 数据类型转换成 Number 对象；也可以通过一些操作触发浏览器显式地自动转换，比如将对 Number 对象进行加法运算。</p>
<pre><code data-language="javascript" class="lang-javascript"><span class="hljs-keyword">var</span> n = <span class="hljs-number">1</span>
<span class="hljs-keyword">var</span> o = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Number</span>(n) <span class="hljs-comment">// 显式装箱</span>
o.valueOf() <span class="hljs-comment">// 显式拆箱</span>
n.toPrecision(<span class="hljs-number">3</span>) <span class="hljs-comment">// 隐式装箱, 实际操作：var tmp = new Number(n);tmp.toPrecision(3);tmp = null;</span>
o + <span class="hljs-number">2</span> <span class="hljs-comment">// 隐式拆箱，实际操作:var tmp = o.valueOf();tmp + 2;tmp = null;</span>
</code></pre>
<h4>什么时候会触发类型转换？</h4>
<p>下面这些常见的操作会触发隐式地类型转换，我们在编写代码的时候一定要注意。</p>
<ul>
<li><strong>运算相关的操作符</strong>包括 +、-、+=、++、* 、/、%、&lt;&lt;、&amp; 等。</li>
<li><strong>数据比较相关的操作符</strong>包括 &gt;、&lt;、== 、&lt;=、&gt;=、===。</li>
<li><strong>逻辑判断相关的操作符</strong>包括 &amp;&amp;、!、||、三目运算符。</li>
</ul>
<h3>Object</h3>
<p>相对于基础类型，引用类型 Object 则复杂很多。简单地说，Object 类型数据就是键值对的集合，键是一个字符串（或者 Symbol） ，值可以是任意类型的值； 复杂地说，Object 又包括很多子类型，比如 Date、Array、Set、RegExp。</p>
<p>对于 Object 类型，我们重点理解一种常见的操作，即深拷贝。</p>
<ul>
<li>由于引用类型在赋值时只传递指针，这种拷贝方式称为<strong>浅拷贝</strong>。</li>
<li>而创建一个新的与之相同的引用类型数据的过程称之为<strong>深拷贝</strong>。</li>
</ul>
<p>现在我们来实现一个拷贝函数，支持上面 7 种类型的数据拷贝。</p>
<p>对于 6 种基础类型，我们只需简单的赋值即可，而 Object 类型变量需要特殊操作。因为通过等号“=”赋值只是<strong>浅拷贝</strong>，要实现真正的拷贝操作则需要通过遍历键来赋值对应的值，这个过程中如果遇到 Object 类型还需要再次进行遍历。</p>
<p>为了准确判断每种数据类型，我们可以先通过 typeof 来查看每种数据类型的描述：</p>
<pre><code data-language="javascript" class="lang-javascript">[<span class="hljs-literal">undefined</span>,&nbsp;<span class="hljs-literal">null</span>,&nbsp;<span class="hljs-literal">true</span>,&nbsp;<span class="hljs-string">''</span>,&nbsp;<span class="hljs-number">0</span>,&nbsp;<span class="hljs-built_in">Symbol</span>(),&nbsp;&#123;&#125;].map(<span class="hljs-function"><span class="hljs-params">it</span>&nbsp;=&gt;</span>&nbsp;<span class="hljs-keyword">typeof</span>&nbsp;it)<span class="hljs-comment">//&nbsp;["undefined",&nbsp;"object",&nbsp;"boolean",&nbsp;"string",&nbsp;"number",&nbsp;"symbol",&nbsp;"object"]</span>
</code></pre>
<p>发现 null 有些特殊，返回结果和 Object 类型一样都为"object"，所以需要再次进行判断。按照上面分析的结论，我们可以写出下面的函数：</p>
<pre><code data-language="javascript" class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span>&nbsp;<span class="hljs-title">clone</span>(<span class="hljs-params">data</span>)&nbsp;</span>&#123;
&nbsp;&nbsp;<span class="hljs-keyword">let</span>&nbsp;result&nbsp;=&nbsp;&#123;&#125;
&nbsp;&nbsp;<span class="hljs-keyword">const</span>&nbsp;keys&nbsp;=&nbsp;[...Object.getOwnPropertyNames(data),&nbsp;...Object.getOwnPropertySymbols(data)]
&nbsp;&nbsp;<span class="hljs-keyword">if</span>(!keys.length)&nbsp;<span class="hljs-keyword">return</span>&nbsp;data
&nbsp;&nbsp;keys.forEach(<span class="hljs-function"><span class="hljs-params">key</span>&nbsp;=&gt;</span>&nbsp;&#123;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">let</span>&nbsp;item&nbsp;=&nbsp;data[key]
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">if</span>&nbsp;(<span class="hljs-keyword">typeof</span>&nbsp;item&nbsp;===&nbsp;<span class="hljs-string">'object'</span>&nbsp;&amp;&amp;&nbsp;item)&nbsp;&#123;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result[key]&nbsp;=&nbsp;clone(item)
&nbsp;&nbsp;&nbsp;&nbsp;&#125;&nbsp;<span class="hljs-keyword">else</span>&nbsp;&#123;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result[key]&nbsp;=&nbsp;item
&nbsp;&nbsp;&nbsp;&nbsp;&#125;
&nbsp;&nbsp;&#125;)
&nbsp;&nbsp;<span class="hljs-keyword">return</span>&nbsp;result
&#125;
</code></pre>
<p>在遍历 Object 类型数据时，我们需要把 Symbol 数据类型也考虑进来，所以不能通过 Object.keys 获取键名或 for...in 方式遍历，而是通过 getOwnPropertyNames 和 getOwnPropertySymbols 函数将键名组合成数组，然后进行遍历。对于键数组长度为 0 的非 Object 类型的数据可直接返回，然后再遍历递归，最终实现拷贝。</p>
<p>我们在编写递归函数的时候需要特别注意的是，递归调用的终止条件，避免无限递归。那在这个 clone 函数中有没有可能出现无限递归调用呢？</p>
<p>答案是有的。那就是当对象数据嵌套的时候，比如像下面这种情况，对象 a 的键 b 指向对象 b，对象 b 的键 a 指向对象 a，那么执行 clone 函数就会出现死循环，从而耗尽内存。</p>
<pre><code data-language="javascript" class="lang-javascript"><span class="hljs-keyword">var</span> a = &#123;
<span class="hljs-keyword">var</span> b = &#123;&#125;
a.b = b
b.a = a
</code></pre>
<p>怎么避免这种情况呢？一种简单的方式就是把已添加的对象记录下来，这样下次碰到相同的对象引用时，直接指向记录中的对象即可。要实现这个记录功能，我们可以借助 ES6 推出的 WeakMap 对象，该对象是一组键/值对的集合，其中的键是弱引用的。其键必须是对象，而值可以是任意的。</p>
<p>我们对 clone 函数改造一下，添加一个 WeakMap 来记录已经拷贝过的对象，如果当前对象已经被拷贝过，那么直接从 WeakMap 中取出，否则重新创建一个对象并加入 WeakMap 中。具体代码如下：</p>
<pre><code data-language="javascript" class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span>&nbsp;<span class="hljs-title">clone</span>(<span class="hljs-params">obj</span>)&nbsp;</span>&#123;
&nbsp;&nbsp;<span class="hljs-keyword">let</span>&nbsp;map&nbsp;=&nbsp;<span class="hljs-keyword">new</span>&nbsp;<span class="hljs-built_in">WeakMap</span>()
&nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">function</span>&nbsp;<span class="hljs-title">deep</span>(<span class="hljs-params">data</span>)&nbsp;</span>&#123;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">let</span>&nbsp;result&nbsp;=&nbsp;&#123;&#125;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span>&nbsp;keys&nbsp;=&nbsp;[...Object.getOwnPropertyNames(data),&nbsp;...Object.getOwnPropertySymbols(data)]
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">if</span>(!keys.length)&nbsp;<span class="hljs-keyword">return</span>&nbsp;data
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span>&nbsp;exist&nbsp;=&nbsp;map.get(data)
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">if</span>&nbsp;(exist)&nbsp;<span class="hljs-keyword">return</span>&nbsp;exist
&nbsp;&nbsp;&nbsp;&nbsp;map.set(data,&nbsp;result)
&nbsp;&nbsp;&nbsp;&nbsp;keys.forEach(<span class="hljs-function"><span class="hljs-params">key</span>&nbsp;=&gt;</span>&nbsp;&#123;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">let</span>&nbsp;item&nbsp;=&nbsp;data[key]
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">if</span>&nbsp;(<span class="hljs-keyword">typeof</span>&nbsp;item&nbsp;===&nbsp;<span class="hljs-string">'object'</span>&nbsp;&amp;&amp;&nbsp;item)&nbsp;&#123;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result[key]&nbsp;=&nbsp;deep(item)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#125;&nbsp;<span class="hljs-keyword">else</span>&nbsp;&#123;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result[key]&nbsp;=&nbsp;item
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#125;
&nbsp;&nbsp;&nbsp;&nbsp;&#125;)
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span>&nbsp;result
&nbsp;&nbsp;&#125;
&nbsp;&nbsp;<span class="hljs-keyword">return</span>&nbsp;deep(obj)
&#125;
</code></pre>
<h3>总结</h3>
<p>这一课时通过实例与原理相结合，带你深入理解了 JavaScript 的 6 种基础数据类型和 1 种引用数据类型。对于 6 种基础数据类型，我们要熟知它们之间的转换关系，而引用类型则比较复杂，重点讲了如何深拷贝一个对象。其实引用对象的子类型比较多，由于篇幅所限没有进行一一讲解，需要大家在平常工作中继续留心积累。</p>
<p>最后布置一道思考题：你能否写出一个函数来判断两个变量是否相等？</p>

<hr>
<h3 id="精选评论"><a href="#精选评论" class="headerlink" title="精选评论"></a>精选评论</h3><h5 id="Amanda："><a href="#Amanda：" class="headerlink" title="Amanda："></a>Amanda：</h5><blockquote>
<p>已经有第8种类型了</p>
</blockquote>
<h5 id="玥："><a href="#玥：" class="headerlink" title="**玥："></a>**玥：</h5><blockquote>
<p>千位分隔符的第一种方法输入整数会输出整数+undefined</p>
</blockquote>
<h5 id="："><a href="#：" class="headerlink" title="**.："></a>**.：</h5><blockquote>
<p>自带千分位函数(1234567).toLocaleString()</p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-讲师回复："><a href="#amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; 嗯，这是一个高效的方法，但最好指定语言环境，例如 (1234567).toLocaleString(‘zh-Hans-CN’)</p>
</blockquote>
<h5 id="客："><a href="#客：" class="headerlink" title="*客："></a>*客：</h5><blockquote>
<p>“(10).toString(16)” 这里为什么加了”括号”就可以用 toString 方法，不加的话就报错；加”括号”的话，编译器是做了什么吗？</p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-1"><a href="#amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-1" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; 默认地，数字后的点号会被当成小数来进行解析，所以接“toString”会报错。而加了括号之后在进行词法分析的时候括号内的数字 10 就会被单独解析，和后面的属性 toString 以及参数 16 组合成一个表达式。</p>
</blockquote>
<h5 id="文："><a href="#文：" class="headerlink" title="**文："></a>**文：</h5><blockquote>
<p>值类型(基本类型)：字符串（String）、数字(Number)、布尔(Boolean)、对空（Null）、未定义（Undefined）、Symbol。引用数据类型：对象(Object)、数组(Array)、函数(Function)。</p>
</blockquote>
<h5 id="用户7763："><a href="#用户7763：" class="headerlink" title="**用户7763："></a>**用户7763：</h5><blockquote>
<p>关于改变this指向的，call，apply，bind…还有吗😂😂</p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-2"><a href="#amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-2" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; class 中 this 会指向类的实例。</p>
</blockquote>
<h5 id="池："><a href="#池：" class="headerlink" title="**池："></a>**池：</h5><blockquote>
<p>这节课很奈斯～😇</p>
</blockquote>
<h5 id="聪："><a href="#聪：" class="headerlink" title="*聪："></a>*聪：</h5><blockquote>
<p>还有一种类型：BigInt</p>
</blockquote>
<h5 id="珍："><a href="#珍：" class="headerlink" title="**珍："></a>**珍：</h5><blockquote>
<p>关于浅拷贝，我感觉我很困惑。有些说浅拷贝是一层拷贝，有些浅拷贝是等号赋值。所以具体是哪个？我都懵了😂</p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-3"><a href="#amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-3" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; 没理解你所说的“一层拷贝“~ 浅拷贝你可以理解为给变量起了个别名，并没有创建新的值。</p>
</blockquote>
<h5 id="盼："><a href="#盼：" class="headerlink" title="*盼："></a>*盼：</h5><blockquote>
<p>赞</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/11/02/%E5%85%B3%E4%BA%8E-JavaScript-%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%8C%E4%BD%A0%E7%9F%A5%E5%A4%9A%E5%B0%91%EF%BC%9F/" data-id="claxeer9v000rv8w1d6gn6ay4" data-title="关于 JavaScript 的数据类型，你知多少？" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-浏览器如何渲染页面？" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/11/02/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%A6%82%E4%BD%95%E6%B8%B2%E6%9F%93%E9%A1%B5%E9%9D%A2%EF%BC%9F/" class="article-date">
  <time class="dt-published" datetime="2022-11-02T03:00:05.000Z" itemprop="datePublished">2022-11-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/11/02/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%A6%82%E4%BD%95%E6%B8%B2%E6%9F%93%E9%A1%B5%E9%9D%A2%EF%BC%9F/">浏览器如何渲染页面？</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>这一课时我将结合代码实例为你讲解浏览器渲染页面时的流程和步骤。</p>
<p>先来看一个例子，假如我们在浏览器中输入了一个网址，得到了下面的 html 文件，渲染引擎是怎样通过解析代码生成页面的呢？</p>
<pre><code data-language="xml" class="lang-xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>
&nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
&nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
&nbsp; &nbsp; lagou
&nbsp; <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre>
<h3>从 HTML 到 DOM</h3>
<h4>1. 字节流解码</h4>
<p>对于上面的代码，我们看到的是它的字符形式。而浏览器通过 HTTP 协议接收到的文档内容是字节数据，下图是抓包工具截获的报文截图，报文内容为左侧高亮显示的区域（为了查看方便，该工具将字节数据以十六进制方式显示）。当浏览器得到字节数据后，通过“<a target="_blank" rel="noopener" href="https://html.spec.whatwg.org/multipage/parsing.html#encoding-sniffing-algorithm">编码嗅探算法</a>”来确定字符编码，然后根据字符编码将字节流数据进行解码，生成截图右侧的字符数据，也就是我们编写的代码。</p>
<p>这个把字节数据解码成字符数据的过程称之为“<strong>字节流解码</strong>”。</p>
<p><img src="https://s0.lgstatic.com/i/image/M00/12/EE/CgqCHl7OM8-AJ2jzAABvLLJLW2s663.png" alt="image (4).png"></p>
<p>我们通过浏览器调试工具查看网络请求时，也是经过了上述操作过程，才能直观地看到字符串。</p>
<h4>2. 输入流预处理</h4>
<p>通过上一步解码得到的字符流数据在进入解析环节之前还需要进行一些预处理操作。比如将换行符转换成统一的格式，最终生成规范化的字符流数据，这个把字符数据进行统一格式化的过程称之为“<strong>输入流预处理</strong>”。</p>
<h4>3. 令牌化</h4>
<p>经过前两步的数据解码和预处理，下面就要进入重要的解析步骤了。</p>
<p>解析包含两步，第一步是<strong>将字符数据转化成令牌（Token）</strong>，第二步是<strong>解析 HTML 生成 DOM 树</strong>。先来说说令牌化，其过程是使用了一种类似状态机的算法，即每次接收一个或多个输入流中的字符；然后根据当前状态和这些字符来更新下一个状态，也就是说在不同的状态下接收同样的字符数据可能会产生不同的结果，比如当接收到“body”字符串时，在标签打开状态会解析成标签，在标签关闭状态则会解析成文本节点。</p>
<p>这个算法的解析规则较多，在此就不一一列举了，有兴趣的同学可以通过下面这个简单的例子来理解其原理。</p>
<p>上述 html 代码的标记过程如下：</p>
<ol>
<li>初始化为“数据状态”（Data State）；</li>
<li>匹配到字符 &lt;，状态切换到 “标签打开状态”（Tag Open State）；</li>
<li>匹配到字符 !，状态切换至 “标签声明打开状态”（Markup Declaration Open State），后续 7 个字符可以组成字符串 DOCTYPE，跳转到 “DOCTYPE 状态”（DOCTYPE State）；</li>
<li>匹配到字符为空格，当前状态切换至 “DOCTYPE 名称之前状态”（Before DOCTYPE Name State）；</li>
<li>匹配到字符串 html，创建一个新的 DOCTYPE 标记，标记的名字为 “html” ，然后当前状态切换至 “DOCTYPE 名字状态”（DOCTYPE Name State）；</li>
<li>匹配到字符 &gt;，跳转到 “数据状态” 并且释放当前的 DOCTYPE 标记；</li>
<li>匹配到字符 &lt;，切换到 “标签打开状态”；</li>
<li>匹配到字符 h，创建一个新的起始标签标记，设置标记的标签名为空，当前状态切换至 “标签名称状态”（Tag Name State）；</li>
<li>从字符 h 开始解析，将解析的字符一个一个添加到创建的起始标签标记的标签名中，直到匹配到字符 &gt;，此时当前状态切换至 “数据状态” 并释放当前标记，当前标记的标签名为 “html” 。</li>
<li>解析后续的  的方式与  一致，创建并释放对应的起始标签标记，解析完毕后，当前状态处于 “数据状态” ；</li>
<li>匹配到字符串 “标记” ，针对每一个字符，创建并释放一个对应的字符标记，解析完毕后，当前状态仍然处于 “数据状态” ；</li>
<li>匹配到字符 &lt;，进入 “标签打开状态” ；</li>
<li>匹配到字符 /，进入 “结束标签打开状态”（End Tag Open State）；</li>
<li>匹配到字符 b，创建一个新的结束标签标记，设置标记的标签名为空，当前状态切换至“标签名称状态”（Tag Name State）；</li>
<li>重新从字符 b 开始解析，将解析的字符一个一个添加到创建的结束标签标记的标签名中，直到匹配到字符 &gt;，此时当前状态切换至 “数据状态” 并释放当前标记，当前标记的标签名为 “body”；</li>
<li>解析  的方式与  一样；</li>
<li>所有的 html 标签和文本解析完成后，状态切换至 “数据状态” ，一旦匹配到文件结束标志符（EOF），则释放 EOF 标记。</li>
</ol>
<p>最终生成类似下面的令牌结构：</p>
<pre><code data-language="xml" class="lang-xml">开始标签:html
  开始标签:head
  结束标签:head
  开始标签:body
    字符串:lagou
  结束标签:body
结束标签:html
</code></pre>
<h4>补充 1：遇到 script 标签时的处理</h4>
<p>如果在 HTML 解析过程中遇到 script 标签，则会发生一些变化。</p>
<p>如果遇到的是内联代码，也就是在 script 标签中直接写代码，那么解析过程会暂停，执行权限会转给 JavaScript 脚本引擎，待 JavaScript 脚本执行完成之后再交由渲染引擎继续解析。有一种情况例外，那就是脚本内容中调用了改变 DOM 结构的 document.write() 函数，此时渲染引擎会回到第二步，将这些代码加入字符流，重新进行解析。</p>
<p>如果遇到的是外链脚本，那么渲染引擎会按照我们在第 01 课时中所述的，根据标签属性来执行对应的操作。</p>
<h4>4. 构建 DOM 树</h4>
<p>解析 HTML 的第二步是树构建。</p>
<p>浏览器在创建解析器的同时会创建一个 Document 对象。在树构建阶段，Document 会作为根节点被不断地修改和扩充。标记步骤产生的令牌会被送到树构建器进行处理。HTML 5 标准中定义了每类令牌对应的 DOM 元素，当树构建器接收到某个令牌时就会创建该令牌对应的 DOM 元素并将该元素插入到 DOM 树中。</p>
<p>为了纠正元素标签嵌套错位的问题和处理未关闭的元素标签，树构建器创建的新 DOM 元素还会被插入到一个开放元素栈中。</p>
<p>树构建算法也可以采用状态机的方式来描述，具体我们以步骤 1 的 HTML 代码为例进行举例说明。</p>
<ol>
<li>进入初始状态 “initial” 模式；</li>
<li>树构建器接收到 DOCTYPE 令牌后，树构建器会创建一个 DocumentType 节点附加到 Document 节点上，DocumentType 节点的 name 属性为 DOCTYPE 令牌的名称，切换到 “before html” 模式；</li>
<li>接收到令牌 html 后，树构建器创建一个 html 元素并将该元素作为 Document 的子节点插入到 DOM 树中和开放元素栈中，切换为 “before head” 模式；</li>
<li>虽然没有接收到 head 令牌，但仍然会隐式地创建 head 元素并加到 DOM 树和开放元素栈中，切换到“in head”模式；</li>
<li>将开放元素栈中的 head 元素弹出，进入 “after head”模式；</li>
<li>接收到 body 令牌后，会创建一个 body 元素插入到 DOM 树中同时压入开放元素栈中，当前状态切换为 “in body” 模式；</li>
<li>接收到字符令牌，创建 Text 节点，节点值为字符内容“标记”，将 Text 节点作为 body 元素节点插入到 DOM 树中；</li>
<li>接收到结束令牌 body，将开放元素栈中的 body 元素弹出，切换至 “after body” 模式；</li>
<li>接收到结束令牌 html，将开放元素栈中的 html 元素弹出，切换至 “after after body” 模式；</li>
<li>接收到 EOF 令牌，树构建器停止构建，html 文档解析过程完成。</li>
</ol>
<p>最终生成下面的 DOM 树结构：</p>
<pre><code data-language="plain" class="lang-plain">              Document
             /        \
DocumentType           HTMLHtmlElement
                      /               \
       HTMLHeadElement                 HTMLBodyElement
                                              |
                                          TextNode
</code></pre>
<p><img src="https://s0.lgstatic.com/i/image/M00/12/EE/CgqCHl7OM-CAQGiGAAFv6uHi6MI573.png" alt="1.png"></p>
<h4>补充 2：从 CSS 到 CSSOM</h4>
<p>渲染引擎除了解析 HTML 之外，也需要解析 CSS。</p>
<p>CSS 解析的过程与 HTML 解析过程步骤一致，最终也会生成树状结构。</p>
<p>与 DOM 树不同的是，CSSOM 树的节点具有继承特性，也就是会先继承父节点样式作为当前样式，然后再进行补充或覆盖。下面举例说明。</p>
<pre><code data-language="java" class="lang-java">body &#123; font-size: <span class="hljs-number">12</span>px &#125;
p &#123; font-weight: light &#125;
span &#123; color: blue &#125;
p span &#123; display: none &#125;
img &#123; <span class="hljs-keyword">float</span>: left &#125;
</code></pre>
<p>对于上面的代码，会解析生成类似下面结构的 DOM 树：</p>
<p><img src="https://s0.lgstatic.com/i/image/M00/12/E2/Ciqc1F7OM-mAO8T2AAGu2Fxum4w061.png" alt="2.png"></p>
<p>需要注意的是，上图中的 CSSOM 树并不完整，完整的 CSSOM 树还应当包括浏览器提供的默认样式（也称为“User Agent 样式”）。</p>
<h3>从 DOM 到渲染</h3>
<p>有了 DOM 树和 CSSOM 树之后，渲染引擎就可以开始生成页面了。</p>
<h4>5. 构建渲染树</h4>
<p>DOM 树包含的结构内容与 CSSOM 树包含的样式规则都是独立的，为了更方便渲染，先需要将它们合并成一棵渲染树。</p>
<p>这个过程会从 DOM 树的根节点开始遍历，然后在 CSSOM 树上找到每个节点对应的样式。</p>
<p>遍历过程中会自动忽略那些不需要渲染的节点（比如脚本标记、元标记等）以及不可见的节点（比如设置了“display:none”样式）。同时也会将一些需要显示的伪类元素加到渲染树中。</p>
<p>对于上面的 HTML 和 CSS 代码，最终生成的渲染树就只有一个 body 节点，样式为 font-size:12px。</p>
<h4>6. 布局</h4>
<p>生成了渲染树之后，就可以进入布局阶段了，布局就是计算元素的大小及位置。</p>
<p>计算元素布局是一个比较复杂的操作，因为需要考虑的因素有很多，包括字体大小、换行位置等，这些因素会影响段落的大小和形状，进而影响下一个段落的位置。</p>
<p>布局完成后会输出对应的“盒模型”，它会精确地捕获每个元素的确切位置和大小，将所有相对值都转换为屏幕上的绝对像素。</p>
<h4>7. 绘制</h4>
<p>绘制就是将渲染树中的每个节点转换成屏幕上的实际像素的过程。得到布局树这份“施工图”之后，渲染引擎并不能立即绘制，因为还不知道绘制顺序，如果没有弄清楚绘制顺序，那么很可能会导致页面被错误地渲染。</p>
<p>例如，对于使用 z-index 属性的元素（如遮罩层）如果未按照正确的顺序绘制，则将导致渲染结果和预期不符（失去遮罩作用）。</p>
<p>所以绘制过程中的第一步就是遍历布局树，生成绘制记录，然后渲染引擎会根据绘制记录去绘制相应的内容。</p>
<p>对于无动画效果的情况，只需要考虑空间维度，生成不同的图层，然后再把这些图层进行合成，最终成为我们看到的页面。当然这个绘制过程并不是静态不变的，会随着页面滚动不断合成新的图形。</p>
<h3>总结</h3>
<p>这一课时主要讲解了浏览器渲染引擎生成页面的 7 个步骤，前面 4 个步骤为 DOM 树的生成过程，后面 3 个步骤是利用 DOM 树和 CSSOM 树来渲染页面的过程。我们想要理解和记忆这些过程其实很简单，那就是以数据变化为线索，具体来说数据的变化过程为：</p>
<p>字节 → 字符 → 令牌 → 树 → 页面</p>
<p>最后布置一道思考题：在构建渲染树的时候，渲染引擎需要遍历 DOM 树节点并从 CSSOM 树中找到匹配的样式规则，在匹配过程中是通过自上而下还是自下而上的方式呢？为什么？</p>

<hr>
<h3 id="精选评论"><a href="#精选评论" class="headerlink" title="精选评论"></a>精选评论</h3><h5 id="锐："><a href="#锐：" class="headerlink" title="**锐："></a>**锐：</h5><blockquote>
<p>不错哦</p>
</blockquote>
<h5 id="宇："><a href="#宇：" class="headerlink" title="*宇："></a>*宇：</h5><blockquote>
<div>匹配过程应该是自上而下，因为CSSOM有继承，不知道理解的对不对&nbsp;&nbsp;😹</div>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-讲师回复："><a href="#amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; 浏览器进行CSS选择器匹配时，是从右向左进行的，所以可以推知是自下而上</p>
</blockquote>
<h5 id="岳："><a href="#岳：" class="headerlink" title="**岳："></a>**岳：</h5><blockquote>
<p>应该是自下而上，如果自上而下，推测会引起重复渲染</p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-1"><a href="#amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-1" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; 嗯~确实应该如此</p>
</blockquote>
<h5 id="格："><a href="#格：" class="headerlink" title="**格："></a>**格：</h5><blockquote>
<p>CSSOM 树的节点具有继承特性，不是所有的样式都会继承的吧，比如width不能继承</p>
</blockquote>
<h5 id="5391："><a href="#5391：" class="headerlink" title="**5391："></a>**5391：</h5><blockquote>
<p>令牌化应该是 tokenize 吧，但是令牌一般指的是登录时候所说的那个 token，和编译中所说的 token 是两回事，这里应该称呼为“单词”更加恰当。</p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-2"><a href="#amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-2" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; 也可以称作 “分词”。这一块没有找到比较权威的翻译说明，大家重点还是理解这个意思~</p>
</blockquote>
<h5 id="贵："><a href="#贵：" class="headerlink" title="**贵："></a>**贵：</h5><blockquote>
<p>自上而下，执行到有外部css,会先读取外部css</p>
</blockquote>
<h5 id="兵："><a href="#兵：" class="headerlink" title="**兵："></a>**兵：</h5><blockquote>
<p>挺好的</p>
</blockquote>
<h5 id="鸣："><a href="#鸣：" class="headerlink" title="**鸣："></a>**鸣：</h5><blockquote>
<p>是从根节点开始匹配的，自下而上</p>
</blockquote>
<h5 id="坤："><a href="#坤：" class="headerlink" title="*坤："></a>*坤：</h5><blockquote>
<p>很简洁</p>
</blockquote>
<h5 id="鹏："><a href="#鹏：" class="headerlink" title="**鹏："></a>**鹏：</h5><blockquote>
<p>最后思考题的答案是什么？</p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-3"><a href="#amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-3" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; 自下而上</p>
</blockquote>
<h5 id="其："><a href="#其：" class="headerlink" title="**其："></a>**其：</h5><blockquote>
<p>自上而下？</p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-4"><a href="#amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-4" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; 是的</p>
</blockquote>
<h5 id="程："><a href="#程：" class="headerlink" title="*程："></a>*程：</h5><blockquote>
<p>自下而上，只有自下上，父元素才能获得子元素的所有属性以及布局，然后才能获得对应父元素的布局，比如文中就提到z-index。</p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-5"><a href="#amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-5" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; 浏览器进行CSS选择器匹配时，是从右向左进行的，所以可以推知是自下而上</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/11/02/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%A6%82%E4%BD%95%E6%B8%B2%E6%9F%93%E9%A1%B5%E9%9D%A2%EF%BC%9F/" data-id="claxeera7001jv8w1bgx29g2v" data-title="浏览器如何渲染页面？" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-手写-CSS-预处理" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/11/02/%E6%89%8B%E5%86%99-CSS-%E9%A2%84%E5%A4%84%E7%90%86/" class="article-date">
  <time class="dt-published" datetime="2022-11-02T02:59:17.000Z" itemprop="datePublished">2022-11-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/11/02/%E6%89%8B%E5%86%99-CSS-%E9%A2%84%E5%A4%84%E7%90%86/">手写 CSS 预处理</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3>功能需求</h3>
<p>这一课时我们来写一个 CSS 预处理器，它的功能可以理解为精简版的 <a target="_blank" rel="noopener" href="https://stylus.bootcss.com/">stylus</a>，主要实现的功能有：</p>
<ul>
<li>用空格和换行符替代花括号、冒号和分号；</li>
<li>支持选择器的嵌套组合；</li>
<li>支持以“$”符号开头的变量定义和使用。</li>
</ul>
<p>如果你对这种风格不是很熟悉也没关系，通过下面这个例子你就能很快明白。</p>
<p><strong>目标 CSS 代码</strong>，为 5 条样式规则。第 1 条和第 5 条样式规则是最简单的，使用 1 个选择器，定义了 1 条样式属性；第 2 条规则多用了一个标签选择器，样式属性值为多个字符串组成；第 3 条规则使用了类选择器；第 4 条规则增加了属性选择器，并且样式属性增加为 2 条。</p>
<pre><code data-language="css" class="lang-css"><span class="hljs-selector-tag">div</span> &#123;<span class="hljs-attribute">color</span>:darkkhaki;&#125;
<span class="hljs-selector-tag">div</span> <span class="hljs-selector-tag">p</span> &#123;<span class="hljs-attribute">border</span>:<span class="hljs-number">1px</span> solid lightgreen;&#125;
<span class="hljs-selector-tag">div</span> <span class="hljs-selector-class">.a-b</span> &#123;<span class="hljs-attribute">background-color</span>:lightyellow;&#125;
<span class="hljs-selector-tag">div</span> <span class="hljs-selector-class">.a-b</span> <span class="hljs-selector-attr">[data]</span> &#123;<span class="hljs-attribute">padding</span>:<span class="hljs-number">15px</span>;<span class="hljs-attribute">font-size</span>:<span class="hljs-number">12px</span>;&#125;
<span class="hljs-selector-class">.d-ib</span> &#123;<span class="hljs-attribute">display</span>:inline-block;&#125;
</code></pre>
<p>再来看看“源代码”，首先声明了两个变量，然后通过换行缩进定义了上述样式规则中的<strong>选择器和样式</strong>：</p>
<pre><code data-language="java" class="lang-java">$ib inline-block
$borderColor lightgreen
div
&nbsp; p
&nbsp; &nbsp; border <span class="hljs-number">1</span>px solid $borderColor
&nbsp; color darkkhaki
&nbsp; .a-b
&nbsp; &nbsp; background-color lightyellow
&nbsp; &nbsp; [data]
&nbsp; &nbsp; &nbsp; padding <span class="hljs-number">15</span>px
&nbsp; &nbsp; &nbsp; font-size <span class="hljs-number">12</span>px
.d-ib
&nbsp; display $ib
</code></pre>
<p>像上面这种强制缩进换行的风格应用非常广泛，比如编程语言 Python、HTML 模板 pug、预处理器 Sass（以“.sass”为后缀的文件）。</p>
<p>这种风格可能有些工程师并不适应，因为缩进空格数不一致就会导致程序解析失败或执行出错。但它也有一些优点，比如格式整齐，省去了花括号等冗余字符，减少了代码量。推荐大家在项目中使用。</p>
<h3>编译器</h3>
<p>对预处理器这种能将一种语言（法）转换成另一种语言（法）的程序一般称之为“<strong>编译器</strong>”。我们平常所知的高级语言都离不开编译器，比如 C++、Java、JavaScript。</p>
<p>不同语言的编译器的工作流程有些差异，但大体上可以分成三个步骤：解析（Parsing）、转换（Transformation）及代码生成（Code Generation）。</p>
<h4>解析</h4>
<p>解析步骤一般分为两个阶段：<strong>词法分析</strong>和<strong>语法分析</strong>。</p>
<p>词法分析就是将接收到的源代码转换成令牌（Token），完成这个过程的函数或工具被称之为<strong>词法分析器</strong>（Tokenizer 或 Lexer）。</p>
<p>令牌由一些代码语句的碎片生成，它们可以是数字、标签、标点符号、运算符，或者其他任何东西。</p>
<p>将代码令牌化之后会进入语法分析，这个过程会将之前生成的令牌转换成一种带有令牌关系描述的抽象表示，这种抽象的表示称之为<strong>抽象语法树</strong>（Abstract Syntax Tree，AST）。完成这个过程的函数或工具被称为<strong>语法分析器</strong>（Parser）。</p>
<p>抽象语法树通常是一个深度嵌套的对象，这种数据结构不仅更贴合代码逻辑，在后面的操作效率方面相对于令牌数组也更有优势。</p>
<p>可以回想一下，我们在第 06 讲中提到的解析 HTML 流程也包括了这两个步骤。</p>
<h4>转换</h4>
<p>解析完成之后的下一步就是<strong>转换</strong>，即把 AST 拿过来然后做一些修改，完成这个过程的函数或工具被称之为<strong>转换器</strong>（Transformer）。</p>
<p>在这个过程中，AST 中的节点可以被修改和删除，也可以新增节点。根本目的就是为了代码生成的时候更加方便。</p>
<h4>代码生成</h4>
<p>编译器的最后一步就是根据转换后的 AST 来生成目标代码，这个阶段做的事情有时候会和转换重叠，但是代码生成最主要的部分还是根据转换后的 AST 来输出代码。完成这个过程的函数或工具被称之为<strong>生成器</strong>（Generator）。</p>
<p>代码生成有几种不同的工作方式，有些编译器将会重用之前生成的令牌，有些会创建独立代码</p>
<p>表示，以便于线性地输出代码。但是接下来我们还是着重于使用之前生成好的 AST。</p>
<p>代码生成器必须知道如何“打印”转换后的 AST 中所有类型的节点，然后递归地调用自身，直到所有代码都被打印到一个很长的字符串中。</p>
<h3>代码实现</h3>
<p>学习了编译器相关知识之后，我们再来按照上述步骤编写代码。</p>
<h4>词法分析</h4>
<p>在进行词法分析之前，首先要考虑字符串可以被拆分成多少种类型的令牌，然后再确定令牌的判断条件及解析方式。</p>
<p>通过分析源代码，可以将字符串分为变量、变量值、选择器、属性、属性值 5 种类型。但其中属性值和变量可以合并成一类进行处理，为了方便后面语法分析，变量可以拆分成变量定义和变量引用。</p>
<p>由于缩进会对语法分析产生影响（样式规则缩进空格数决定了属于哪个选择器），所以也要加入令牌对象。</p>
<p>因此一个令牌对象结构如下，type 属性表示令牌类型，value 属性存储令牌字符内容，indent 属性记录缩进空格数：</p>
<pre><code data-language="typescript" class="lang-typescript">&#123;
&nbsp; <span class="hljs-keyword">type</span>: <span class="hljs-string">"variableDef"</span> | <span class="hljs-string">"variableRef"</span> | <span class="hljs-string">"selector"</span> | <span class="hljs-string">"property"</span> | <span class="hljs-string">"value"</span>, <span class="hljs-comment">//枚举值，分别对应变量定义、变量引用、选择器、属性、值</span>
&nbsp; value: <span class="hljs-built_in">string</span>, <span class="hljs-comment">// token字符值，即被分解的字符串</span>
&nbsp; indent: <span class="hljs-built_in">number</span> <span class="hljs-comment">// 缩进空格数，需要根据它判断从属关系</span>
&#125;
</code></pre>
<p>然后确定各种类型令牌的判断条件：</p>
<ul>
<li><strong>variableDef</strong>，以“$”符号开头，该行前面无其他非空字符串；</li>
<li><strong>variableRef</strong>，以“$”符号开头，该行前面有非空字符串；</li>
<li><strong>selector</strong>，独占一行，该行无其他非空字符串；</li>
<li><strong>property</strong>，以字母开头，该行前面无其他非空字符串；</li>
<li><strong>value</strong>，非该行第一个字符串，且该行第一个字符串为 property 或 variableDef 类型。</li>
</ul>
<p>最后再来确定令牌解析方式。</p>
<p>一般进行词法解析的时候，可以逐个字符进行解析判断，但考虑到源代码语法的特殊性——换行符和空格缩进会影响语法解析，所以可以考虑逐行逐个单词进行解析。</p>
<p>词法分析代码如下所示：</p>
<pre><code data-language="javascript" class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span>&nbsp;<span class="hljs-title">tokenize</span>(<span class="hljs-params">text</span>)&nbsp;</span>&#123;
&nbsp;&nbsp;<span class="hljs-keyword">return</span>&nbsp;text.trim().split(<span class="hljs-regexp">/\n|\r\n/</span>).reduce(<span class="hljs-function">(<span class="hljs-params">tokens,&nbsp;line,&nbsp;idx</span>)&nbsp;=&gt;</span>&nbsp;&#123;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span>&nbsp;spaces&nbsp;=&nbsp;line.match(<span class="hljs-regexp">/^\s+/</span>)&nbsp;||&nbsp;[<span class="hljs-string">''</span>]
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span>&nbsp;indent&nbsp;=&nbsp;spaces[<span class="hljs-number">0</span>].length
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span>&nbsp;input&nbsp;=&nbsp;line.trim()
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span>&nbsp;words&nbsp;=&nbsp;input.split(<span class="hljs-regexp">/\s/</span>)
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">let</span>&nbsp;value&nbsp;=&nbsp;words.shift()
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">if</span>&nbsp;(words.length&nbsp;===&nbsp;<span class="hljs-number">0</span>)&nbsp;&#123;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tokens.push(&#123;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">type</span>:&nbsp;<span class="hljs-string">'selector'</span>,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;value,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;indent
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#125;)
&nbsp;&nbsp;&nbsp;&nbsp;&#125;&nbsp;<span class="hljs-keyword">else</span>&nbsp;&#123;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">let</span>&nbsp;type&nbsp;=&nbsp;<span class="hljs-string">''</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">if</span>&nbsp;(<span class="hljs-regexp">/^\$/</span>.test(value))&nbsp;&#123;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type&nbsp;=&nbsp;<span class="hljs-string">'variableDef'</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#125;&nbsp;<span class="hljs-keyword">else</span>&nbsp;<span class="hljs-keyword">if</span>&nbsp;(<span class="hljs-regexp">/^[a-zA-Z-]+$/</span>.test(value))&nbsp;&#123;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type&nbsp;=&nbsp;<span class="hljs-string">'property'</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#125;&nbsp;<span class="hljs-keyword">else</span>&nbsp;&#123;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">throw</span>&nbsp;<span class="hljs-keyword">new</span>&nbsp;<span class="hljs-built_in">Error</span>(<span class="hljs-string">`Tokenize&nbsp;error:Line&nbsp;<span class="hljs-subst">$&#123;idx&#125;</span>&nbsp;"<span class="hljs-subst">$&#123;value&#125;</span>"&nbsp;is&nbsp;not&nbsp;a&nbsp;vairable&nbsp;or&nbsp;property!`</span>)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#125;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tokens.push(&#123;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;value,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;indent
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#125;)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">while</span>&nbsp;(value&nbsp;=&nbsp;words.shift())&nbsp;&#123;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tokens.push(&#123;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">type</span>:&nbsp;<span class="hljs-regexp">/^\$/</span>.test(value)&nbsp;?&nbsp;<span class="hljs-string">'variableRef'</span>&nbsp;:&nbsp;<span class="hljs-string">'value'</span>,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;value,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">indent</span>:&nbsp;<span class="hljs-number">0</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#125;)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#125;
&nbsp;&nbsp;&nbsp;&nbsp;&#125;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span>&nbsp;tokens;
&nbsp;&nbsp;&#125;,&nbsp;[])
&#125;
</code></pre>
<h4>语法分析</h4>
<p>现在我们来分析如何将上一步生成的令牌数组转化成抽象语法树，树结构相对于数组而言，最大的特点是具有层级关系，哪些令牌具有层级关系呢？</p>
<p>从缩进中不难看出，选择器与选择器、选择器与属性都存在层级关系，那么我们可以分别通过 <strong>children 属性和 rules 属性</strong>来描述这两类层级关系。</p>
<p>要判断层级关系需要借助缩进空格数，所以节点需要增加一个属性 indent。</p>
<p>考虑到构建树时可能会产生回溯，那么可以设置一个数组来记录当前构建路径。当遇到非父子关系的节点时，沿着当前路径往上找到其父节点。</p>
<p>最后为了简化树结构，这一步也可以将变量值进行替换，从而减少变量节点。</p>
<p>所以抽象语法树可以写成如下结构。首先定义一个根节点，在其 children 属性中添加选择器节点，选择器节点相对令牌而言增加了 2 个属性：</p>
<ul>
<li><strong>rules</strong>，存储当前选择器的样式属性和值组成的对象，其中值以字符串数组的形式存储；</li>
<li><strong>children</strong>，子选择器节点。</li>
</ul>
<pre><code data-language="javascript" class="lang-javascript">&#123;
&nbsp;&nbsp;<span class="hljs-attr">type</span>:&nbsp;<span class="hljs-string">'root'</span>,
&nbsp;&nbsp;<span class="hljs-attr">children</span>:&nbsp;[&#123;
  &nbsp;&nbsp;<span class="hljs-attr">type</span>:&nbsp;<span class="hljs-string">'selector'</span>,
    <span class="hljs-attr">value</span>: string
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">rules</span>:&nbsp;[&#123;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">property</span>:&nbsp;string,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">value</span>:&nbsp;string[],
&nbsp;&nbsp;&nbsp;&nbsp;&#125;],
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">indent</span>:&nbsp;number,
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">children</span>:&nbsp;[]
&nbsp;&nbsp;&#125;]
&#125;
</code></pre>
<p>由于考虑到一个属性的值可能会由多个令牌组成，比如 border 属性的值由“1px” “solid” “$borderColor” 3 个令牌组成，所以将 value 属性设置为字符串数组。</p>
<p>语法分析代码如下所示。首先定义一个根节点，然后按照先进先出的方式遍历令牌数组，遇到变量定义时，将变量名和对应的值存入到缓存对象中；当遇到属性时，插入到当前选择器节点的 rules 属性中，遇到值和变量引用时都将插入到当前选择器节点 rules 属性数组最后一个对象的 value 数组中，但是变量引用在插入之前需要借助缓存对象的变量值进行替换。当遇到选择器节点时，则需要往对应的父选择器节点 children 属性中插入，并将指针指向被插入的节点，同时记得将被插入的节点添加到用于存储遍历路径的数组中：</p>
<pre><code data-language="javascript" class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span>&nbsp;<span class="hljs-title">parse</span>(<span class="hljs-params">tokens</span>)&nbsp;</span>&#123;
&nbsp;&nbsp;<span class="hljs-keyword">var</span>&nbsp;ast&nbsp;=&nbsp;&#123;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">type</span>:&nbsp;<span class="hljs-string">'root'</span>,
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">children</span>:&nbsp;[],
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">indent</span>:&nbsp;<span class="hljs-number">-1</span>
&nbsp;&nbsp;&#125;;
&nbsp;&nbsp;<span class="hljs-keyword">let</span>&nbsp;path&nbsp;=&nbsp;[ast]
&nbsp;&nbsp;<span class="hljs-keyword">let</span>&nbsp;preNode&nbsp;=&nbsp;ast
&nbsp;&nbsp;<span class="hljs-keyword">let</span>&nbsp;node
&nbsp;&nbsp;<span class="hljs-keyword">let</span>&nbsp;vDict&nbsp;=&nbsp;&#123;&#125;
&nbsp;&nbsp;<span class="hljs-keyword">while</span>&nbsp;(node&nbsp;=&nbsp;tokens.shift())&nbsp;&#123;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">if</span>&nbsp;(node.type&nbsp;===&nbsp;<span class="hljs-string">'variableDef'</span>)&nbsp;&#123;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">if</span>&nbsp;(tokens[<span class="hljs-number">0</span>]&nbsp;&amp;&amp;&nbsp;tokens[<span class="hljs-number">0</span>].type&nbsp;===&nbsp;<span class="hljs-string">'value'</span>)&nbsp;&#123;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span>&nbsp;vNode&nbsp;=&nbsp;tokens.shift()
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vDict[node.value]&nbsp;=&nbsp;vNode.value
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#125;&nbsp;<span class="hljs-keyword">else</span>&nbsp;&#123;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;preNode.rules[preNode.rules.length&nbsp;-&nbsp;<span class="hljs-number">1</span>].value&nbsp;=&nbsp;vDict[node.value]
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#125;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">continue</span>;
&nbsp;&nbsp;&nbsp;&nbsp;&#125;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">if</span>&nbsp;(node.type&nbsp;===&nbsp;<span class="hljs-string">'property'</span>)&nbsp;&#123;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">if</span>&nbsp;(node.indent&nbsp;&gt;&nbsp;preNode.indent)&nbsp;&#123;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;preNode.rules.push(&#123;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">property</span>:&nbsp;node.value,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">value</span>:&nbsp;[]
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#125;)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#125;&nbsp;<span class="hljs-keyword">else</span>&nbsp;&#123;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">let</span>&nbsp;parent&nbsp;=&nbsp;path.pop()
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">while</span>&nbsp;(node.indent&nbsp;&lt;=&nbsp;parent.indent)&nbsp;&#123;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parent&nbsp;=&nbsp;path.pop()
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#125;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parent.rules.push(&#123;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">property</span>:&nbsp;node.value,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">value</span>:&nbsp;[]
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#125;)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;preNode&nbsp;=&nbsp;parent
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;path.push(parent)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#125;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">continue</span>;
&nbsp;&nbsp;&nbsp;&nbsp;&#125;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">if</span>&nbsp;(node.type&nbsp;===&nbsp;<span class="hljs-string">'value'</span>)&nbsp;&#123;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">try</span>&nbsp;&#123;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;preNode.rules[preNode.rules.length&nbsp;-&nbsp;<span class="hljs-number">1</span>].value.push(node.value);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#125;&nbsp;<span class="hljs-keyword">catch</span>&nbsp;(e)&nbsp;&#123;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-built_in">console</span>.error(preNode)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#125;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">continue</span>;
&nbsp;&nbsp;&nbsp;&nbsp;&#125;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">if</span>&nbsp;(node.type&nbsp;===&nbsp;<span class="hljs-string">'variableRef'</span>)&nbsp;&#123;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;preNode.rules[preNode.rules.length&nbsp;-&nbsp;<span class="hljs-number">1</span>].value.push(vDict[node.value]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">continue</span>;
&nbsp;&nbsp;&nbsp;&nbsp;&#125;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">if</span>&nbsp;(node.type&nbsp;===&nbsp;<span class="hljs-string">'selector'</span>)&nbsp;&#123;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span>&nbsp;item&nbsp;=&nbsp;&#123;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">type</span>:&nbsp;<span class="hljs-string">'selector'</span>,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">value</span>:&nbsp;node.value,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">indent</span>:&nbsp;node.indent,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">rules</span>:&nbsp;[],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">children</span>:&nbsp;[]
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#125;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">if</span>&nbsp;(node.indent&nbsp;&gt;&nbsp;preNode.indent)&nbsp;&#123;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;path[path.length&nbsp;-&nbsp;<span class="hljs-number">1</span>].indent&nbsp;===&nbsp;node.indent&nbsp;&amp;&amp;&nbsp;path.pop()
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;path.push(item)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;preNode.children.push(item);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;preNode&nbsp;=&nbsp;item;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#125;&nbsp;<span class="hljs-keyword">else</span>&nbsp;&#123;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">let</span>&nbsp;parent&nbsp;=&nbsp;path.pop()
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">while</span>&nbsp;(node.indent&nbsp;&lt;=&nbsp;parent.indent)&nbsp;&#123;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parent&nbsp;=&nbsp;path.pop()
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#125;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parent.children.push(item)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;path.push(item)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#125;
&nbsp;&nbsp;&nbsp;&nbsp;&#125;
&nbsp;&nbsp;&#125;
&nbsp;&nbsp;<span class="hljs-keyword">return</span>&nbsp;ast;
&#125;
</code></pre>
<h4>转换</h4>
<p>在转换之前我们先来看看要生成的目标代码结构，其更像是一个由一条条样式规则组成的数组，所以我们考虑将抽象语法树转换成“抽象语法数组”。</p>
<p>在遍历树节点时，需要记录当前遍历路径，以方便选择器的拼接；同时可以考虑将“值”类型的节点拼接在一起。最后形成下面的数组结构，数组中每个元素对象包括两个属性，selector 属性值为当前规则的选择器，rules 属性为数组，数组中每个元素对象包含 property 和 value 属性：</p>
<pre><code data-language="css" class="lang-css">&#123;
 &nbsp;<span class="hljs-attribute">selector</span>: string,
 &nbsp;rules: &#123;
 &nbsp; &nbsp;property: string,
 &nbsp; &nbsp;value: string
 &nbsp;&#125;<span class="hljs-selector-attr">[]</span>
&#125;<span class="hljs-selector-attr">[]</span>
</code></pre>
<p>具体代码实现如下，递归遍历抽象语法树，遍历的时候完成选择器拼接以及属性值的拼接，最终返回一个与 CSS 样式规则相对应的数组：</p>
<pre><code data-language="javascript" class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span>&nbsp;<span class="hljs-title">transform</span>(<span class="hljs-params">ast</span>)&nbsp;</span>&#123;
&nbsp;&nbsp;<span class="hljs-keyword">let</span>&nbsp;newAst&nbsp;=&nbsp;[];
&nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">function</span>&nbsp;<span class="hljs-title">traverse</span>(<span class="hljs-params">node,&nbsp;result,&nbsp;prefix</span>)&nbsp;</span>&#123;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">let</span>&nbsp;selector&nbsp;=&nbsp;<span class="hljs-string">''</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">if</span>&nbsp;(node.type&nbsp;===&nbsp;<span class="hljs-string">'selector'</span>)&nbsp;&#123;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;selector&nbsp;=&nbsp;[...prefix,&nbsp;node.value];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result.push(&#123;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">selector</span>:&nbsp;selector.join(<span class="hljs-string">'&nbsp;'</span>),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">rules</span>:&nbsp;node.rules.reduce(<span class="hljs-function">(<span class="hljs-params">acc,&nbsp;rule</span>)&nbsp;=&gt;</span>&nbsp;&#123;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;acc.push(&#123;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">property</span>:&nbsp;rule.property,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">value</span>:&nbsp;rule.value.join(<span class="hljs-string">'&nbsp;'</span>)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#125;)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span>&nbsp;acc;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#125;,&nbsp;[])
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#125;)
&nbsp;&nbsp;&nbsp;&nbsp;&#125;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">for</span>&nbsp;(<span class="hljs-keyword">let</span>&nbsp;i&nbsp;=&nbsp;<span class="hljs-number">0</span>;&nbsp;i&nbsp;&lt;&nbsp;node.children.length;&nbsp;i++)&nbsp;&#123;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;traverse(node.children[i],&nbsp;result,&nbsp;selector)
&nbsp;&nbsp;&nbsp;&nbsp;&#125;
&nbsp;&nbsp;&#125;
&nbsp;&nbsp;traverse(ast,&nbsp;newAst,&nbsp;[])
&nbsp;&nbsp;<span class="hljs-keyword">return</span>&nbsp;newAst;
&#125;
</code></pre>
<p>实现方式比较简单，通过函数递归遍历树，然后重新拼接选择器和属性的值，最终返回数组结构。</p>
<h4>代码生成</h4>
<p>有了新的“抽象语法数组”，生成目标代码就只需要通过 map 操作对数组进行遍历，然后将选择器、属性、值拼接成字符串返回即可。</p>
<p>具体代码如下：</p>
<pre><code data-language="javascript" class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span>&nbsp;<span class="hljs-title">generate</span>(<span class="hljs-params">nodes</span>)&nbsp;</span>&#123;
&nbsp;&nbsp;<span class="hljs-keyword">return</span>&nbsp;nodes.map(<span class="hljs-function"><span class="hljs-params">n</span>&nbsp;=&gt;</span>&nbsp;&#123;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">let</span>&nbsp;rules&nbsp;=&nbsp;n.rules.reduce(<span class="hljs-function">(<span class="hljs-params">acc,&nbsp;item</span>)&nbsp;=&gt;</span>&nbsp;acc&nbsp;+=&nbsp;<span class="hljs-string">`<span class="hljs-subst">$&#123;item.property&#125;</span>:<span class="hljs-subst">$&#123;item.value&#125;</span>;`</span>,&nbsp;<span class="hljs-string">''</span>)
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span>&nbsp;<span class="hljs-string">`<span class="hljs-subst">$&#123;n.selector&#125;</span>&nbsp;&#123;<span class="hljs-subst">$&#123;rules&#125;</span>&#125;`</span>
&nbsp;&nbsp;&#125;).join(<span class="hljs-string">'\n'</span>)
&#125;
</code></pre>
<h3>总结</h3>
<p>这一课时动手实践了一个简单的 CSS 预处理器，希望你能更好地掌握 CSS 工具预处理器的基本原理，同时也希望通过这个实现过程带你跨入编译器的大门。编译器属于大家日用而不知的重要工具，像 webpack、Babel这些著名工具以及 JavaScript 引擎都用到了它。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/yalishizhude/course/blob/master/plus1/pre.js">完整代码地址</a></p>
<p>最后布置一道思考题：你能否为预处理器添加一些其他功能呢（比如局部变量）？</p>

<hr>
<h3 id="精选评论"><a href="#精选评论" class="headerlink" title="精选评论"></a>精选评论</h3><h5 id="月："><a href="#月：" class="headerlink" title="*月："></a>*月：</h5><blockquote>
<p>你说这个棒不棒😉😉😉😉</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/11/02/%E6%89%8B%E5%86%99-CSS-%E9%A2%84%E5%A4%84%E7%90%86/" data-id="claxeera4001av8w146gof13m" data-title="手写 CSS 预处理" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-如何管理你的-CSS-代码？" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/11/02/%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E4%BD%A0%E7%9A%84-CSS-%E4%BB%A3%E7%A0%81%EF%BC%9F/" class="article-date">
  <time class="dt-published" datetime="2022-11-02T02:58:40.000Z" itemprop="datePublished">2022-11-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/11/02/%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E4%BD%A0%E7%9A%84-CSS-%E4%BB%A3%E7%A0%81%EF%BC%9F/">如何管理你的 CSS 代码？</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>上一课时我们从技术细节的角度分析了 CSS 布局的相关内容。这一课时我们提升一下思考维度，从组织管理的角度探讨如何管理好项目中的 CSS 代码。</p>
<p>接下来我们先解决 CSS 原生语法未能很好实现的模块化和作用域的问题，然后再对代码结构进行优化，提升代码的复用率。</p>
<h3>如何组织样式文件</h3>
<p>尽管 CSS 提供了 import 命令支持文件引用，但由于其存在一些问题（比如影响浏览器并行下载、加载顺序错乱等）导致使用率极低。更常见的做法是通过预处理器或编译工具插件来引入样式文件，因此本课时的讨论将不局限于以 .css 为后缀的样式文件。</p>
<p><strong>管理样式文件的目的就是为了让开发人员更方便地维护代码。</strong></p>
<p>具体来说就是将样式文件进行分类，把相关的文件放在一起。让工程师在修改样式的时候更容易找到对应的样式文件，在创建样式文件的时候更容易找到对应的目录。</p>
<p>下面我们来看看热门的开源项目都是怎么来管理样式文件的。</p>
<h4>开源项目中的样式文件</h4>
<p>我们先来看看著名的 UI 相关的开源项目是怎么管理样式文件的。</p>
<p>以 <a target="_blank" rel="noopener" href="https://github.com/twbs/bootstrap">Bootstrap 4.4</a> 为例，下图是项目样式代码结构，可以看出项目使用的是 Sass 预处理器。</p>
<p><img src="https://s0.lgstatic.com/i/image/M00/11/12/Ciqc1F7Lg2KAL_EGAABIIQsIyiQ803.png" alt="image (9).png"></p>
<p>该目录包括了 5 个目录、组件样式文件和一些全局样式。再来分析下目录及内容：</p>
<ul>
<li>forms/，表单组件相关样式；</li>
<li>helpers/，公共样式，包括定位、清除等；</li>
<li>mixins/，可以理解为生成最终样式的函数；</li>
<li>utilities/，媒体查询相关样式；</li>
<li>vendor/，依赖的外部第三方样式。</li>
</ul>
<p>根目录存放了组件样式文件和目录，其他样式文件放在不同的目录中。目录中的文件分类清晰，但目录结构相对于大多数实际项目而言过于简单（只有样式文件）。</p>
<p>我们再来看一个更符合大多数情况的开源项目 <a target="_blank" rel="noopener" href="https://github.com/ant-design/ant-design/">ant-design 4.2</a>，该项目采用 Less 预处理器，主要源码放在 /components 目录下：</p>
<p><img src="https://s0.lgstatic.com/i/image/M00/11/1D/CgqCHl7Lg2qAA71pAAA-LE1MpA8895.png" alt="image (10).png"></p>
<p>从目录名称上不难猜测，各个组件代码通过文件夹区分，点击其中的 alert 文件夹查看也确实如此，组件相关的代码、测试代码、demo 示例、样式文件、描述文档都在里面。</p>
<p><img src="https://s0.lgstatic.com/i/image/M00/11/12/Ciqc1F7Lg3KACdLvAAAhZ58r7rs506.png" alt="image (11).png"></p>
<p>至于全局样式和公共样式则在 /components/style 目录下：</p>
<p><img src="https://s0.lgstatic.com/i/image/M00/11/1D/CgqCHl7Lg3iAW5XnAABJl9DhW5U953.png" alt="image (12).png"></p>
<p>其中包括 4 个目录：</p>
<ul>
<li>color/，颜色相关的变量与函数；</li>
<li>core/，全局样式，根标签样式、字体样式等；</li>
<li>mixins/，样式生成函数；</li>
<li>themes/，主题相关的样式变量。</li>
</ul>
<p>将组件代码及相关样式放在一起，开发的时候修改会很方便。 但在组件目录 /comnponents 下设置 style 目录存放全局和公共样式，在逻辑上就有些说不通了，这些“样式”文件并不是一个单独的“组件”。再看 style 目录内部结构，相对于设置单独的 color 目录来管理样式中的颜色，更推荐像 Bootstrap 一样设立专门的目录或文件来管理变量。</p>
<p>最后来看看依赖 Vue.js 实现的热门 UI 库 <a target="_blank" rel="noopener" href="https://github.com/ElemeFE/element">element 2.13.1</a> 的目录结构。项目根路径下的 packages 目录按组件划分目录来存放其源码，但和 ant-design 不同的是，组件样式文件并没有和组件代码放在一起。下图是 /packages 目录下的部分内容。</p>
<p><img src="https://s0.lgstatic.com/i/image/M00/11/1D/CgqCHl7Lg4GALTUpAAA1dlUb1Vo822.png" alt="image (13).png"></p>
<p>element 将样式文件统一放入了 /packages/theme-chalk 目录下，目录部分内容如下图所示：</p>
<p><img src="https://s0.lgstatic.com/i/image/M00/11/12/Ciqc1F7Lg4iAEEjuAABKZlcUAZw345.png" alt="image (14).png"></p>
<p>其中包含 4 个目录：</p>
<ul>
<li>common/，一些全局样式和公共变量；</li>
<li>date-picker/，日期组件相关样式；</li>
<li>fonts/，字体文件；</li>
<li>mixins/，样式生成函数及相关变量。</li>
</ul>
<p>和 antd 有同样的问题，把样式当成“组件”看待，组件同级目录设立了 theme-chalk 目录存放样式文件。theme-chalk 目录下的全局样式 reset.scss 与组件样式同级，这也有些欠妥。这种为了将样式打包成模块，在独立项目中直接嵌入另一个独立项目（可以简单理解为一个项目不要有多个 package.json 文件）并不推荐，更符合 Git 使用规范的做法，即是以<a target="_blank" rel="noopener" href="https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E5%AD%90%E6%A8%A1%E5%9D%97">子模块</a>的方式引用进项目。 而且将组件样式和源码分离这种方式开发的时候也不方便，经常需要跨多层目录查找和修改样式。</p>
<h4>样式文件管理模式</h4>
<p>除了开源项目之外，<a target="_blank" rel="noopener" href="https://sass-guidelin.es/#architecture">Sass Guidelines</a> 曾经提出过一个用来划分样式文件目录结构的 7-1 模式也很有参考意义。这种模式建议将目录结构划分为 7 个目录和 1 个文件，这 1 个文件是样式的入口文件，它会将项目所用到的所有样式都引入进来，一般命名为 main.scss。</p>
<p>剩下的 7 个目录及作用如下：</p>
<ul>
<li>base/，模板代码，比如默认标签样式重置；</li>
<li>components/，组件相关样式；</li>
<li>layout/，布局相关，包括头部、尾部、导航栏、侧边栏等；</li>
<li>pages/，页面相关样式；</li>
<li>themes/，主题样式，即使有的项目没有多个主题，也可以进行预留；</li>
<li>abstracts/，其他样式文件生成的依赖函数及 mixin，不能直接生成 css 样式；</li>
<li>vendors/，第三方样式文件。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://github.com/HugoGiraudel/sass-boilerplate">点击这里获取示例项目地址</a>，截图如下图所示：</p>
<p><img src="https://s0.lgstatic.com/i/image/M00/11/12/Ciqc1F7Lg5CAFS5jAAB-ZPy2xPc135.png" alt="image (15).png"></p>
<p>由于这个划分模式是专门针对使用 Sass 项目提出的，从样式文件名称看出还留有 jQuery 时代的影子，为了更加符合单页应用的项目结构，我们可以稍作优化。</p>
<ul>
<li>main.scss 文件存在意义不大，页面样式、组件样式、布局样式都可以在页面和组件中引用，全局样式也可以在根组件中引用。而且每次添加、修改样式文件都需要在 main.scss 文件中同步，这种过度中心化的配置方式也不方便。</li>
<li>layout 目录也可以去除，因为像 footer、header 这些布局相关的样式，放入对应的组件中来引用会更好，至于不能被组件化的“_grid”样式存在性也不大。因为对于页面布局，既可以通过下面介绍的方法来拆分成全局样式，也可以依赖第三方 UI 库来实现。所以说这个目录可以去除。</li>
<li>themes/ 目录也可以去除，毕竟大部分前端项目是不需要设置主题的，即使有主题也可以新建一个样式文件来管理样式变量。</li>
<li>vendors/ 目录可以根据需求添加。因为将外部样式复制到项目中的情况比较少，更多的是通过 npm 来安装引入 UI 库或者通过 webpack 插件来写入对应的 cdn 地址。</li>
</ul>
<p>所以优化后的目录结构如下所示：</p>
<pre><code data-language="java" class="lang-java">src/
|
|– abstracts/
|&nbsp; &nbsp;|– _variables.scss&nbsp; &nbsp;&nbsp;
|&nbsp; &nbsp;|– _functions.scss&nbsp; &nbsp;&nbsp;
|&nbsp; &nbsp;|– _mixins.scss&nbsp; &nbsp; &nbsp; &nbsp;
|&nbsp; &nbsp;|– _placeholders.scss&nbsp;
|
|– base/
|&nbsp; &nbsp;|– _reset.scss&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;
|&nbsp; &nbsp;|– _typography.scss&nbsp; &nbsp;
|&nbsp; &nbsp;…&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
|
|– components/
|&nbsp; &nbsp;|– _buttons.scss&nbsp; &nbsp; &nbsp;&nbsp;
|&nbsp; &nbsp;|– _carousel.scss&nbsp; &nbsp; &nbsp;
|&nbsp; &nbsp;|– _cover.scss&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;
|&nbsp; &nbsp;|– _dropdown.scss&nbsp; &nbsp; &nbsp;
|&nbsp; &nbsp;|- header/
|&nbsp; &nbsp; &nbsp; |- header.tsx
|&nbsp; &nbsp; &nbsp; |- header.sass
|&nbsp; &nbsp;|- footer/
|&nbsp; &nbsp; &nbsp; |- footer.tsx
|&nbsp; &nbsp; &nbsp; |- footer.sass
|&nbsp; &nbsp;…&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
|
|– pages/
|&nbsp; &nbsp;|– _home.scss&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
|&nbsp; &nbsp;|– _contact.scss&nbsp; &nbsp; &nbsp;&nbsp;
|&nbsp; &nbsp;…&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
|
</code></pre>
<p>这只是推荐的一种目录结构，具体使用可以根据实际情况进行调整。比如我在项目的 src 目录下创建了模块目录，按照模块来拆分路由以及页面、组件，所以每个模块目录下都会有 pages/ 目录和 components/ 目录。</p>
<h3>如何避免样式冲突</h3>
<p>由于 CSS 的规则是全局的，任何一个样式规则，都对整个页面有效，所以如果不对选择器的命名加以管控会很容易产生冲突。</p>
<h4>手动命名</h4>
<p>最简单有效的命名管理方式就是制定一些命名规则，比如 <a target="_blank" rel="noopener" href="http://oocss.org/">OOCSS</a>、<a target="_blank" rel="noopener" href="http://getbem.com/">BEM</a>、<a target="_blank" rel="noopener" href="https://amcss.github.io/">AMCSS</a>，其中推荐比较常用的 BEM。</p>
<p>这里简单补充一下 BEM 相关知识，熟悉 BEM 的可以直接跳过。</p>
<p>BEM 是 Block、Element、Modifier 三个单词的缩写，Block 代表独立的功能组件，Element 代表功能组件的一个组成部分，Modifier 对应状态信息。</p>
<p>下图是官方给出的示例代码：</p>
<p><img src="https://s0.lgstatic.com/i/image/M00/11/1E/CgqCHl7Lg5qAeYYDAAA8eZ2PEKM297.png" alt="image (16).png"></p>
<p>从命名可以看到 Element 和 Modifier 是可选的，各个单词通过双横线（也可以用双下划线）连接（双横线虽然能和单词的连字符进行区分，但确实有些冗余，可以考虑直接用下划线代替）。BEM 的命名方式具有语义，很容易理解，非常适用于组件样式类。</p>
<h4>工具命名</h4>
<p>通过命名规范来避免冲突的方式固然是好的，但这种规范约束也不能绝对保证样式名的唯一性，而且也没有有效的校验工具来保证命名正确无冲突。所以，聪明的开发者想到了通过插件将原命名转化成不重复的随机命名，从根本上避免命名冲突。比较著名的解决方案就是 CSS Modules。</p>
<p>下面是一段 css 样式代码：</p>
<pre><code data-language="css" class="lang-css"><span class="hljs-comment">/* style.css */</span>
<span class="hljs-selector-class">.className</span> &#123;
  <span class="hljs-attribute">color</span>: green;
&#125;
</code></pre>
<p>借助 css Modules 插件，可以将 css 以 JSON 对象的形式引用和使用。</p>
<pre><code data-language="javascript" class="lang-javascript"><span class="hljs-keyword">import</span> styles <span class="hljs-keyword">from</span> <span class="hljs-string">"./style.css"</span>;
<span class="hljs-comment">// import &#123; className &#125; from "./style.css";</span>
element.innerHTML = <span class="hljs-string">'&lt;div class="'</span> + styles.className + <span class="hljs-string">'"&gt;'</span>;
</code></pre>
<p>编译之后的代码，样式类名被转化成了随机名称：</p>
<pre><code data-language="xml" class="lang-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"_3zyde4l1yATCOkgn-DBWEL"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">
<span class="hljs-selector-class">._3zyde4l1yATCOkgn-DBWEL</span> &#123;
  <span class="hljs-attribute">color</span>: green;
&#125;
</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
</code></pre>
<p>但这种命名方式带来了一个问题，那就是如果想在引用组件的同时，覆盖它的样式会变得困难，因为编译后的样式名是随机。例如，在上面的示例代码中，如果想在另一个组件中覆盖 className 样式就很困难，而在手动命名情况下则可以直接重新定义 className 样式进行覆盖。</p>
<h3>如何高效复用样式</h3>
<p>如果你有一些项目开发经历，一定发现了某些样式会经常被重复使用，比如：</p>
<ul>
<li>display:inline-block</li>
<li>clear:both</li>
<li>position:relative</li>
<li>......</li>
</ul>
<p>这违背了 DRY（Don't Repeat Yourself）原则，完全可以通过设置为全局公共样式来减少重复定义。</p>
<p>哪些样式规则可以设置为全局公共样式呢？</p>
<ul>
<li>首先是具有枚举值的属性，除了上面提到的，还包括 cursor:pointer、float:left 等。</li>
<li>其次是那些特定数值的样式属性值，比如 margin: 0、left: 0、height: 100%。</li>
<li>最后是设计规范所使用的属性，比如设计稿中规定的几种颜色。</li>
</ul>
<p>样式按照小粒度拆分之后命名规范也很重要，合理的命名规范可以避免公共样式重复定义，开发时方便快速引用。</p>
<p>前面提到的语义化命名方式 BEM 显然不太适合。首先全局样式是基于样式属性和值的，是无语义的；其次对于这种复用率很高的样式应该尽量保证命名简短方便记忆，所以推荐使用更简短、更方便记忆的命名规则。比如我们团队所使用的就是“属性名首字母 + 横线 + 属性值首字母”的方式进行命名。</p>
<p>举个例子，比如对于 display:inline-block 的样式属性值，它的属性为“display”缩写为“d”，值为“inline-block”，缩写为“ib”，通过短横线连接起来就可以命名成“d-ib”；同样，如果工程师想设置一个 float:left 的样式，也很容易想到使用“f-l”的样式名。</p>
<p>那会不会出现重复定义呢？这个问题很好解决，按照字母序升序定义样式类就可以了。</p>
<h3>延伸：值得关注的 CSS in JavaScript</h3>
<p>我们都知道 Web 标准提倡结构、样式、行为分离（分别对应 HTML、CSS、JavaScript 三种语言），但 React.js 的一出现就开始颠覆了这个原则。</p>
<p>先是通过 JSX 将 HTML 代码嵌入进 JavaScript 组件，然后又通过 CSS in JavaScript 的方式将 CSS 代码也嵌入进 JavaScript 组件。这种“all in JavaScript”的方式确实有悖 Web 标准。但这种编写方式和日益盛行的组件化概念非常契合，具有“高内聚”的特性，所以未来标准有所改变也未尝不可能。这也正是我们需要关注 CSS in JavaScript 技术的原因。</p>
<p>相对于使用预处理语言编写样式，CSS in JavaScript 具有两个不那么明显的优势：</p>
<ul>
<li>可以通过随机命名解决作用域问题，但命名规则和 CSS Modules 都可以解决这个问题；</li>
<li>样式可以使用 JavaScript 语言特性，比如函数、循环，实现元素不同的样式效果可以通过新建不同样式类，修改元素样式类来实现。</li>
</ul>
<p>我们以 <a target="_blank" rel="noopener" href="https://styled-components.com/">styled-compoents</a> 为例进行说明，下面是示例代码，第一段是源代码：</p>
<pre><code data-language="javascript" class="lang-javascript"><span class="hljs-comment">// 源代码</span>
<span class="hljs-keyword">const</span> Button = styled.button<span class="hljs-string">`
  background: transparent;
  border-radius: 3px;
  border: 2px solid palevioletred;
  color: palevioletred;
  margin: 0.5em 1em;
  padding: 0.25em 1em;
  <span class="hljs-subst">$&#123;props =&gt; props.primary &amp;&amp; css`<span class="css">
    <span class="hljs-selector-tag">background</span>: <span class="hljs-selector-tag">palevioletred</span>;
    <span class="hljs-selector-tag">color</span>: <span class="hljs-selector-tag">white</span>;
  `</span>&#125;</span>
`</span>;
<span class="hljs-keyword">const</span> Container = styled.div<span class="hljs-string">`
  text-align: center;
`</span>
render(
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Container</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">Button</span>&gt;</span>Normal Button<span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">primary</span>&gt;</span>Primary Button<span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">Container</span>&gt;</span></span>
);
</code></pre>
<p>第二段是编译后生成的：</p>
<pre><code data-language="xml" class="lang-xml"><span class="hljs-comment">&lt;!--HTML 代码--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"sc-fzXfNJ ciXJHl"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"sc-fzXfNl hvaMnE"</span>&gt;</span>Normal Button<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"sc-fzXfNl kiyAbM"</span>&gt;</span>Primary Button<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
/*CSS 代码*/
.ciXJHl&nbsp;&#123;
  text-align: center;
&#125;
.hvaMnE&nbsp;&#123;
  color: palevioletred;
  background: transparent;
  border-radius: 3px;
  border-width: 2px;
  border-style: solid;
  border-color: palevioletred;
  border-image: initial;
  margin: 0.5em 1em;
  padding: 0.25em 1em;
&#125;
.kiyAbM&nbsp;&#123;
  color: white;
  border-radius: 3px;
  border-width: 2px;
  border-style: solid;
  border-color: palevioletred;
  border-image: initial;
  margin: 0.5em 1em;
  padding: 0.25em 1em;
  background: palevioletred;
&#125;
</code></pre>
<p>对比以上两段代码很容易发现，在编译后的样式代码中有很多重复的样式规则。这并不友好，不仅增加了编写样式的复杂度和代码量，连编译后也增加了冗余代码。</p>
<p>styled-components 只是 CSS in JavaScript 的一种解决方案，其他解决方案还有很多，<a target="_blank" rel="noopener" href="https://github.com/MicheleBertoli/css-in-js">有兴趣的</a><a target="_blank" rel="noopener" href="https://github.com/MicheleBertoli/css-in-js">同学</a><a target="_blank" rel="noopener" href="https://github.com/MicheleBertoli/css-in-js">可以点击这里查阅 GitHub 上的资料学习</a>，上面收录了现有的 CSS in JavaScript 解决方案。</p>
<h3>总结</h3>
<p>对于样式文件的管理，推荐使用 7-1 模式简化后的目录结构，包括 pages/、components/、abastracts/、base/ 4 个目录。对于样式命名，可以采用 BEM 来命名组件、面向属性的方式来命名公共样式。</p>
<p>最后留一道思考题：说说你在项目中是如何管理样式代码的？</p>

<hr>
<h3 id="精选评论"><a href="#精选评论" class="headerlink" title="精选评论"></a>精选评论</h3><h5 id="Mr-W："><a href="#Mr-W：" class="headerlink" title="Mr.W："></a>Mr.W：</h5><blockquote>
<p>在评价element的样式文件管理时说element的样式文件与组件文件分离这种方式开发的时候也不方便，经常需要跨多层目录查找和修改样式。但是，根据Sass Guidelines优化后得到的样式文件组织结构不也是与组件文件分离的吗？也会造成开发不方便的问题吧。期望能够得到回复与解答。</p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-讲师回复："><a href="#amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; 是样式与组件分离，同一个组件的样式与模板逻辑都会放在一起、不会出现跨目录层级查找的情况。<br>你说的开发方便是指“All in js“吗？<br>这种编写方式比较适用于小组件，一般情况下还是推荐按照 W3C 的规范，将组件的模板、逻辑和样式都分离开来。<br>一方面降低代码耦合度，另一方面也方便复用。</p>
</blockquote>
<h5 id="鑫："><a href="#鑫：" class="headerlink" title="**鑫："></a>**鑫：</h5><blockquote>
<p>我个人是使用boostrap的css库，直接才用多class并行 比如：最后一个放的是当前div的私有样式，个人认为，用这样写很快，也好维护，写div就把涉及重排的样式都写上，最后剩下的定制css就很少了 。缺点是很class很长，丑</p>
</blockquote>
<h5 id="Warn："><a href="#Warn：" class="headerlink" title="Warn："></a>Warn：</h5><blockquote>
<p>个人项目中样式还是偏向BEM命名多一些</p>
</blockquote>
<h5 id="威："><a href="#威：" class="headerlink" title="**威："></a>**威：</h5><blockquote>
<p>公共样式应放在哪个目录？</p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-1"><a href="#amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-1" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; 全局的公共样式可以放在  src&#x2F;base 目录哦~</p>
</blockquote>
<h5 id="其："><a href="#其：" class="headerlink" title="**其："></a>**其：</h5><blockquote>
<p>打卡！</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/11/02/%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E4%BD%A0%E7%9A%84-CSS-%E4%BB%A3%E7%A0%81%EF%BC%9F/" data-id="claxeera00011v8w12cylg2o6" data-title="如何管理你的 CSS 代码？" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/2/">&laquo; 上一页</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/4/">下一页 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/11/">十一月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">十月 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/11/26/%E4%B8%BA%E4%BB%80%E4%B9%88React16%E8%A6%81%E6%9B%B4%E6%94%B9%E7%BB%84%E4%BB%B6%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-%EF%BC%88%E4%B8%8B%EF%BC%89/">为什么React16要更改组件的生命周期?（下）</a>
          </li>
        
          <li>
            <a href="/2022/11/26/%E8%A6%81%E6%9B%B4%E6%94%B9%E7%BB%84%E4%BB%B6%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%9F%EF%BC%88%E4%B8%8A%EF%BC%89/">(no title)</a>
          </li>
        
          <li>
            <a href="/2022/11/26/%E4%BB%A3%E7%A0%81%E8%BD%ACdom/">代码转dom</a>
          </li>
        
          <li>
            <a href="/2022/11/26/React%E7%9F%A5%E8%AF%86%E9%93%BE/">React知识链</a>
          </li>
        
          <li>
            <a href="/2022/11/02/%E6%8E%92%E5%BA%8F%E2%80%9C/">排序“</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 XuJiaDi<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>