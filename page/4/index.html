<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>徐嘉迪的个人网站</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="没有永远的失败者，只有努力的成功者">
<meta property="og:type" content="website">
<meta property="og:title" content="徐嘉迪的个人网站">
<meta property="og:url" content="http://example.com/page/4/index.html">
<meta property="og:site_name" content="徐嘉迪的个人网站">
<meta property="og:description" content="没有永远的失败者，只有努力的成功者">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="XuJiaDi">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="徐嘉迪的个人网站" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">徐嘉迪的个人网站</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">没有永远的失败者，只有努力的成功者</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS 订阅"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-掌握-CSS-精髓：布局" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/11/02/%E6%8E%8C%E6%8F%A1-CSS-%E7%B2%BE%E9%AB%93%EF%BC%9A%E5%B8%83%E5%B1%80/" class="article-date">
  <time class="dt-published" datetime="2022-11-02T02:58:08.000Z" itemprop="datePublished">2022-11-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/11/02/%E6%8E%8C%E6%8F%A1-CSS-%E7%B2%BE%E9%AB%93%EF%BC%9A%E5%B8%83%E5%B1%80/">掌握 CSS 精髓：布局</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>CSS 虽然初衷是用来美化 HTML 文档的，但实际上随着 float、position 等属性的出现，它已经可以起到调整文档渲染结构的作用了，而随着弹性盒子以及网格布局的推出，CSS 将承担越来越重要的布局功能。渐渐地我们发现 HTML 标签决定了页面的逻辑结构，而 CSS 决定了页面的视觉结构。</p>
<p>这一课时我们先来分析常见的布局效果有哪些，然后再通过代码来实现这些效果，从而帮助你彻底掌握 CSS 布局。</p>
<p>我们通常提到的布局，有两个共同点：</p>
<ol>
<li>大多数用于 PC 端，因为 PC 端屏幕像素宽度够大，可布局的空间也大；</li>
<li>布局是有限空间内的元素排列方式，因为页面设计横向不滚动，纵向无限延伸，所以大多数时候讨论的布局都是对水平方向进行分割。</li>
</ol>
<p>实际上我们在讨论布局的时候，会把网页上特定的区域进行分列操作。按照分列数目，可以大致分为 3 类，即单列布局、2 列布局、3 列布局。</p>
<h4>单列布局</h4>
<p>单列布局是最常用的一种布局，它的实现效果就是将一个元素作为布局容器，通常设置一个较小的（最大）宽度来保证不同像素宽度屏幕下显示一致。</p>
<p><strong>示例网站</strong></p>
<p>拉勾，蓝色区域为布局容器，水平居中对齐，宽度 1260px：</p>
<p><img src="https://s0.lgstatic.com/i/image/M00/0E/02/Ciqc1F7E7naAWgsXAARfwy0XcV8278.png" alt="image001.png"></p>
<p>谷歌搜索，蓝色区域为布局容器，水平左对齐，宽度 652px：</p>
<p><img src="https://s0.lgstatic.com/i/image/M00/0E/0E/CgqCHl7E7oKAfb17AAFwoje2OMQ914.png" alt="image003.png"></p>
<p>一些网站会将单列布局与其他布局方式混合使用，比如拉勾网首页的海报和左侧标签就使用了 2 列布局，这样既能向下兼容窄屏幕，又能按照主次关系显示页面内容。</p>
<p>这种布局的优势在于基本上可以适配超过布局容器宽度的各种显示屏幕，比如上面的示例网站布局容器宽度为 700px，也就是说超过 700px 宽度的显示屏幕上浏览网站看到的效果是一致的。</p>
<p>但它最大的缺点也是源于此，过度的冗余设计必然会带来浪费。例如，在上面的例子中，其实我的屏幕宽度是足够的，可以显示更多的内容，但是页面两侧却出现了大量空白区域，如果在 4k 甚至更宽的屏幕下，空白区域大小会超过页面内容区域大小！</p>
<h4>2 列布局</h4>
<p>2 列布局使用频率也非常的高，实现效果就是将页面分割成左右宽度不等的两列，宽度较小的列设置为固定宽度，剩余宽度由另一列撑满。为了描述方便，我们暂且称宽度较小的列父元素为次要布局容器，宽度较大的列父元素为主要布局容器。</p>
<p><strong>示例网站</strong></p>
<p>Ant Design 文档，蓝色区域为主要内容布局容器，侧边栏为次要内容布局容器。</p>
<p><img src="https://s0.lgstatic.com/i/image/M00/0E/02/Ciqc1F7E7o2AW5gDAAE-NngMuFU998.png" alt="image005.png"></p>
<p>这种布局适用于内容上具有明显主次关系的网页，比如 API 文档页面中左侧显示内容导航，右侧显示文档描述；又比如后台管理系统中左侧显示菜单栏，右侧显示配置页面。相对于单列布局，在屏幕宽度适配方面处理得更好。当屏幕宽度不够时，主要内容布局容器优先显示，次要内容布局容器改为垂直方向显示或隐藏，但有时候也会和单列布局搭配使用，作为单列布局中的子布局使用。</p>
<h4>3 列布局</h4>
<p>3 列布局按照左中右的顺序进行排列，通常中间列最宽，左右两列次之。</p>
<p><strong>示例网站</strong></p>
<p>登录 GitHub 后，蓝色区域为宽度最大的中间列。</p>
<p><img src="https://s0.lgstatic.com/i/image/M00/0E/02/Ciqc1F7E7p2AMPNpAAG-acrwqPY708.png" alt="image007.png"></p>
<p>CSDN 首页，这是 3 列布局的第二种实现方式，蓝色部分就是 2 列布局的主要布局容器，而它的子元素又使用了 2 列布局。</p>
<p><img src="https://s0.lgstatic.com/i/image/M00/0E/0E/CgqCHl7E7qaAIc4DAAaJzemBURk917.png" alt="image009.png"></p>
<p>3 列布局和 2 列布局类似，也有明确的主次关系，只是关系层次增加了一层。下面我们来看看如何实现这些布局。</p>
<h4>布局实现</h4>
<p>单列布局没有太多技术难点，通过将设置布局容器（最大）宽度以及左右边距为 auto 即可实现，我们重点讨论 2 列和 3 列布局。关于这两种布局，在网上可以找到很多实现方式，我们是不是只要把这些方式收集起来然后都记住就行了呢？</p>
<p>当然不是！</p>
<p>我们要做的是通过归纳法，找到这些方式的共同实现步骤，只要把这些步骤记住了，就能做到举一反三。</p>
<p>你可以试着自己先整理一下，或者直接看我整理好的结果。</p>
<p>要实现 2 列布局或 3 列布局，可以按照下面的步骤来操作：</p>
<p>（1）为了保证主要布局容器优先级，应将主要布局容器写在次要布局容器之前。</p>
<p>（2）将布局容器进行水平排列；</p>
<p>（3）设置宽度，即次要容器宽度固定，主要容器撑满；</p>
<p>（4）消除布局方式的副作用，如浮动造成的高度塌陷；</p>
<p>（5）为了在窄屏下也能正常显示，可以通过媒体查询进行优化。</p>
<p>根据以上操作步骤，先来看一个使用 flex 布局实现 2 列布局的例子。</p>
<p>第 1 步，写好 HTML 结构。这里为了查看方便，我们为布局容器设置背景颜色和高度。</p>
<pre><code data-language="xml" class="lang-xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">
&nbsp;&nbsp;<span class="hljs-comment">/*&nbsp;为了方便查看，给布局容器设置高度和颜色&nbsp;*/</span>
&nbsp;&nbsp;<span class="hljs-selector-tag">main</span>,<span class="hljs-selector-tag">aside</span>&nbsp;&#123;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attribute">height</span>:&nbsp;<span class="hljs-number">100px</span>;
&nbsp;&nbsp;&#125;
&nbsp;&nbsp;<span class="hljs-selector-tag">main</span>&nbsp;&#123;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attribute">background-color</span>:&nbsp;<span class="hljs-number">#f09e5a</span>;
&nbsp;&nbsp;&#125;
&nbsp;&nbsp;<span class="hljs-selector-tag">aside</span>&nbsp;&#123;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attribute">background-color</span>:&nbsp;<span class="hljs-number">#c295cf</span>;
&nbsp;&nbsp;&#125;
</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
&nbsp;&nbsp;<span class="hljs-tag">&lt;<span class="hljs-name">main</span>&gt;</span>主要布局容器<span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span>
&nbsp;&nbsp;<span class="hljs-tag">&lt;<span class="hljs-name">aside</span>&gt;</span>次要布局容器<span class="hljs-tag">&lt;/<span class="hljs-name">aside</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre>
<p><img src="https://s0.lgstatic.com/i/image/M00/0E/0E/CgqCHl7E7smAEPRpAAAvxBH_FHc839.png" alt="image011.png"></p>
<p>第 2 步，将布局容器水平排列：</p>
<pre><code data-language="xml" class="lang-xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">
&nbsp;&nbsp;<span class="hljs-selector-class">.wrap</span>&nbsp;&#123;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attribute">display</span>:&nbsp;flex;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attribute">flex-direction</span>:&nbsp;row-reverse;
&nbsp;&nbsp;&#125;
&nbsp;&nbsp;<span class="hljs-selector-class">.main</span>&nbsp;&#123;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attribute">flex</span>:&nbsp;<span class="hljs-number">1</span>;
&nbsp;&nbsp;&#125;
&nbsp;&nbsp;<span class="hljs-selector-class">.aside</span>&nbsp;&#123;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attribute">flex</span>:&nbsp;<span class="hljs-number">1</span>;
&nbsp;&nbsp;&#125;
</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span>&nbsp;<span class="hljs-attr">class</span>=<span class="hljs-string">"wrap"</span>&gt;</span>
&nbsp;&nbsp;<span class="hljs-tag">&lt;<span class="hljs-name">main</span>&nbsp;<span class="hljs-attr">class</span>=<span class="hljs-string">"main"</span>&gt;</span>主要布局容器<span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span>
&nbsp;&nbsp;<span class="hljs-tag">&lt;<span class="hljs-name">aside</span>&nbsp;<span class="hljs-attr">class</span>=<span class="hljs-string">"aside"</span>&gt;</span>次要布局容器<span class="hljs-tag">&lt;/<span class="hljs-name">aside</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre>
<p><img src="https://s0.lgstatic.com/i/image/M00/0E/02/Ciqc1F7E7tOANF4CAAAvkbIVZBE683.png" alt="image013.png"></p>
<p>第 3 步，调整布局容器宽度：</p>
<pre><code data-language="xml" class="lang-xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">
&nbsp;&nbsp;<span class="hljs-selector-class">.wrap</span>&nbsp;&#123;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attribute">display</span>:&nbsp;flex;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attribute">flex-direction</span>:&nbsp;row-reverse;
&nbsp;&nbsp;&#125;
&nbsp;&nbsp;<span class="hljs-selector-class">.main</span>&nbsp;&#123;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attribute">flex</span>:&nbsp;<span class="hljs-number">1</span>;
&nbsp;&nbsp;&#125;
&nbsp;&nbsp;<span class="hljs-selector-class">.aside</span>&nbsp;&#123;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attribute">width</span>:&nbsp;<span class="hljs-number">200px</span>;
&nbsp;&nbsp;&#125;
</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span>&nbsp;<span class="hljs-attr">class</span>=<span class="hljs-string">"wrap"</span>&gt;</span>
&nbsp;&nbsp;<span class="hljs-tag">&lt;<span class="hljs-name">main</span>&nbsp;<span class="hljs-attr">class</span>=<span class="hljs-string">"main"</span>&gt;</span>主要布局容器<span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span>
&nbsp;&nbsp;<span class="hljs-tag">&lt;<span class="hljs-name">aside</span>&nbsp;<span class="hljs-attr">class</span>=<span class="hljs-string">"aside"</span>&gt;</span>次要布局容器<span class="hljs-tag">&lt;/<span class="hljs-name">aside</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre>
<p><img src="https://s0.lgstatic.com/i/image/M00/0E/0E/CgqCHl7E7t2ADHFHAAAwDrjM5WI921.png" alt="image015.png"></p>
<p>第 4 步，消除副作用，比如浮动造成的高度塌陷。由于使用 flex 布局没有副作用，所以不需要修改，代码和效果图同第 3 步。</p>
<p><img src="https://s0.lgstatic.com/i/image/M00/0E/03/Ciqc1F7E7uWAaUkVAAAv8s-Kzi4653.png" alt="image017.png"></p>
<p>第 5 步，增加媒体查询。</p>
<pre><code data-language="xml" class="lang-xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">
&nbsp;&nbsp;<span class="hljs-selector-class">.wrap</span>&nbsp;&#123;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attribute">display</span>:&nbsp;flex;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attribute">flex-direction</span>:&nbsp;row-reverse;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attribute">flex-wrap</span>:&nbsp;wrap;
&nbsp;&nbsp;&#125;
&nbsp;&nbsp;<span class="hljs-selector-class">.main</span>&nbsp;&#123;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attribute">flex</span>:&nbsp;<span class="hljs-number">1</span>;
&nbsp;&nbsp;&#125;
&nbsp;&nbsp;<span class="hljs-selector-class">.aside</span>&nbsp;&#123;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attribute">width</span>:&nbsp;<span class="hljs-number">200px</span>;
&nbsp;&nbsp;&#125;
&nbsp;&nbsp;<span class="hljs-keyword">@media</span>&nbsp;<span class="hljs-keyword">only</span>&nbsp;screen&nbsp;<span class="hljs-keyword">and</span>&nbsp;(<span class="hljs-attribute">max-width:</span>&nbsp;<span class="hljs-number">1000px</span>)&nbsp;&#123;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-selector-class">.wrap</span>&nbsp;&#123;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attribute">flex-direction</span>:&nbsp;row;
&nbsp;&nbsp;&nbsp;&nbsp;&#125;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-selector-class">.main</span>&nbsp;&#123;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attribute">flex</span>:&nbsp;<span class="hljs-number">100%</span>;
&nbsp;&nbsp;&nbsp;&nbsp;&#125;
&nbsp;&nbsp;&#125;
</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span>&nbsp;<span class="hljs-attr">class</span>=<span class="hljs-string">"wrap"</span>&gt;</span>
&nbsp;&nbsp;<span class="hljs-tag">&lt;<span class="hljs-name">main</span>&nbsp;<span class="hljs-attr">class</span>=<span class="hljs-string">"main"</span>&gt;</span>主要布局容器<span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span>
&nbsp;&nbsp;<span class="hljs-tag">&lt;<span class="hljs-name">aside</span>&nbsp;<span class="hljs-attr">class</span>=<span class="hljs-string">"aside"</span>&gt;</span>次要布局容器<span class="hljs-tag">&lt;/<span class="hljs-name">aside</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre>
<p><img src="https://s0.lgstatic.com/i/image/M00/0E/03/Ciqc1F7E7vOAaoMnAALoOB59RVs256.gif" alt="image019.gif"></p>
<p>下面再来个复杂些的 3 列布局的例子。</p>
<p>第 1 步，写好 HTML 结构，为了辨认方便，我们给布局容器设置背景色和高度：</p>
<pre><code data-language="xml" class="lang-xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">
&nbsp;&nbsp;<span class="hljs-comment">/*&nbsp;为了方便查看，给布局容器设置高度和颜色&nbsp;*/</span>
&nbsp;&nbsp;<span class="hljs-selector-class">.main</span>,&nbsp;<span class="hljs-selector-class">.left</span>,&nbsp;<span class="hljs-selector-class">.right</span>&nbsp;&#123;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attribute">height</span>:&nbsp;<span class="hljs-number">100px</span>;
&nbsp;&nbsp;&#125;
&nbsp;&nbsp;<span class="hljs-selector-class">.main</span>&nbsp;&#123;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attribute">background-color</span>:&nbsp;red;
&nbsp;&nbsp;&#125;
&nbsp;&nbsp;<span class="hljs-selector-class">.left</span>&nbsp;&#123;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attribute">background-color</span>:&nbsp;green;
&nbsp;&nbsp;&#125;
&nbsp;&nbsp;<span class="hljs-selector-class">.right</span>&nbsp;&#123;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attribute">background-color</span>:&nbsp;blue;
&nbsp;&nbsp;&#125;
</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span>&nbsp;<span class="hljs-attr">class</span>=<span class="hljs-string">"wrap"</span>&gt;</span>
&nbsp;&nbsp;<span class="hljs-tag">&lt;<span class="hljs-name">main</span>&nbsp;<span class="hljs-attr">class</span>=<span class="hljs-string">"main"</span>&gt;</span>main<span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span>
&nbsp;&nbsp;<span class="hljs-tag">&lt;<span class="hljs-name">aside</span>&nbsp;<span class="hljs-attr">class</span>=<span class="hljs-string">"left"</span>&gt;</span>left<span class="hljs-tag">&lt;/<span class="hljs-name">aside</span>&gt;</span>
&nbsp;&nbsp;<span class="hljs-tag">&lt;<span class="hljs-name">aside</span>&nbsp;<span class="hljs-attr">class</span>=<span class="hljs-string">"right"</span>&gt;</span>right<span class="hljs-tag">&lt;/<span class="hljs-name">aside</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre>
<p><img src="https://s0.lgstatic.com/i/image/M00/0E/0E/CgqCHl7E7wKAXwSWAAAp_ydHZSg960.png" alt="image020.png"></p>
<p>第 2 步，让布局容器水平排列：</p>
<pre><code data-language="xml" class="lang-xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">
&nbsp;&nbsp;<span class="hljs-selector-class">.main</span>,&nbsp;<span class="hljs-selector-class">.left</span>,&nbsp;<span class="hljs-selector-class">.right</span>&nbsp;&#123;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attribute">float</span>:&nbsp;left;
&nbsp;&nbsp;&#125;
</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span>&nbsp;<span class="hljs-attr">class</span>=<span class="hljs-string">"wrap"</span>&gt;</span>
&nbsp;&nbsp;<span class="hljs-tag">&lt;<span class="hljs-name">main</span>&nbsp;<span class="hljs-attr">class</span>=<span class="hljs-string">"main"</span>&gt;</span>main<span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span>
&nbsp;&nbsp;<span class="hljs-tag">&lt;<span class="hljs-name">aside</span>&nbsp;<span class="hljs-attr">class</span>=<span class="hljs-string">"left"</span>&gt;</span>left<span class="hljs-tag">&lt;/<span class="hljs-name">aside</span>&gt;</span>
&nbsp;&nbsp;<span class="hljs-tag">&lt;<span class="hljs-name">aside</span>&nbsp;<span class="hljs-attr">class</span>=<span class="hljs-string">"right"</span>&gt;</span>right<span class="hljs-tag">&lt;/<span class="hljs-name">aside</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre>
<p><img src="https://s0.lgstatic.com/i/image/M00/0E/03/Ciqc1F7E7wyAQ5-dAAAav_zx9fY631.png" alt="image022.png"></p>
<p>第 3 步，调整宽度，将主要布局容器 main 撑满，次要布局容器 left 固定 300px，次要布局容器 right 固定 200px。</p>
<p>这里如果直接设置的话，布局容器 left 和 right 都会换行，所以我们需要通过设置父元素 wrap 内边距来压缩主要布局 main 给次要布局容器留出空间。同时通过设置次要布局容器边距以及采用相对定位调整次要布局容器至两侧。</p>
<pre><code data-language="xml" class="lang-xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">
&nbsp;&nbsp;<span class="hljs-selector-class">.main</span>,&nbsp;<span class="hljs-selector-class">.left</span>,&nbsp;<span class="hljs-selector-class">.right</span>&nbsp;&#123;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attribute">float</span>:&nbsp;left;
&nbsp;&nbsp;&#125;
&nbsp;&nbsp;<span class="hljs-selector-class">.wrap</span>&nbsp;&#123;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attribute">padding</span>:&nbsp;<span class="hljs-number">0</span>&nbsp;<span class="hljs-number">200px</span>&nbsp;<span class="hljs-number">0</span>&nbsp;<span class="hljs-number">300px</span>;
&nbsp;&nbsp;&#125;
&nbsp;&nbsp;<span class="hljs-selector-class">.main</span>&nbsp;&#123;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attribute">width</span>:&nbsp;<span class="hljs-number">100%</span>;
&nbsp;&nbsp;&#125;
&nbsp;&nbsp;<span class="hljs-selector-class">.left</span>&nbsp;&#123;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attribute">width</span>:&nbsp;<span class="hljs-number">300px</span>;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attribute">position</span>:&nbsp;relative;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attribute">left</span>:&nbsp;-<span class="hljs-number">300px</span>;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attribute">margin-left</span>:&nbsp;-<span class="hljs-number">100%</span>;
&nbsp;&nbsp;&#125;
&nbsp;&nbsp;<span class="hljs-selector-class">.right</span>&nbsp;&#123;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attribute">position</span>:&nbsp;relative;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attribute">width</span>:&nbsp;<span class="hljs-number">200px</span>;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attribute">margin-left</span>:&nbsp;-<span class="hljs-number">200px</span>;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attribute">right</span>:&nbsp;-<span class="hljs-number">200px</span>;
&nbsp;&nbsp;&#125;
</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span>&nbsp;<span class="hljs-attr">class</span>=<span class="hljs-string">"wrap"</span>&gt;</span>
&nbsp;&nbsp;<span class="hljs-tag">&lt;<span class="hljs-name">main</span>&nbsp;<span class="hljs-attr">class</span>=<span class="hljs-string">"main"</span>&gt;</span>main<span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span>
&nbsp;&nbsp;<span class="hljs-tag">&lt;<span class="hljs-name">aside</span>&nbsp;<span class="hljs-attr">class</span>=<span class="hljs-string">"left"</span>&gt;</span>left<span class="hljs-tag">&lt;/<span class="hljs-name">aside</span>&gt;</span>
&nbsp;&nbsp;<span class="hljs-tag">&lt;<span class="hljs-name">aside</span>&nbsp;<span class="hljs-attr">class</span>=<span class="hljs-string">"right"</span>&gt;</span>right<span class="hljs-tag">&lt;/<span class="hljs-name">aside</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre>
<p><img src="https://s0.lgstatic.com/i/image/M00/0E/03/Ciqc1F7E7xuAdjuNAAAjJjRTGoc544.png" alt="image024.png"></p>
<p>第 4 步，消除副作用。我们知道使用浮动会造成高度塌陷，如果在父元素后面添加新的元素就会产生这个问题。所以可以通过伪类来清除浮动，同时减小页面宽度，还会发现次要布局容器 left 和 right 都换行了，但这个副作用我们可以在第 5 步时进行消除。</p>
<pre><code data-language="xml" class="lang-xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">
&nbsp;&nbsp;<span class="hljs-selector-class">.main</span>,&nbsp;<span class="hljs-selector-class">.left</span>,&nbsp;<span class="hljs-selector-class">.right</span>&nbsp;&#123;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attribute">float</span>:&nbsp;left;
&nbsp;&nbsp;&#125;
&nbsp;&nbsp;<span class="hljs-selector-class">.wrap</span>&nbsp;&#123;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attribute">padding</span>:&nbsp;<span class="hljs-number">0</span>&nbsp;<span class="hljs-number">200px</span>&nbsp;<span class="hljs-number">0</span>&nbsp;<span class="hljs-number">300px</span>;
&nbsp;&nbsp;&#125;
&nbsp;&nbsp;<span class="hljs-selector-class">.wrap</span><span class="hljs-selector-pseudo">::after</span>&nbsp;&#123;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attribute">content</span>:&nbsp;<span class="hljs-string">''</span>;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attribute">display</span>:&nbsp;block;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attribute">clear</span>:&nbsp;both;
&nbsp;&nbsp;&#125;
&nbsp;&nbsp;<span class="hljs-selector-class">.main</span>&nbsp;&#123;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attribute">width</span>:&nbsp;<span class="hljs-number">100%</span>;
&nbsp;&nbsp;&#125;
&nbsp;&nbsp;<span class="hljs-selector-class">.left</span>&nbsp;&#123;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attribute">width</span>:&nbsp;<span class="hljs-number">300px</span>;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attribute">position</span>:&nbsp;relative;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attribute">left</span>:&nbsp;-<span class="hljs-number">300px</span>;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attribute">margin-left</span>:&nbsp;-<span class="hljs-number">100%</span>;
&nbsp;&nbsp;&#125;
&nbsp;&nbsp;<span class="hljs-selector-class">.right</span>&nbsp;&#123;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attribute">position</span>:&nbsp;relative;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attribute">width</span>:&nbsp;<span class="hljs-number">200px</span>;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attribute">margin-left</span>:&nbsp;-<span class="hljs-number">200px</span>;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attribute">right</span>:&nbsp;-<span class="hljs-number">200px</span>;
&nbsp;&nbsp;&#125;
</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span>&nbsp;<span class="hljs-attr">class</span>=<span class="hljs-string">"wrap"</span>&gt;</span>
&nbsp;&nbsp;<span class="hljs-tag">&lt;<span class="hljs-name">main</span>&nbsp;<span class="hljs-attr">class</span>=<span class="hljs-string">"main"</span>&gt;</span>main<span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span>
&nbsp;&nbsp;<span class="hljs-tag">&lt;<span class="hljs-name">aside</span>&nbsp;<span class="hljs-attr">class</span>=<span class="hljs-string">"left"</span>&gt;</span>left<span class="hljs-tag">&lt;/<span class="hljs-name">aside</span>&gt;</span>
&nbsp;&nbsp;<span class="hljs-tag">&lt;<span class="hljs-name">aside</span>&nbsp;<span class="hljs-attr">class</span>=<span class="hljs-string">"right"</span>&gt;</span>right<span class="hljs-tag">&lt;/<span class="hljs-name">aside</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre>
<p><img src="https://s0.lgstatic.com/i/image/M00/0E/0F/CgqCHl7E7y2AWIVNAAAjKqEadUw543.png" alt="image026.png"></p>
<p>第 5 步，利用媒体查询调整页面宽度较小情况下的显示优先级。这里我们仍然希望优先显示主要布局容器 main，其次是次要布局容器 left，最后是布局容器 right。</p>
<pre><code data-language="xml" class="lang-xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">
&nbsp;&nbsp;<span class="hljs-selector-class">.main</span>,&nbsp;<span class="hljs-selector-class">.left</span>,&nbsp;<span class="hljs-selector-class">.right</span>&nbsp;&#123;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attribute">float</span>:&nbsp;left;
&nbsp;&nbsp;&#125;
&nbsp;&nbsp;<span class="hljs-selector-class">.wrap</span>&nbsp;&#123;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attribute">padding</span>:&nbsp;<span class="hljs-number">0</span>&nbsp;<span class="hljs-number">200px</span>&nbsp;<span class="hljs-number">0</span>&nbsp;<span class="hljs-number">300px</span>;
&nbsp;&nbsp;&#125;
&nbsp;&nbsp;<span class="hljs-selector-class">.wrap</span><span class="hljs-selector-pseudo">::after</span>&nbsp;&#123;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attribute">content</span>:&nbsp;<span class="hljs-string">''</span>;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attribute">display</span>:&nbsp;block;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attribute">clear</span>:&nbsp;both;
&nbsp;&nbsp;&#125;
&nbsp;&nbsp;<span class="hljs-selector-class">.main</span>&nbsp;&#123;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attribute">width</span>:&nbsp;<span class="hljs-number">100%</span>;
&nbsp;&nbsp;&#125;
&nbsp;&nbsp;<span class="hljs-selector-class">.left</span>&nbsp;&#123;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attribute">width</span>:&nbsp;<span class="hljs-number">300px</span>;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attribute">position</span>:&nbsp;relative;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attribute">left</span>:&nbsp;-<span class="hljs-number">300px</span>;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attribute">margin-left</span>:&nbsp;-<span class="hljs-number">100%</span>;
&nbsp;&nbsp;&#125;
&nbsp;&nbsp;<span class="hljs-selector-class">.right</span>&nbsp;&#123;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attribute">position</span>:&nbsp;relative;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attribute">width</span>:&nbsp;<span class="hljs-number">200px</span>;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attribute">margin-left</span>:&nbsp;-<span class="hljs-number">200px</span>;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attribute">right</span>:&nbsp;-<span class="hljs-number">200px</span>;
&nbsp;&nbsp;&#125;
&nbsp;&nbsp;<span class="hljs-keyword">@media</span>&nbsp;<span class="hljs-keyword">only</span>&nbsp;screen&nbsp;<span class="hljs-keyword">and</span>&nbsp;(<span class="hljs-attribute">max-width:</span>&nbsp;<span class="hljs-number">1000px</span>)&nbsp;&#123;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-selector-class">.wrap</span>&nbsp;&#123;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attribute">padding</span>:&nbsp;<span class="hljs-number">0</span>;
&nbsp;&nbsp;&nbsp;&nbsp;&#125;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-selector-class">.left</span>&nbsp;&#123;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attribute">left</span>:&nbsp;<span class="hljs-number">0</span>;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attribute">margin-left</span>:&nbsp;<span class="hljs-number">0</span>;
&nbsp;&nbsp;&nbsp;&nbsp;&#125;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-selector-class">.right</span>&nbsp;&#123;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attribute">margin-left</span>:&nbsp;<span class="hljs-number">0</span>;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attribute">right</span>:&nbsp;<span class="hljs-number">0</span>;
&nbsp;&nbsp;&nbsp;&nbsp;&#125;
&nbsp;&nbsp;&#125;
</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span>&nbsp;<span class="hljs-attr">class</span>=<span class="hljs-string">"wrap"</span>&gt;</span>
&nbsp;&nbsp;<span class="hljs-tag">&lt;<span class="hljs-name">main</span>&nbsp;<span class="hljs-attr">class</span>=<span class="hljs-string">"main"</span>&gt;</span>main<span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span>
&nbsp;&nbsp;<span class="hljs-tag">&lt;<span class="hljs-name">aside</span>&nbsp;<span class="hljs-attr">class</span>=<span class="hljs-string">"left"</span>&gt;</span>left<span class="hljs-tag">&lt;/<span class="hljs-name">aside</span>&gt;</span>
&nbsp;&nbsp;<span class="hljs-tag">&lt;<span class="hljs-name">aside</span>&nbsp;<span class="hljs-attr">class</span>=<span class="hljs-string">"right"</span>&gt;</span>right<span class="hljs-tag">&lt;/<span class="hljs-name">aside</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre>
<p><img src="https://s0.lgstatic.com/i/image/M00/0E/03/Ciqc1F7E72KAcZENAAI1dbZkP0I370.gif" alt="image028.gif"></p>
<p>这种 3 列布局的实现，就是流传已久的“圣杯布局”，但标准的圣杯布局没有添加媒体查询。</p>
<h4>延伸1：垂直方向的布局</h4>
<p>垂直方向有一种布局虽然使用频率不如水平方向布局高，但在面试中很容易被问到，所以这里特意再补充讲解一下。</p>
<p>这种布局将页面分成上、中、下三个部分，上、下部分都为固定高度，中间部分高度不定。当页面高度小于浏览器高度时，下部分应固定在屏幕底部；当页面高度超出浏览器高度时，下部分应该随中间部分被撑开，显示在页面最底部。</p>
<p>这种布局也称之为”sticky footer“，意思是下部分粘黏在屏幕底部。要实现这个功能，最简单的就是使用 flex 或 grid 进行布局。下面是使用 flex 的主要代码：</p>
<pre><code data-language="xml" class="lang-xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">
  <span class="hljs-selector-class">.container</span>&nbsp;&#123;
  &nbsp;&nbsp;<span class="hljs-attribute">display</span>:&nbsp;flex;
  &nbsp;&nbsp;<span class="hljs-attribute">height</span>:&nbsp;<span class="hljs-number">100%</span>;
  &nbsp;&nbsp;<span class="hljs-attribute">flex-direction</span>:&nbsp;column;
  &#125;
  <span class="hljs-selector-tag">header</span>,&nbsp;<span class="hljs-selector-tag">footer</span>&nbsp;&#123;
  &nbsp;&nbsp;<span class="hljs-attribute">min-height</span>:&nbsp;<span class="hljs-number">100px</span>;
  &#125;
  <span class="hljs-selector-tag">main</span>&nbsp;&#123;
  &nbsp;&nbsp;<span class="hljs-attribute">flex</span>:&nbsp;<span class="hljs-number">1</span>;
  &#125;
</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span>&nbsp;<span class="hljs-attr">class</span>=<span class="hljs-string">"container"</span>&gt;</span>
&nbsp;&nbsp;<span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span>
&nbsp;&nbsp;<span class="hljs-tag">&lt;<span class="hljs-name">main</span>&gt;</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
&nbsp;&nbsp;<span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span>
&nbsp;&nbsp;<span class="hljs-tag">&lt;<span class="hljs-name">footer</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre>
<p>代码实现思路比较简单，将布局容器的父元素 display 属性设置成 flex，伸缩方向改为垂直方向，高度撑满页面，再将中间布局容器的 flex 属性设置为 1，让其自适应即可。<br>
如果要考虑兼容性的话，其实现起来要复杂些，下面是主要代码：</p>
<pre><code data-language="xml" class="lang-xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">
&nbsp;&nbsp;<span class="hljs-selector-class">.container</span>&nbsp;&#123;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attribute">box-sizing</span>:&nbsp;border-box;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attribute">min-height</span>:&nbsp;<span class="hljs-number">100vh</span>;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attribute">padding-bottom</span>:&nbsp;<span class="hljs-number">100px</span>;
&nbsp;&nbsp;&#125;
&nbsp;&nbsp;<span class="hljs-selector-tag">header</span>,&nbsp;<span class="hljs-selector-tag">footer</span>&nbsp;&#123;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attribute">height</span>:&nbsp;<span class="hljs-number">100px</span>;
&nbsp;&nbsp;&#125;
&nbsp;&nbsp;<span class="hljs-selector-tag">footer</span>&nbsp;&#123;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attribute">margin-top</span>:&nbsp;-<span class="hljs-number">100px</span>;
&nbsp;&nbsp;&#125;
</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span>&nbsp;<span class="hljs-attr">class</span>=<span class="hljs-string">"container"</span>&gt;</span>
&nbsp;&nbsp;<span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span>
&nbsp;&nbsp;<span class="hljs-tag">&lt;<span class="hljs-name">main</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">footer</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span>
</code></pre>
<p>将上部分布局容器与中间布局容器放入一个共同的父元素中，并让父元素高度撑满，然后设置内下边距给下部分布局容器预留空间，下部分布局容器设置上外边距“嵌入”父元素中。从而实现了随着中间布局容器高度而被撑开的效果。</p>
<h4>延伸2：框架中栅格布局的列数</h4>
<p>很多 UI 框架都提供了栅格系统来帮助页面实现等分或等比布局，比如 Bootstrap 提供了 12 列栅格，elment ui 和 ant design 提供了 24 列栅格。</p>
<p>那么你思考过栅格系统设定这些列数背后的原因吗？</p>
<p>首先从 12 列说起，12 这个数字，从数学上来说它具有很多约数 1、2、3、4、6、12，也就是说可以轻松实现 1 等分、2 等分、3 等分、4 等分、6 等分、12 等分，比例方面可以实现 1:11、1:5、1:3、1:2、1:1、1:10:1、1:4:1 等。如果换成 10 或 8，则可实现的等分比例就会少很多，而更大的 16 似乎是个不错的选择，但对于常用的 3 等分就难以实现。</p>
<p>至于使用 24 列不使用 12 列，可能是考虑宽屏幕（PC 端屏幕宽度不断增加）下对 12 列难以满足等分比例需求，比如 8 等分。同时又能够保证兼容 12 列情况下的等分比例（方便项目迁移和替换）。</p>
<h4>总结</h4>
<p>通过这一讲，我们学习了几种常见布局，包括单列、2 列、3 列及垂直三栏布局，同时思考每种布局的优缺点和使用场景，并且对 2 列布局和 3 列布局实现方法归纳成了 5 个步骤，希望你能举一反三，并应用到实际的工作中。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/yalishizhude/course/tree/master/04">课程代码点击下载</a>。</p>
<p>最后布置一道思考题：你还想到了使用哪些方法来实现 2 列或 3 列布局？</p>

<hr>
<h3 id="精选评论"><a href="#精选评论" class="headerlink" title="精选评论"></a>精选评论</h3><h5 id="平："><a href="#平：" class="headerlink" title="**平："></a>**平：</h5><blockquote>
<p>会手写双飞翼布局和圣杯布局的前端，基础还是不错的，正统来源</p>
</blockquote>
<h5 id="贵："><a href="#贵：" class="headerlink" title="**贵："></a>**贵：</h5><blockquote>
<p>知常用，懂原理，可进阶。</p>
</blockquote>
<h5 id="2783："><a href="#2783：" class="headerlink" title="**2783："></a>**2783：</h5><blockquote>
<p>打卡，写的不错，平常专注于业务逻辑，基础这些反而越来越不重视了！温故而知新！</p>
</blockquote>
<h5 id="伟："><a href="#伟：" class="headerlink" title="**伟："></a>**伟：</h5><blockquote>
<p>其实主要布局放在次要布局前面的做法是完全没必要的，浏览器并不会先显示主要布局而是两种布局都加载完毕一起显示</p>
</blockquote>
<h5 id="宁："><a href="#宁：" class="headerlink" title="*宁："></a>*宁：</h5><blockquote>
<p>突然感觉大佬的思路 很厉害的样子</p>
</blockquote>
<h5 id="辉："><a href="#辉：" class="headerlink" title="*辉："></a>*辉：</h5><blockquote>
<p>双飞翼布局,框架用多了,基本没用到手写flex<div><br></div></p>
</blockquote>
<h5 id="盼："><a href="#盼：" class="headerlink" title="*盼："></a>*盼：</h5><blockquote>
<p>打卡😀</p>
</blockquote>
<h5 id="媛："><a href="#媛：" class="headerlink" title="**媛："></a>**媛：</h5><blockquote>
<p>双飞翼布局</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/11/02/%E6%8E%8C%E6%8F%A1-CSS-%E7%B2%BE%E9%AB%93%EF%BC%9A%E5%B8%83%E5%B1%80/" data-id="claxeera6001ev8w1bj5hg5i5" data-title="掌握 CSS 精髓：布局" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-微前端与功能的可重用性" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/11/02/%E5%BE%AE%E5%89%8D%E7%AB%AF%E4%B8%8E%E5%8A%9F%E8%83%BD%E7%9A%84%E5%8F%AF%E9%87%8D%E7%94%A8%E6%80%A7/" class="article-date">
  <time class="dt-published" datetime="2022-11-02T02:57:35.000Z" itemprop="datePublished">2022-11-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/11/02/%E5%BE%AE%E5%89%8D%E7%AB%AF%E4%B8%8E%E5%8A%9F%E8%83%BD%E7%9A%84%E5%8F%AF%E9%87%8D%E7%94%A8%E6%80%A7/">微前端与功能的可重用性</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p data-nodeid="829" class="">在这之前，我们来思考一个问题，在日常开发中是怎么复用代码的？</p>
<ul data-nodeid="830">
<li data-nodeid="831">
<p data-nodeid="832"><strong data-nodeid="912">复制粘贴</strong>。这是初级工程师最容易采用的方式，该方式虽然简单有效，但会给代码维护带来很多问题，比如增加了很多重复的代码，复用代码逻辑发生变动时需要处处修改。因此，这种违反 DRY（Don't Repeat Yourself）原则的方式应该尽量避免。</p>
</li>
<li data-nodeid="833">
<p data-nodeid="834"><strong data-nodeid="917">封装模块</strong>。稍有经验的工程师会考虑将代码逻辑封装成模块，然后通过引用模块的方式来复用，比如最常见的组件就是集成了视图操作的代码模块。这种方式解决了“复制粘贴”的可维护性问题，但如果将场景扩大，这种方式就行不通了，比如多个项目要使用同一个模块的时候。</p>
</li>
<li data-nodeid="835">
<p data-nodeid="836"><strong data-nodeid="922">打包成库</strong>。模块很好地解决了跨文件复用代码的问题，对于跨项目复用的情况可以通过打包成库的方式来解决，比如前端领域中会打包成库然后发布到 NPM 中，使用的时候再通过命令行工具来安装。</p>
</li>
<li data-nodeid="837">
<p data-nodeid="838"><strong data-nodeid="927">提供服务</strong>。库这种复用方式其实也有缺陷，首先库有特定的依赖，比如要在 React 项目使用基于 Vue 开发的树形组件，就必须把 Vue 也引进来，这样势必会增加项目体积和复杂度；其次库更多的是偏向功能的复用，而偏向业务的代码则很少用库来实现。如果使用微前端架构就可以按照业务拆分成微应用，然后再通过配置引用的方式来复用所需的微应用。</p>
</li>
</ul>
<p data-nodeid="839">不过微前端最早被提出不是为了代码的复用，而是用来将项目进行拆分和解耦。</p>
<h3 data-nodeid="840">微前端概念</h3>
<p data-nodeid="841">“微前端”一词最早于 2016 年底在 <a target="_blank" rel="noopener" href="https://www.thoughtworks.com/radar/techniques/micro-frontends" data-nodeid="933">ThoughtWorks Technology Radar</a> 中提出，它将后端的微服务概念扩展到了前端世界。微服务是服务端提出的一个有界上下文、松耦合的架构模式，具体是将应用的服务端拆分成更小的微服务，这些微服务都能独立运行，采用轻量级的通信方式（比如 HTTP ）。</p>
<p data-nodeid="1440">微前端概念的提出可以借助下面的 Web 应用架构模式演变图来理解。</p>
<p data-nodeid="1441" class=""><img src="https://s0.lgstatic.com/i/image/M00/50/25/Ciqc1F9h5ZaAKe-1AACsAd0gjts226.png" alt="Lark20200916-181408.png" data-nodeid="1446"></p>
<div data-nodeid="1442"><p style="text-align:center">Web 应用架构模式的演变图</p></div>



<p data-nodeid="845">最原始的架构模式是单体 Web 应用，整个应用由一个团队来负责开发。</p>
<p data-nodeid="846">随着技术的发展，开发职责开始细分，一个项目的负责团队会分化成前端团队和后端团队，即出现了前后端分离的架构方式。</p>
<p data-nodeid="847">随着项目变得越来越复杂，先感受到压力的是后端，于是微服务的架构模式开始出现。</p>
<p data-nodeid="848">随着前端运行环境进一步提升，Web 应用的发展趋势越来越倾向于富应用，即在浏览器端集成更多的功能，前端层的代码量以及业务逻辑也开始快速增长，从而变得越来越难以维护。于是引入了微服务的架构思想，将网站或 Web 应用按照业务拆分成粒度更小的微应用，由独立的团队负责开发。</p>
<p data-nodeid="849">从图上可以看出，微前端、微服务这些架构模式的演变趋势就是不断地将逻辑进行拆分，从而降低项目复杂度，提升可维护性和可复用性。</p>
<h3 data-nodeid="850">微前端应用场景</h3>
<p data-nodeid="851">从上面的演变过程可以看出，微前端架构比较适合大型的 Web 应用，常见的有以下 3 种形式。</p>
<ul data-nodeid="852">
<li data-nodeid="853">
<p data-nodeid="854"><strong data-nodeid="950">公司内部的平台系统</strong>。这些系统之间存在一定的相关性，用户在使用过程中会涉及跨系统的操作，频繁地页面跳转或系统切换将导致操作效率低下。而且，在多个独立系统内部可能会开发一些重复度很高的功能，比如用户管理，这些重复的功能会导致开发成本和用户使用成本上升。</p>
</li>
<li data-nodeid="855">
<p data-nodeid="856"><strong data-nodeid="955">大型单页应用</strong>。这类应用的特点是系统体量较大，导致在日常调试开发的时候需要耗费较多时间，严重影响到开发体验和效率。而且随着业务上的功能升级，项目体积还会不断增大，如果项目要进行架构升级的话改造成本会很高。</p>
</li>
<li data-nodeid="857">
<p data-nodeid="858"><strong data-nodeid="960">对已有系统的兼容和扩展</strong>。比如一些项目使用的是老旧的技术，使用微前端之后，对于新功能的开发可以使用新的技术框架，这样避免了推翻重构，也避免了继续基于过时的技术进行开发。</p>
</li>
</ul>
<h3 data-nodeid="859">微前端核心思想</h3>
<p data-nodeid="860">微前端架构遵循下面 3 个核心思想。</p>
<p data-nodeid="861"><strong data-nodeid="968">1. 技术无关</strong></p>
<p data-nodeid="862">前端看上去非常统一，不像服务端在语言上可选择性非常多（Java、Python、Go、PHP 等），但仍然在框架上存在分歧。微前端架构要求保留每个团队选择技术栈的权利，即不同微应用可以选择不同的技术框架来实现，当然也包括制定不同的发布周期和发布流程。</p>
<p data-nodeid="863"><strong data-nodeid="975">2. 环境独立</strong></p>
<p data-nodeid="864">为了达到高度解耦的目的，每个微应用不应当共享运行时环境，即使所有微应用都使用了相同的框架，那么它们之间应该尽量避免依赖共享状态或全局变量。</p>
<p data-nodeid="865">为了避免微应用之间产生冲突，应该通过命名前缀等方式来对一些公共作用域进行隔离。</p>
<p data-nodeid="866">对于 CSS 隔离，比较容易产生冲突的是主应用与微应用，可以采用 CSS Module 或者命名空间的方式，在编写每个微应用时使用约定好的特定前缀，或者采用 postcss 插件，在打包时添加特定的前缀。</p>
<p data-nodeid="867">另一种隔离，不同于微应用之间的 CSS 方式是在每次新的微应用加载时，将前一个微应用的 link 和 style 进行卸载。</p>
<p data-nodeid="868">对于 JavaScript 隔离则会麻烦一些，比较好的做法是使用沙箱的方式来进行隔离。沙箱机制的核心是让局部的 JavaScript 运行时，对外部对象的访问和修改处在可控的范围内，即无论内部怎么运行，都不会影响外部的对象。可以通过 with 关键字和 window.Proxy 对象来实现浏览器端的沙箱。</p>
<p data-nodeid="869">需要注意的是，沙箱机制核心在于创建一个虚拟的运行环境，并不等同于创建独立的作用域。在独立作用域中会有污染全局变量的风险，比如在独立作用域修改了原生 API 将 Array.prototype.forEach = null，那么之后的所有代码创建的数组执行 forEach 时都会报错，而沙箱机制就能避免这种问题的产生。</p>
<p data-nodeid="870">这种沙箱机制不仅能保证微应用之间的独立性，还能保证主应用的稳定性，所以当某个微应用的 JavaScript 执行失败或尚未执行时，整个应用应该仍是可用的。</p>
<p data-nodeid="871"><strong data-nodeid="988">3. 原生优先</strong></p>
<p data-nodeid="872">原生优先使用浏览器事件进行通信，而不要使用自封装的发布订阅系统。如果确实必须跨应用进行通信，尽量让通信内容和方式变得简单，这样能有效地减少微应用之间的公共依赖。</p>
<h3 data-nodeid="873">微前端架构模式</h3>
<p data-nodeid="874">了解完微前端的基本原理之后再来看看具体是如何实现的。微前端架构按集成微应用的位置不同，主要可以分为 2 类：</p>
<ul data-nodeid="875">
<li data-nodeid="876">
<p data-nodeid="877">在服务端集成微应用，比如通过 Nginx 代理转发；</p>
</li>
<li data-nodeid="878">
<p data-nodeid="879">在浏览器集成微应用，比如使用 Web Components 的自定义元素功能。</p>
</li>
</ul>
<p data-nodeid="880">一些说法认为通过构建工具在编译的时候进行集成也属于微前端范畴，比如将微应用发布成独立的 npm 包，共同作为主应用的依赖项，构建生成一个供部署的 JS Bundle，但这种方式并不符合微前端的核心思想，也并不是主流的微前端实现方式，故不做深入讨论。</p>
<p data-nodeid="881">这一课时我们只讨论服务端集成和浏览器端集成的情况。</p>
<h4 data-nodeid="882">服务端集成</h4>
<p data-nodeid="883">服务端集成常用的方式是通过反向代理，在服务端进行路由转发，即通过路径匹配将不同请求转发到对应的微应用。这种架构方式实现起来比较容易，改造的工作量也比较小，因为只是将不同的 Web 应用拼凑在一起，严格地说并不能算是一个完整的 Web 应用。当用户从一个微应用跳转到另一个微应用时，往往需要刷新页面重新加载资源。</p>
<p data-nodeid="884">这种代理转发的方式和直接跳转到对应的 Web 应用相比具有一个优势，那就是不同应用之间的通信问题变得简单了，因为在同一个域下，所以可以共享 localstorage、cookie 这些数据。譬如每个微应用都需要身份认证信息 token，那么只需要登录后将 token 信息写入 localstorage，后续所有的微应用就都可以使用了，不必再重新登录或者使用其他方式传递登录信息。</p>
<h4 data-nodeid="885">浏览器集成</h4>
<p data-nodeid="886">浏览器集成也称运行时集成，常见的方式有以下 3 种。</p>
<ul data-nodeid="887">
<li data-nodeid="888">
<p data-nodeid="889"><strong data-nodeid="1005">iframe</strong>。通过 iframe 的方式将不同的微应用集成到主应用中，实现成本低，但样式、兼容性方面存在一定问题，比如沙箱属性 sandbox 的某些值在 IE 下不支持。</p>
</li>
<li data-nodeid="890">
<p data-nodeid="891"><strong data-nodeid="1010">前端路由</strong>。每个微应用暴露出渲染函数，主应用在启动时加载各个微应用的主模块，之后根据路由规则渲染相应的微应用。虽然实现方式比较灵活，但有一定的改造成本。</p>
</li>
<li data-nodeid="892">
<p data-nodeid="893"><strong data-nodeid="1015">Web Components</strong>。基于原生的自定义元素来加载不同微应用，借助 Shadow DOM 实现隔离，改造成本比较大。</p>
</li>
</ul>
<p data-nodeid="894">这也是一种非常热门的集成方式，代表性的框架有 <a target="_blank" rel="noopener" href="https://github.com/single-spa/single-spa" data-nodeid="1019">single-spa</a> 以及基于它修改的<a target="_blank" rel="noopener" href="https://github.com/umijs/qiankun" data-nodeid="1023">乾坤</a>。</p>
<h3 data-nodeid="895">总结</h3>
<p data-nodeid="896">这一课时介绍了微前端技术相关概念，核心内容如下：</p>
<ul data-nodeid="897">
<li data-nodeid="898">
<p data-nodeid="899">首先，微前端这种架构模式来源于微服务，目的在于对项目进行拆分和隔离，从而提高项目的可维护性和可复用性；</p>
</li>
<li data-nodeid="900">
<p data-nodeid="901">其次，微前端这种架构的核心思想有 3 点，技术无关、环境独立、原生优先，其中环境独立比较难以实现，需要借助一定的技术手段或代码规范；</p>
</li>
<li data-nodeid="902">
<p data-nodeid="903">最后，主流的微前端实现方式大致分为两类，在服务端集成或者在浏览器端集成，服务端集成一般通过代理转发方式实现；在浏览器端集成则实现方式较多，也有例如 <a target="_blank" rel="noopener" href="https://github.com/single-spa/single-spa" data-nodeid="1032">single-spa</a> 这类框架支持。</p>
</li>
</ul>
<p data-nodeid="904" class="">最后布置一道思考题：除了前后端分离及微服务，你还了解过哪些架构模式？</p>

<hr>
<h3 id="精选评论"><a href="#精选评论" class="headerlink" title="精选评论"></a>精选评论</h3><h5 id="平："><a href="#平：" class="headerlink" title="**平："></a>**平：</h5><blockquote>
<p>前端微服务有哪些缺点？</p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-讲师回复："><a href="#amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; 微前端意味着各个项目高度”自治“，可能使用不同的框架。在开发人员角度，框架的多样性会增加系统的复杂性；在用户角度来看，浏览器端在加载一个页面的时候需要加载的依赖增加，性能也会受到一定程度影响。</p>
</blockquote>
<h5 id="正："><a href="#正：" class="headerlink" title="**正："></a>**正：</h5><blockquote>
<p>vue中将单页面应用拆分成多页面应用属于微前端吗？</p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-1"><a href="#amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-1" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; 光凭单页应用和多页应用并不能判断是否属于微前端架构，简单地可以从是否属于不同的项目，有独立的 package.json 文件进行判断（monorepo 不算）~</p>
</blockquote>
<h5 id="杰："><a href="#杰：" class="headerlink" title="*杰："></a>*杰：</h5><blockquote>
<p>容器化的实施配合自动打包可以方便部署和扩缩</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/11/02/%E5%BE%AE%E5%89%8D%E7%AB%AF%E4%B8%8E%E5%8A%9F%E8%83%BD%E7%9A%84%E5%8F%AF%E9%87%8D%E7%94%A8%E6%80%A7/" data-id="claxeera30017v8w18xns53jf" data-title="微前端与功能的可重用性" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-前端热点技术之-Serverle" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/11/02/%E5%89%8D%E7%AB%AF%E7%83%AD%E7%82%B9%E6%8A%80%E6%9C%AF%E4%B9%8B-Serverle/" class="article-date">
  <time class="dt-published" datetime="2022-11-02T02:56:33.000Z" itemprop="datePublished">2022-11-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/11/02/%E5%89%8D%E7%AB%AF%E7%83%AD%E7%82%B9%E6%8A%80%E6%9C%AF%E4%B9%8B-Serverle/">前端热点技术之 Serverle</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p data-nodeid="224821" class="">严格意义上来说，Serverless 并不属于前端技术，但对于那些想提升自己知识广度，想往全栈工程师方向发展的前端工程师而言，是一个非常高效的工具。而对于那些只想专注于前端领域的工程师而言，了解 Serverless 背后的思想，对提升开发思维也会有一定的帮助。</p>
<p data-nodeid="224822">下面我们就通过相关概念和具体案例来揭开 Serverless 的神秘面纱吧。</p>
<h3 data-nodeid="224823">什么是 Serverless</h3>
<p data-nodeid="224824">Serverless 是由“Server”和“less”两个单词组合而成，翻译成中文就是“无服务器”的意思，所谓无服务器并非脱离服务器的 Web 离线应用，也不是说前端页面绕过服务端直接读写数据库，而是开发者不用再考虑服务器环境搭建和维护等问题，只需要专注于开发即可。也就是说 Serverless 不是语言或框架，而是一种软件的部署方式。传统的应用需要部署在服务器或虚拟机上，安装运行环境之后以进程的方式启动，而使用 Serverless 则可以省略这个过程，直接使用云服务厂商提供的运行环境。</p>
<h3 data-nodeid="224825">Serverless 从何而来</h3>
<p data-nodeid="224826">Serverless 并不是一个全新的产物，而是一种构建和管理基于微服务架构的完整流程，允许在服务部署级别而不是在服务器部署级别来管理你的应用部署。与传统架构的不同之处在于，它完全由云厂商管理，由事件触发，以无状态的方式运行（可能只存在于一次调用的过程中）在容器内。</p>
<h3 data-nodeid="224827">Serverless 的组成</h3>
<p data-nodeid="224828">Serverless 架构由两部分组成，即 FaaS 和 BaaS。</p>
<p data-nodeid="224829">FaaS（Function-as-a-Service）函数即服务，一个函数就是一个服务，函数可以由任何语言编写，除此之外不需要关心任何运维细节，比如计算资源、弹性扩容，而且还可以按量计费，且支持事件驱动。</p>
<p data-nodeid="224830">BaaS（Backend-as-a-Service）后端即服务，集成了许多中间件技术，比如数据即服务（数据库服务）、缓存、网关等。</p>
<h3 data-nodeid="224831">Serverless 的特点</h3>
<p data-nodeid="224832">了解完 Serverless 的基础概念，我们再来看看它有哪些特点。</p>
<h4 data-nodeid="224833">免维护</h4>
<p data-nodeid="224834">Serverless 不仅提供了运行代码的环境，还能自动实现负载均衡、弹性伸缩这类高级功能，极大地降低了服务搭建的复杂性，有效提升开发和迭代的速度。</p>
<h4 data-nodeid="224835">费用</h4>
<p data-nodeid="224836">如果只考虑 FaaS，那么费用是比较便宜的。</p>
<p data-nodeid="224837">以阿里云的函数计算为例，费用包括调用次数、执行时间、公网流量 3 个因素。调用次数和执行时间都有免费额度，即使超过，单次/每秒的费用也非常低，这种按需收费的方式就避免了资源的浪费。</p>
<p data-nodeid="226013">流量费用则稍贵，达到 0.8 元/GB，而且没有免费额度，所以对于通信数据量比较大的场景还是要慎重使用。</p>
<p data-nodeid="226287"><img src="https://s0.lgstatic.com/i/image/M00/4D/DA/Ciqc1F9bVNSABY8aAADMDBAJigk871.png" alt="Lark20200911-184216.png" data-nodeid="226290"></p>




<h4 data-nodeid="224840">深度绑定</h4>
<p data-nodeid="224841">通常使用某个云厂商的 Serverless 产品时，可能会包括多种产品，如函数计算、对象存储、数据库等，而这些产品和云厂商又深度绑定，所以如果要进行迁移，成本相对于部署在服务器而言会增加很多。</p>
<h4 data-nodeid="224842">运行时长限制</h4>
<p data-nodeid="224843">通常云厂商对于 Serverless 中的函数执行时间是有限制的，如阿里云的函数计算产品，最大执行时长为 10 分钟，如果执行长时间任务，还需要单独申请调整时长上限，或者自行将超时函数拆分成粒度更小的函数，但是这种方式会增加一定的开发成本。</p>
<h4 data-nodeid="224844">冷启动</h4>
<p data-nodeid="224845">由于函数是按需执行的，首次执行时会创建运行容器，一般这个创建环境的时间在几百毫秒，在延迟敏感的业务场景下需要进行优化，比如定时触发函数或者设置预留实例。</p>
<h3 data-nodeid="224846">Serverless 的应用场景</h3>
<p data-nodeid="224847">以阿里云的函数计算为例，可以分为两类：事件函数和 HTTP 函数。</p>
<ul data-nodeid="224848">
<li data-nodeid="224849">
<p data-nodeid="224850"><strong data-nodeid="224917">事件函数</strong>。事件函数的执行方式有两种，一种是通过 SDK 提供的 API 函数调用它，基于此可以进行一些轻量计算操作，比如对图片进行压缩、格式转换，又或者执行一些 AI 训练任务；另一种是通过配置时间和间隔，让其自动执行，一些常见的自动执行场景包括文件备份、数据统计等。</p>
</li>
<li data-nodeid="224851">
<p data-nodeid="224852"><strong data-nodeid="224922">HTTP 函数</strong>。每一个 HTTP 函数都有特定的域名来供外部访问，当这个域名被访问时，函数将会被创建并执行。可以使用 HTTP 函数为前后端分离架构的 Web 应用提供后端数据支撑，比如提供获取天气 API 查看实时天气，或者提供 API 来读写数据库。</p>
</li>
</ul>
<h3 data-nodeid="224853">Serverless 实例</h3>
<p data-nodeid="225211">下面来分析讲解一个使用阿里云函数计算来实现代码自动部署的例子。函数要实现的功能就是，当 GitHub 仓库中的某个分支有新的提交时，拉取最新代码并编译，然后将编译生成的代码部署到 OSS 存储的静态服务器上。</p>
<p data-nodeid="225746" class=""><img src="https://s0.lgstatic.com/i/image/M00/4D/E5/CgqCHl9bVLaATst6AADK7ETww2g973.png" alt="Lark20200911-184226.png" data-nodeid="225750"></p>
<div data-nodeid="225747"><p style="text-align:center">自动部署流程图</p></div>







<p data-nodeid="224857">在这个例子中，两种函数都会用到。</p>
<p data-nodeid="224858">首先是 HTTP 函数负责接收 GitHub 发出的 webhook 请求，当收到请求后使用内部模块调用一个事件函数，在这个事件函数中执行具体的操作。虽然理论上一个 HTTP 函数可以实现，但拆解成两个函数可以有效避免函数执行时间过长导致的 webhook 请求超时报错。</p>
<p data-nodeid="224859">下面是 HTTP 函数源码：</p>
<pre class="lang-javascript" data-nodeid="224860"><code data-language="javascript"><span class="hljs-comment">/**
&nbsp;* ACCOUNT_ID 主账号ID
&nbsp;* ACCESS_KEY_ID 访问 bucket 所需要的 key
&nbsp;* ACCESS_KEY_SECRET 访问 bucket 所需要的 secret
&nbsp;* REGION bucket 所在的 region
&nbsp;* BUCKET 用于存储配置文件的 bucket
&nbsp;*/</span>
<span class="hljs-keyword">const</span> &#123;
&nbsp; ACCOUNT_ID,
&nbsp; ACCESS_KEY_ID,
&nbsp; ACCESS_KEY_SECRET,
&nbsp; REGION,
&nbsp; BUCKET
&#125; = process.env
<span class="hljs-keyword">const</span> FCClient = <span class="hljs-built_in">require</span>(<span class="hljs-string">'@alicloud/fc2'</span>);
<span class="hljs-keyword">const</span> OSS = <span class="hljs-built_in">require</span>(<span class="hljs-string">'ali-oss'</span>)
<span class="hljs-keyword">const</span> getRawBody = <span class="hljs-built_in">require</span>(<span class="hljs-string">'raw-body'</span>)
<span class="hljs-comment">/**
&nbsp;*&nbsp;
&nbsp;* <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> </span>filePath 函数计算配置文件路径
&nbsp;*/</span>
<span class="hljs-keyword">const</span> getOSSConfigFile = <span class="hljs-keyword">async</span> (filePath) =&gt; &#123;
&nbsp; <span class="hljs-keyword">try</span> &#123;
&nbsp; &nbsp; <span class="hljs-keyword">const</span> client = <span class="hljs-keyword">new</span> OSS(&#123;
&nbsp; &nbsp; &nbsp; <span class="hljs-attr">region</span>: REGION,
&nbsp; &nbsp; &nbsp; <span class="hljs-attr">accessKeyId</span>: ACCESS_KEY_ID,
&nbsp; &nbsp; &nbsp; <span class="hljs-attr">accessKeySecret</span>: ACCESS_KEY_SECRET,
&nbsp; &nbsp; &nbsp; <span class="hljs-attr">bucket</span>: BUCKET
&nbsp; &nbsp; &#125;);
&nbsp; &nbsp; <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> client.get(filePath);
&nbsp; &nbsp; <span class="hljs-keyword">const</span> content = result.content ? result.content.toString() : <span class="hljs-string">'&#123;&#125;'</span>
&nbsp; &nbsp; <span class="hljs-keyword">return</span> <span class="hljs-built_in">JSON</span>.parse(content)
&nbsp; &#125; <span class="hljs-keyword">catch</span>(e) &#123;
&nbsp; &nbsp; <span class="hljs-built_in">console</span>.error(e)
&nbsp; &nbsp; <span class="hljs-keyword">return</span> &#123;&#125;
&nbsp; &#125;
&#125;


<p><span class="hljs-built_in">exports</span>.handler &#x3D; <span class="hljs-function">(<span class="hljs-params">req, resp</span>) &#x3D;&gt;</span> &#123;<br>&amp;nbsp; getRawBody(req, <span class="hljs-keyword">async</span> (e, payload) &#x3D;&gt; &#123;<br>&amp;nbsp; &amp;nbsp; <span class="hljs-keyword">const</span> body &#x3D; <span class="hljs-built_in">JSON</span>.parse(payload)<br>&amp;nbsp; &amp;nbsp; <span class="hljs-keyword">if</span> (e) &#123;<br>&amp;nbsp; &amp;nbsp; &amp;nbsp; <span class="hljs-built_in">console</span>.error(e)<br>&amp;nbsp; &amp;nbsp; &amp;nbsp; resp.setStatusCode(<span class="hljs-number">400</span>)<br>&amp;nbsp; &amp;nbsp; &amp;nbsp; resp.send(<span class="hljs-string">‘请求体解析失败’</span>)<br>&amp;nbsp; &amp;nbsp; &amp;nbsp; <span class="hljs-keyword">return</span><br>&amp;nbsp; &amp;nbsp; &#125;<br>&amp;nbsp; &amp;nbsp; <span class="hljs-keyword">let</span> cfg<br>&amp;nbsp; &amp;nbsp; <span class="hljs-keyword">try</span> &#123;<br>&amp;nbsp; &amp;nbsp; &amp;nbsp; <span class="hljs-keyword">let</span> config<br>&amp;nbsp; &amp;nbsp; &amp;nbsp; config &#x3D; <span class="hljs-keyword">await</span> getOSSConfigFile(<span class="hljs-string"><code>/config/&lt;span class=&quot;hljs-subst&quot;&gt;$&#123;body.repository.name&#125;&lt;/span&gt;.json</code></span>) || {}<br>&amp;nbsp; &amp;nbsp; &amp;nbsp; cfg &#x3D; config.action[body.action]<br>&amp;nbsp; &amp;nbsp; &amp;nbsp; <span class="hljs-keyword">if</span> (!cfg) {<br>&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; <span class="hljs-built_in">console</span>.error(config.action, body.action)<br>&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">‘未找到对应仓库的配置信息.’</span>)<br>&amp;nbsp; &amp;nbsp; &amp;nbsp; }<br>&amp;nbsp; &amp;nbsp; } <span class="hljs-keyword">catch</span> (e) {<br>&amp;nbsp; &amp;nbsp; &amp;nbsp; <span class="hljs-built_in">console</span>.error(e)<br>&amp;nbsp; &amp;nbsp; &amp;nbsp; resp.setStatusCode(<span class="hljs-number">500</span>)<br>&amp;nbsp; &amp;nbsp; &amp;nbsp; resp.send(e.message)<br>&amp;nbsp; &amp;nbsp; &amp;nbsp; <span class="hljs-keyword">return</span><br>&amp;nbsp; &amp;nbsp; }<br>&amp;nbsp; &amp;nbsp; <span class="hljs-keyword">if</span> (cfg) {<br>&amp;nbsp; &amp;nbsp; &amp;nbsp; <span class="hljs-keyword">const</span> client &#x3D; <span class="hljs-keyword">new</span> FCClient(ACCOUNT_ID, {<br>&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; <span class="hljs-attr">accessKeyID</span>: ACCESS_KEY_ID,<br>&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; <span class="hljs-attr">accessKeySecret</span>: ACCESS_KEY_SECRET,<br>&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; <span class="hljs-attr">region</span>: cfg.region<br>&amp;nbsp; &amp;nbsp; &amp;nbsp; });<br>&amp;nbsp; &amp;nbsp; &amp;nbsp; client.invokeFunction(cfg.service, cfg.name, <span class="hljs-built_in">JSON</span>.stringify(cfg)).catch(<span class="hljs-built_in">console</span>.error)<br>&amp;nbsp; &amp;nbsp; &amp;nbsp; resp.send(<span class="hljs-string"><code>client.invokeFunction(&lt;span class=&quot;hljs-subst&quot;&gt;$&#123;cfg.service&#125;&lt;/span&gt;, &lt;span class=&quot;hljs-subst&quot;&gt;$&#123;cfg.name&#125;&lt;/span&gt;, &lt;span class=&quot;hljs-subst&quot;&gt;$&#123;&lt;span class=&quot;hljs-built_in&quot;&gt;JSON&lt;/span&gt;.stringify(cfg)&#125;&lt;/span&gt;)</code></span>)<br>&amp;nbsp; &amp;nbsp; }<br>&amp;nbsp; })<br>}<br></code></pre></p>
<p data-nodeid="224861">简单的实现方式就是解析 webhook 请求体内部的参数，获取仓库名和分支名传递给事件函数，但考虑可扩展性，对每个项目仓库使用了单独的配置文件。具体到代码中就是调用 getOSSConfigFile() 函数来从 OSS 存储上读取仓库相关的配置文件信息，然后通过 invokeFunction() 函数调用事件函数并将配置信息传递给事件函数。</p>
<p data-nodeid="224862">这样的好处在于，之后要新增其他仓库或其他分支的时候，只需要新增一个配置文件就可以了。</p>
<p data-nodeid="224863">再来看看事件函数的入口函数实现。</p>
<p data-nodeid="224864">前面在讲 Serverless 函数冷启动问题的时候提到过，函数执行完成后会存活一段时间，在这段时间内再次调用会执行之前创建的函数，短时间内重复执行的话会因为已经存在目录导致拉取失败，所以创建了随机目录并修改工作目录到随机目录下以获取写权限。</p>
<p data-nodeid="224865">然后再根据配置文件中的信息，按串行加载对应的执行模块并传入参数。</p>
<pre class="lang-javascript" data-nodeid="224866"><code data-language="javascript"><span class="hljs-keyword">const</span>&nbsp;fs&nbsp;=&nbsp;<span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>)
<span class="hljs-comment">/**
&nbsp;*&nbsp;
&nbsp;*&nbsp;<span class="hljs-doctag">@param&nbsp;<span class="hljs-type">&#123;*&#125;</span>&nbsp;</span>event&nbsp;
&nbsp;*&nbsp;&nbsp;&nbsp;&#123;
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;repo&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;仓库地址
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;region&nbsp;&nbsp;&nbsp;bucket&nbsp;所在区域
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bucket&nbsp;&nbsp;&nbsp;编译后部署的bucket
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;command&nbsp;&nbsp;编译命令
&nbsp;*&nbsp;&nbsp;&nbsp;&#125;
&nbsp;*&nbsp;<span class="hljs-doctag">@param&nbsp;<span class="hljs-type">&#123;*&#125;</span>&nbsp;</span>context&nbsp;
&nbsp;*&nbsp;<span class="hljs-doctag">@param&nbsp;<span class="hljs-type">&#123;*&#125;</span>&nbsp;</span>callback&nbsp;
&nbsp;*/</span>
<span class="hljs-built_in">exports</span>.handler&nbsp;=&nbsp;<span class="hljs-keyword">async</span>&nbsp;(event,&nbsp;context,&nbsp;callback)&nbsp;=&gt;&nbsp;&#123;
&nbsp;&nbsp;<span class="hljs-keyword">const</span>&nbsp;&#123;events&#125;&nbsp;=&nbsp;Buffer.isBuffer(event)&nbsp;?&nbsp;<span class="hljs-built_in">JSON</span>.parse(event.toString())&nbsp;:&nbsp;event
&nbsp;&nbsp;<span class="hljs-keyword">let</span>&nbsp;dir&nbsp;=&nbsp;<span class="hljs-built_in">Math</span>.random().toString(<span class="hljs-number">36</span>).substr(<span class="hljs-number">6</span>)
&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;设置随机临时工作目录，避免容器未销毁的情况下，重复拉取仓库失败</span>
&nbsp;&nbsp;<span class="hljs-keyword">const</span>&nbsp;workDir&nbsp;=&nbsp;<span class="hljs-string">`/tmp/<span class="hljs-subst">$&#123;dir&#125;</span>`</span>
&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;为了保证后续流程能找到临时工作目录，设置为全局变量</span>
&nbsp;&nbsp;<span class="hljs-built_in">global</span>.workDir&nbsp;=&nbsp;workDir&nbsp;
&nbsp;&nbsp;<span class="hljs-keyword">try</span>&nbsp;&#123;
&nbsp;&nbsp;&nbsp;&nbsp;fs.mkdirSync(workDir)
&nbsp;&nbsp;&#125;&nbsp;<span class="hljs-keyword">catch</span>(e)&nbsp;&#123;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-built_in">console</span>.error(e)
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span>
&nbsp;&nbsp;&#125;
&nbsp;&nbsp;process.chdir(workDir);
&nbsp;&nbsp;<span class="hljs-keyword">try</span>&nbsp;&#123;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">await</span>&nbsp;events.reduce(<span class="hljs-keyword">async</span>&nbsp;(acc,&nbsp;cur)&nbsp;=&gt;&nbsp;&#123;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">await</span>&nbsp;acc
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span>&nbsp;<span class="hljs-built_in">require</span>(<span class="hljs-string">`./<span class="hljs-subst">$&#123;cur.<span class="hljs-built_in">module</span>&#125;</span>`</span>)(cur)
&nbsp;&nbsp;&nbsp;&nbsp;&#125;,&nbsp;<span class="hljs-built_in">Promise</span>.resolve())
&nbsp;&nbsp;&nbsp;&nbsp;callback(<span class="hljs-literal">null</span>,&nbsp;<span class="hljs-string">`自动部署成功.`</span>);
&nbsp;&nbsp;&#125;&nbsp;<span class="hljs-keyword">catch</span>(e)&nbsp;&#123;
&nbsp;&nbsp;&nbsp;&nbsp;callback(e)
&nbsp;&nbsp;&#125;
&#125;
</code></pre>
<p data-nodeid="224867">具体有哪些模块呢？一般的部署过程主要包括 3 步：拉取仓库代码、安装依赖并构建、将生成的代码上传部署。</p>
<p data-nodeid="224868">拉取代码对于手动操作而言很简单，一条 git clone 命令就搞定了，但在自动化实现的时候会碰到一些麻烦的细节问题。</p>
<p data-nodeid="224869">首先身份认证问题。由于是私有仓库，所以只能通过密钥文件或账号密码的形式来认证访问权限。如果通过账号密码的形式登录，则要模拟键终端交互，这个相对而言实现成本较高，所以采用了配置 ssh key 的方式。具体是根据前面传入的配置信息找到私钥文件所在地址并下载到本地，但是因为权限问题，并不能直接保存到当前用户的 .ssh 目录下。</p>
<p data-nodeid="224870">另一个问题是在首次进行 git clone 操作的时候，终端会出现一个是否添加 known hosts 的提示，在终端中操作的时候需要键盘输入 “Y” 或者 “N” 来继续后面的操作。这里可以通过一个选项本来关闭这个提示。</p>
<p data-nodeid="224871">具体实现参考下面的 shell 脚本。</p>
<pre class="lang-shell" data-nodeid="224872"><code data-language="shell"><span class="hljs-meta">#</span><span class="bash">!/bin/sh</span>
ID_RSA=/tmp/id_rsa
exec /usr/bin/ssh -o StrictHostKeyChecking=no -o GSSAPIAuthentication=no -i $ID_RSA "$@"
</code></pre>
<p data-nodeid="224873">解决了比较麻烦的身份认证和终端交互问题之后，剩下的逻辑就比较简单了，执行 git clone 命令拉取仓库代码就行，为了加快速下载速度，可以通过设置 --depth 1 这个参数来指定只拉取最新提交的代码。</p>
<pre class="lang-javascript" data-nodeid="224874"><code data-language="javascript"><span class="hljs-keyword">const</span> OSS = <span class="hljs-built_in">require</span>(<span class="hljs-string">'ali-oss'</span>)
<span class="hljs-keyword">const</span> cp = <span class="hljs-built_in">require</span>(<span class="hljs-string">'child_process'</span>)
<span class="hljs-keyword">const</span> &#123; BUCKET, REGION, ACCESS_KEY_ID, ACCESS_KEY_SECRET &#125; = process.env
<span class="hljs-keyword">const</span> shellFile = <span class="hljs-string">'ssh.sh'</span>
<span class="hljs-comment">/**
&nbsp;*&nbsp;
&nbsp;* <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> </span>repoURL 代码仓库地址
&nbsp;* <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> </span>repoKey 访问代码仓库所需要的密钥文件路径
&nbsp;* <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> </span>branch&nbsp; 分支名称
&nbsp;*/</span>
<span class="hljs-keyword">const</span> downloadRepo = <span class="hljs-keyword">async</span> (&#123;repoURL, repoKey, branch=<span class="hljs-string">'master'</span>&#125;, retryTimes = <span class="hljs-number">0</span>) =&gt; &#123;
&nbsp; <span class="hljs-keyword">try</span> &#123;
&nbsp; &nbsp; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Download repo <span class="hljs-subst">$&#123;repoURL&#125;</span>`</span>);
&nbsp; &nbsp; process.chdir(<span class="hljs-built_in">global</span>.workDir)
&nbsp; &nbsp; <span class="hljs-keyword">const</span> client = <span class="hljs-keyword">new</span> OSS(&#123;
&nbsp; &nbsp; &nbsp; <span class="hljs-attr">accessKeyId</span>: ACCESS_KEY_ID,
&nbsp; &nbsp; &nbsp; <span class="hljs-attr">accessKeySecret</span>: ACCESS_KEY_SECRET,
&nbsp; &nbsp; &nbsp; <span class="hljs-attr">region</span>: REGION,
&nbsp; &nbsp; &nbsp; <span class="hljs-attr">bucket</span>: BUCKET
&nbsp; &nbsp; &#125;);
&nbsp; &nbsp; <span class="hljs-keyword">await</span> client.get(repoKey, <span class="hljs-string">`./id_rsa`</span>);
&nbsp; &nbsp; <span class="hljs-keyword">await</span> client.get(shellFile, <span class="hljs-string">`./<span class="hljs-subst">$&#123;shellFile&#125;</span>`</span>);
&nbsp; &nbsp; cp.execSync(<span class="hljs-string">`chmod 0600 ./id_rsa`</span>);
&nbsp; &nbsp; cp.execSync(<span class="hljs-string">`chmod +x ./<span class="hljs-subst">$&#123;shellFile&#125;</span>`</span>);
&nbsp; &nbsp; cp.execSync(<span class="hljs-string">`GIT_SSH="./<span class="hljs-subst">$&#123;shellFile&#125;</span>" git clone -b <span class="hljs-subst">$&#123;branch&#125;</span> --depth 1 <span class="hljs-subst">$&#123;repoURL&#125;</span>`</span>);
&nbsp; &nbsp; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'downloaded'</span>);
&nbsp; &#125; <span class="hljs-keyword">catch</span> (e) &#123;
&nbsp; &nbsp; <span class="hljs-built_in">console</span>.error(e);
&nbsp; &nbsp; <span class="hljs-keyword">if</span> (retryTimes &lt; <span class="hljs-number">2</span>) &#123;
&nbsp; &nbsp; &nbsp; downloadRepo(&#123;repoURL, repoKey, branch&#125;, retryTimes++);
&nbsp; &nbsp; &#125; <span class="hljs-keyword">else</span> &#123;
&nbsp; &nbsp; &nbsp; <span class="hljs-keyword">throw</span> e
&nbsp; &nbsp; &#125;
&nbsp; &#125;
&#125;;
<span class="hljs-built_in">module</span>.exports = downloadRepo
</code></pre>
<p data-nodeid="224875">安装依赖并构建这个步骤没有太多复杂的地方，通过子进程调用 yarn install --check-files 命令，然后执行 package.json 文件中配置的脚本任务即可。具体代码如下：</p>
<pre class="lang-javascript" data-nodeid="224876"><code data-language="javascript"><span class="hljs-keyword">const</span> cp = <span class="hljs-built_in">require</span>(<span class="hljs-string">'child_process'</span>)


<p><span class="hljs-keyword">const</span> install &#x3D; <span class="hljs-function">(<span class="hljs-params">repoName, retryTimes &#x3D; <span class="hljs-number">0</span></span>) &#x3D;&gt;</span> &#123;<br>&amp;nbsp; <span class="hljs-keyword">try</span> &#123;<br>&amp;nbsp; &amp;nbsp; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">‘Install dependencies.’</span>);<br>&amp;nbsp; &amp;nbsp; cp.execSync(<span class="hljs-string"><code>yarn install --check-files</code></span>);<br>&amp;nbsp; &amp;nbsp; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">‘Installed.’</span>);<br>&amp;nbsp; &amp;nbsp; retryTimes &#x3D; <span class="hljs-number">0</span><br>&amp;nbsp; } <span class="hljs-keyword">catch</span> (e) {<br>&amp;nbsp; &amp;nbsp; <span class="hljs-built_in">console</span>.error(e.message);<br>&amp;nbsp; &amp;nbsp; <span class="hljs-keyword">if</span> (retryTimes &lt; <span class="hljs-number">2</span>) {<br>&amp;nbsp; &amp;nbsp; &amp;nbsp; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">‘Retry install…’</span>);<br>&amp;nbsp; &amp;nbsp; &amp;nbsp; install(repoName, ++retryTimes);<br>&amp;nbsp; &amp;nbsp; } <span class="hljs-keyword">else</span> {<br>&amp;nbsp; &amp;nbsp; &amp;nbsp; <span class="hljs-keyword">throw</span> e<br>&amp;nbsp; &amp;nbsp; }<br>&amp;nbsp; }<br>}<br><span class="hljs-keyword">const</span> build &#x3D; <span class="hljs-function">(<span class="hljs-params">command, retryTimes &#x3D; <span class="hljs-number">0</span></span>) &#x3D;&gt;</span> {<br>&amp;nbsp; <span class="hljs-keyword">try</span> {<br>&amp;nbsp; &amp;nbsp; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">‘Build code.’</span>)<br>&amp;nbsp; &amp;nbsp; cp.execSync(<span class="hljs-string"><code>&lt;span class=&quot;hljs-subst&quot;&gt;$&#123;command&#125;&lt;/span&gt;</code></span>);<br>&amp;nbsp; &amp;nbsp; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">‘Built.’</span>);<br>&amp;nbsp; } <span class="hljs-keyword">catch</span> (e) {<br>&amp;nbsp; &amp;nbsp; <span class="hljs-built_in">console</span>.error(e.message);<br>&amp;nbsp; &amp;nbsp; <span class="hljs-keyword">if</span> (retryTimes &lt; <span class="hljs-number">2</span>) {<br>&amp;nbsp; &amp;nbsp; &amp;nbsp; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">‘Retry build…’</span>);<br>&amp;nbsp; &amp;nbsp; &amp;nbsp; build(command, ++retryTimes);<br>&amp;nbsp; &amp;nbsp; } <span class="hljs-keyword">else</span> {<br>&amp;nbsp; &amp;nbsp; &amp;nbsp; <span class="hljs-keyword">throw</span> e<br>&amp;nbsp; &amp;nbsp; }<br>&amp;nbsp; }<br>};</p>
<p><span class="hljs-built_in">module</span>.exports &#x3D; <span class="hljs-function">(<span class="hljs-params">{<br>&amp;nbsp; repoName,<br>&amp;nbsp; command<br>}</span>) &#x3D;&gt;</span> {<br>&amp;nbsp; <span class="hljs-keyword">const</span> {<br>&amp;nbsp; &amp;nbsp; workDir<br>&amp;nbsp; } &#x3D; <span class="hljs-built_in">global</span><br>&amp;nbsp; process.chdir(<span class="hljs-string"><code>&lt;span class=&quot;hljs-subst&quot;&gt;$&#123;workDir&#125;&lt;/span&gt;/&lt;span class=&quot;hljs-subst&quot;&gt;$&#123;repoName&#125;&lt;/span&gt;</code></span>)<br>&amp;nbsp; install(repoName)<br>&amp;nbsp; build(command)<br>}<br></code></pre></p>
<p data-nodeid="224877">最后上传部署可以根据不同的场景编写不同的模块，比如有的可能部署在 OSS 存储上，会需要调用 OSS 对应的 SDK 进行上传，有的可能部署在某台服务器上，需要通过 scp 命令来传输。</p>
<p data-nodeid="224878">下面是一个部署到 OSS 存储的例子。</p>
<pre class="lang-javascript" data-nodeid="224879"><code data-language="javascript"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>);
<span class="hljs-keyword">const</span> OSS = <span class="hljs-built_in">require</span>(<span class="hljs-string">'ali-oss'</span>);
<span class="hljs-comment">// 遍历函数</span>
<span class="hljs-keyword">const</span> traverse = <span class="hljs-function">(<span class="hljs-params">dirPath, arr = []</span>) =&gt;</span> &#123;
&nbsp; <span class="hljs-keyword">var</span> filesList = fs.readdirSync(dirPath);
&nbsp; <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; filesList.length; i++) &#123;
&nbsp; &nbsp; <span class="hljs-keyword">var</span> fileObj = &#123;&#125;;
&nbsp; &nbsp; fileObj.name = path.join(dirPath, filesList[i]);
&nbsp; &nbsp; <span class="hljs-keyword">var</span> filePath = path.join(dirPath, filesList[i]);
&nbsp; &nbsp; <span class="hljs-keyword">var</span> stats = fs.statSync(filePath);
&nbsp; &nbsp; <span class="hljs-keyword">if</span> (stats.isDirectory()) &#123;
&nbsp; &nbsp; &nbsp; traverse(filePath, arr);
&nbsp; &nbsp; &#125; <span class="hljs-keyword">else</span> &#123;
&nbsp; &nbsp; &nbsp; fileObj.type = path.extname(filesList[i]).substring(<span class="hljs-number">1</span>);
&nbsp; &nbsp; &nbsp; arr.push(fileObj);
&nbsp; &nbsp; &#125;
&nbsp; &#125;
&nbsp; <span class="hljs-keyword">return</span> arr
&#125;
<span class="hljs-comment">/**
&nbsp;*&nbsp;
&nbsp;* <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">repoName</span></span>
&nbsp;*&nbsp;
&nbsp;*/</span>
<span class="hljs-keyword">const</span> deploy = <span class="hljs-function">(<span class="hljs-params">&#123; dist = <span class="hljs-string">''</span>, source, region, accessKeyId, accessKeySecret, bucket, repoName &#125;, retryTimes = <span class="hljs-number">0</span></span>) =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-keyword">async</span> (res) =&gt; &#123;
&nbsp; <span class="hljs-keyword">const</span> &#123; workDir &#125; = <span class="hljs-built_in">global</span>
&nbsp; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Deploy.'</span>);
&nbsp; <span class="hljs-keyword">try</span> &#123;
&nbsp; &nbsp; <span class="hljs-keyword">const</span> client = <span class="hljs-keyword">new</span> OSS(&#123;
&nbsp; &nbsp; &nbsp; region,
&nbsp; &nbsp; &nbsp; accessKeyId,
&nbsp; &nbsp; &nbsp; accessKeySecret,
&nbsp; &nbsp; &nbsp; bucket
&nbsp; &nbsp; &#125;);
&nbsp; &nbsp; process.chdir(<span class="hljs-string">`<span class="hljs-subst">$&#123;workDir&#125;</span>/<span class="hljs-subst">$&#123;repoName&#125;</span>`</span>)
&nbsp; &nbsp; <span class="hljs-keyword">const</span> root = path.join(process.cwd(), source)
&nbsp; &nbsp; <span class="hljs-keyword">let</span> files = traverse(root, []);
&nbsp; &nbsp; <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.all(files.map(<span class="hljs-function">(<span class="hljs-params">&#123; name &#125;, index</span>) =&gt;</span> &#123;
&nbsp; &nbsp; &nbsp; <span class="hljs-keyword">const</span> remotePath = path.join(dist, name.replace(root + <span class="hljs-string">'/'</span>, <span class="hljs-string">''</span>));
&nbsp; &nbsp; &nbsp; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`[<span class="hljs-subst">$&#123;index&#125;</span>] uploaded <span class="hljs-subst">$&#123;name&#125;</span> to <span class="hljs-subst">$&#123;remotePath&#125;</span>`</span>);
&nbsp; &nbsp; &nbsp; <span class="hljs-keyword">return</span> client.put(remotePath, name);
&nbsp; &nbsp; &#125;));
&nbsp; &nbsp; res();
&nbsp; &nbsp; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Deployed.'</span>);
&nbsp; &#125; <span class="hljs-keyword">catch</span> (e) &#123;
&nbsp; &nbsp; <span class="hljs-built_in">console</span>.error(e);
&nbsp; &nbsp; <span class="hljs-keyword">if</span> (retryTimes &lt; <span class="hljs-number">2</span>) &#123;
&nbsp; &nbsp; &nbsp; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Retry deploy.'</span>);
&nbsp; &nbsp; &nbsp; deploy(&#123; dist, source, region, accessKeyId, accessKeySecret, bucket &#125;, ++retryTimes);
&nbsp; &nbsp; &#125; <span class="hljs-keyword">else</span> &#123;
&nbsp; &nbsp; &nbsp; <span class="hljs-keyword">throw</span> e
&nbsp; &nbsp; &#125;
&nbsp; &#125;
&#125;)
<span class="hljs-built_in">module</span>.exports = deploy
</code></pre>
<p data-nodeid="224880">由于未找到阿里云 OSS SDK 中上传目录的功能，所以只能通过深度遍历的方式来逐个将文件进行上传。考虑编译后生成地文件数量并不多，这里没有做并发数限制，而是将全部文件进行批量上传。</p>
<h3 data-nodeid="224881">总结</h3>
<p data-nodeid="224882">虽然 Serverless 并不属于前端开发范畴，但确实是一个具有通用性、开箱即用的产品。本课时的主要目的是起到一个抛砖引玉的作用，通过概念介绍以及函数计算的具体实例让你对其有一个初步的认识和了解。希望你在工作中能通过具体实践，不断探索它的使用边界和场景。</p>
<p data-nodeid="224883" class="">最后布置一道作业题：尝试部署一个 Serverless 服务。</p>




      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/11/02/%E5%89%8D%E7%AB%AF%E7%83%AD%E7%82%B9%E6%8A%80%E6%9C%AF%E4%B9%8B-Serverle/" data-id="claxeer9w000uv8w1b4ig3w7m" data-title="前端热点技术之 Serverle" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-到底该不该了解算法？" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/11/02/%E5%88%B0%E5%BA%95%E8%AF%A5%E4%B8%8D%E8%AF%A5%E4%BA%86%E8%A7%A3%E7%AE%97%E6%B3%95%EF%BC%9F/" class="article-date">
  <time class="dt-published" datetime="2022-11-02T02:55:42.000Z" itemprop="datePublished">2022-11-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/11/02/%E5%88%B0%E5%BA%95%E8%AF%A5%E4%B8%8D%E8%AF%A5%E4%BA%86%E8%A7%A3%E7%AE%97%E6%B3%95%EF%BC%9F/">到底该不该了解算法？</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p data-nodeid="5197" class="">算法是为了解决某个问题抽象而成的计算方法，我们可以简单地把算法比作一个拥有输入和输出的函数，这个函数总能在有限的时间经过有限的步骤给出特定的解。</p>
<p data-nodeid="5198">以往的前端开发场景中使用到算法的情况并不多，原因有下面 3 个。</p>
<ul data-nodeid="5199">
<li data-nodeid="5200">
<p data-nodeid="5201">前端开发场景更关注页面效果及用户交互，大多数开发的时候只需要按照自然逻辑来编写代码即可，比如响应用户事件、控制组件加载与页面跳转，对于数据的操作停留在校验、请求、提交及格式化这些基础的操作，涉及数据计算的场景比较少。</p>
</li>
<li data-nodeid="5202">
<p data-nodeid="5203">前端运行环境浏览器性能有限，如果把大量的数据放到前端进行计算，无论是网络加载还是渲染数据都将耗费大量时间，从而导致用户体验下降。</p>
</li>
<li data-nodeid="5204">
<p data-nodeid="5205">在多端的系统中，算法运用在后端会更加高效。如果将算法运用在前端，很可能意味着需要在不同环境用不同语言重新再实现一遍。举个简单而不是特别恰当的例子，假设需要给用户展现一个树形图表，如果后端直接返回关系数据库中查询到的表结构数据，那么前端则需要先将其转换成树结构的 JSON 数据才能填充到对应的组件，那么在 iOS 和 Android 设备上也要执行同样的逻辑，但是由于语言不同，这些代码逻辑无法复用，都必须单独编写；相反，如果后端拿到数据之后转化后再返回则能同时免去这些代码的编写。</p>
</li>
</ul>
<p data-nodeid="5206">但随着 Web 技术的不断发展，前端运行环境以及 Node.js 的计算能力不断加强，算法将被用于更多的开发场景中，对于前端工程师来说也将变得越来越重要。所以这一课时我们就来聊聊算法相关的内容。</p>
<h3 data-nodeid="5207">算法性能指标</h3>
<p data-nodeid="5208">在衡量算法优劣的时候通常会用到两个重要的性能指标：时间复杂度和空间复杂度，分别用来表述算法运行所需要的运行时间和存储空间。</p>
<p data-nodeid="5209">这里的“复杂度”我们可以理解为一个带有参数的函数，简写为 O，O 的参数一般为 1 或 n 的表达式。下面分别举例进行说明。</p>
<p data-nodeid="5210">假设现在需要对一个首项为 1、差值为 1 的等差数列数组 arr 进行求和。如果像下面的代码一样采用 reduce 操作，则意味着需要遍历数组 arr 之后才能得到计算结果；如果数组 arr 的长度为 n，那么对应的累加操作 acc+=cur 这个表达式将被执行 n 次，因此这个操作的时间复杂度为 O(n)。</p>
<pre class="lang-javascript" data-nodeid="5211"><code data-language="javascript">arr.reduce(<span class="hljs-function">(<span class="hljs-params">acc, cur</span>) =&gt;</span> acc+=cur, <span class="hljs-number">0</span>)
</code></pre>
<p data-nodeid="5212">对等差数列比较了解的同学应该知道，可以使用求和公式来计算结果，这样的话并不需要遍历数组，只需要把首项 arr[0]、项数 n 和公差 1 带入公式进行计算即可。</p>
<p data-nodeid="9667" class=""><img src="https://s0.lgstatic.com/i/image/M00/49/07/Ciqc1F9OIsmAfhPMAAAIB06k65c146.png" alt="image (8).png" data-nodeid="9671"></p>
<div data-nodeid="9668"><p style="text-align:center">等差数列求和公式</p></div>











<p></p>

<p></p>
<p data-nodeid="5215">整个操作只执行了一次，所以时间复杂度为 O(1)，要优于 O(n)。也就是说，时间复杂度取决于表达式执行次数。</p>
<p data-nodeid="5216">空间复杂度的计算思路和时间复杂度相似，但不是根据执行次数而是根据变量占用空间大小。下面通过一个例子进行说明。</p>
<p data-nodeid="5217">假设现在要将数组 arr 中的元素向前移动一位，第一个元素移动到最后一位。如果直接在原数组上进行操作，只借助一个额外的变量实现，那么空间复杂度为 O(1)。</p>
<pre class="lang-javascript" data-nodeid="5218"><code data-language="javascript"><span class="hljs-keyword">let</span> tmp = arr[<span class="hljs-number">0</span>]
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;arr.length - <span class="hljs-number">1</span>;i++) &#123;
  arr[i] = arr[i+<span class="hljs-number">1</span>]
&#125;
arr[arr.length - <span class="hljs-number">1</span>] = tmp
</code></pre>
<p data-nodeid="5219">如果将结果保存在一个新的数组中，那么空间复杂度为 O(n)。</p>
<pre class="lang-javascript" data-nodeid="5220"><code data-language="javascript"><span class="hljs-keyword">let</span> newArr = []
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;arr.length - <span class="hljs-number">1</span>;i++) &#123;
  newArr[i] = arr[i+<span class="hljs-number">1</span>]
&#125;
newArr.push(arr[<span class="hljs-number">0</span>])
</code></pre>
<p data-nodeid="5221">为了方便比较复杂度，复杂度的计算还遵循下面两个简写原则：</p>
<ul data-nodeid="5222">
<li data-nodeid="5223">
<p data-nodeid="5224">多项式组成的复杂度，取最高次项，并省略系数，比如 O(3n+1) 简写成 O(n)；</p>
</li>
<li data-nodeid="5225">
<p data-nodeid="5226">不同参数可以统一用 n 表示，比如遍历长度为 m 乘以 n 的数组，复杂度 O(mn) 写成 O(n^2)。</p>
</li>
</ul>
<p data-nodeid="5227">基于此，我们在优化算法时，如果只能优化系数或非最高次项操作，那么在算法复杂度计算来看，这种提升意义是比较小的。</p>
<p data-nodeid="5228">常用的复杂度从优到劣排序，依次如下：</p>
<pre class="lang-javascript" data-nodeid="5229"><code data-language="javascript">O(<span class="hljs-number">1</span>)&gt;O(logn)&gt;O(n)&gt;O(nlogn)&gt;O(n^<span class="hljs-number">2</span>)&gt;O(x^n)
</code></pre>
<p data-nodeid="5230">通常，如果不对复杂度进行特别说明，一般用时间复杂度指代算法复杂度。</p>
<h3 data-nodeid="5231">TimSort 排序</h3>
<p data-nodeid="5232">排序算法就是让线性结构的数据按照升序或降序的方式排列的操作，是最基础也是使用频率较高的算法。排序的意义在于可以大大减少后续操作的时间复杂度。例如，在一个数组中找到第 2 小的数，对于无序数组需要对数组进行遍历，那么时间复杂度为 O(n)，而在有序数组中可以直接通过下标获取，时间复杂度为 O(1)。</p>
<p data-nodeid="5233">正因如此，对于排序这个基础的操作有多种算法，对具体的算法感兴趣的同学可以看一些对比分析文章，比如<a target="_blank" rel="noopener" href="https://www.cnblogs.com/onepixel/articles/7674659.html" data-nodeid="5292">《十大经典排序算法（动图演示）》</a>，里面分析对比了主流排序算法的（平均、最优、最坏）时间复杂度、空间复杂度、稳定度。</p>
<p data-nodeid="9984" class="">在前端领域，排序属于日用而不知的算法，因为 JavaScript 引擎早已把高效的排序算法写入数组的原型函数 sort 中了，这种高效的排序算法就是 <strong data-nodeid="9990">TimSort</strong>。</p>
<p data-nodeid="5235">TimSort 是一种在 Java、Python 等多种语言环境广泛应用的排序算法，是根据作者姓名 Tim Peters 而命名的。它是一种典型的混合算法，同时采用了折半插入排序和归并排序。最好的情况下，时间复杂度可以达到 O(n)，最坏的情况下也能达到 O(nlogn)，空间复杂度在最好情况和最坏情况下分别为 O(1) 和 O(n)。</p>
<p data-nodeid="5236">TimSort 并不是简单地把两种排序方式进行组合，而是进行了一些优化。下面通过一个实例来了解它的具体实现步骤。</p>
<p data-nodeid="5237">假设要对一个整数数组进行 TimSort 排序，那么具体的操作步骤如下所示。</p>
<p data-nodeid="5238">首先，根据数组长度进行计算，得到一个数值 minRunLength，表示最小的子数组 run 的长度。minRunLength 的计算方式比较简单，对于长度小于 64 的数组直接返回数组长度，长度大于或等于 64 则不断除以 2 直到小于 64。 这个值的主要作用是用来控制 run 的数量，方便后续进行归并排序，避免一个超长 run 和一个超短 run 合并。</p>
<p data-nodeid="5239">其次，通过 while 循环遍历数组，计算下一个 run 的长度，具体计算方式其实是根据索引值来遍历数组的，从第一个元素开始找寻最长的有序子数组，如果和排序方式不一致（比如在升序排序中找到一个降序子数组），那么就进行反转，然后返回这个有序子数组的长度，赋值给变量 currentRunLength。</p>
<p data-nodeid="5240">再次，判断 currentRunLength 和 minRunLength 的大小，如果 currentRunLength 小于 minRunLength，那么通过折半插入排序合并成一个更长的 run。</p>
<p data-nodeid="5241">另外，将得到的 run 压入栈 pendingRuns 中，等待进一步的合并。</p>
<p data-nodeid="5242">进而，将 pendingRuns 中的部分 run 进行合并，使栈内的所有 run 都满足条件pendingRuns[i].length &gt; pendingRuns[i+1].length + pendingRuns[i+2].length &amp;&amp; pendingRuns[i].length &gt; pendingRuns[i+1].length。</p>
<p data-nodeid="5243">最后，按次序合并 pendingRuns 中的 run，得到最终结果。</p>
<blockquote data-nodeid="5244">
<p data-nodeid="5245">若对 JavaScript 中的 TimSort 实现仍有疑惑的话，建议查看具体源码，源码虽为 tq 文件，但语法风格和 JavaScript 差异不大。</p>
</blockquote>
<h3 data-nodeid="5246">补充 1：折半插入排序</h3>
<p data-nodeid="5247">折半插入排序（Binary Insertion Sort）是对插入排序算法的一种优化，插入排序算法就是不断地将元素插入前面已排好序的数组中，它的时间复杂度和空间复杂度分别为 O(n^2) 和 O(1)。折半插入就是用折半查找插入点取代按顺序依次寻找插入点，从而加快寻找插入点的速度。</p>
<p data-nodeid="5248">下面是一段通过折半插入排序来对数组进行升序排列的示例代码：</p>
<pre class="lang-javascript" data-nodeid="5249"><code data-language="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span>&nbsp;<span class="hljs-title">binayInsertionSort</span>(<span class="hljs-params">arr</span>)&nbsp;</span>&#123;
&nbsp;&nbsp;<span class="hljs-keyword">for</span>&nbsp;(<span class="hljs-keyword">var</span>&nbsp;i&nbsp;=&nbsp;<span class="hljs-number">1</span>;&nbsp;i&nbsp;&lt;&nbsp;arr.length;&nbsp;i++)&nbsp;&#123;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">if</span>&nbsp;(arr[i]&nbsp;&gt;=&nbsp;arr[i&nbsp;-&nbsp;<span class="hljs-number">1</span>])&nbsp;<span class="hljs-keyword">continue</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">let</span>&nbsp;temp&nbsp;=&nbsp;arr[i];
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">let</span>&nbsp;low&nbsp;=&nbsp;<span class="hljs-number">0</span>;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">let</span>&nbsp;high&nbsp;=&nbsp;i&nbsp;-&nbsp;<span class="hljs-number">1</span>;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">while</span>&nbsp;(low&nbsp;&lt;=&nbsp;high)&nbsp;&#123;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mid&nbsp;=&nbsp;<span class="hljs-built_in">Math</span>.floor((low&nbsp;+&nbsp;high)&nbsp;/&nbsp;<span class="hljs-number">2</span>);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">if</span>&nbsp;(temp&nbsp;&gt;&nbsp;arr[mid])&nbsp;&#123;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;low&nbsp;=&nbsp;mid&nbsp;+&nbsp;<span class="hljs-number">1</span>;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#125;&nbsp;<span class="hljs-keyword">else</span>&nbsp;&#123;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;high&nbsp;=&nbsp;mid&nbsp;-&nbsp;<span class="hljs-number">1</span>;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#125;
&nbsp;&nbsp;&nbsp;&nbsp;&#125;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">for</span>&nbsp;(<span class="hljs-keyword">var</span>&nbsp;j&nbsp;=&nbsp;i;&nbsp;j&nbsp;&gt;&nbsp;low;&nbsp;--j)&nbsp;&#123;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arr[j]&nbsp;=&nbsp;arr[j&nbsp;-&nbsp;<span class="hljs-number">1</span>];
&nbsp;&nbsp;&nbsp;&nbsp;&#125;
&nbsp;&nbsp;&nbsp;&nbsp;arr[j]&nbsp;=&nbsp;temp;
&nbsp;&nbsp;&#125;
&#125;
</code></pre>
<h3 data-nodeid="5250">补充 2：归并排序</h3>
<p data-nodeid="5251">归并排序（Merge Sort）采用分治法（Divide and Conquer）的思想（将原问题拆分成规模更小的子问题，然后递归求解），把数组拆分成子数组，先对每个子数组进行排序，然后再将有序的子数组进行合并，得到完全有序的数组。时间复杂度和空间复杂度分别为 O(nlogn) 和 O(n)。常见的将两个有序数组合并成一个有序数组的方式，称为<strong data-nodeid="5342">二路归并</strong>。</p>
<p data-nodeid="5252">下面是一段通过归并排序对数组进行升序排列的示例代码：</p>
<pre class="lang-javascript" data-nodeid="5253"><code data-language="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mergeSort</span>(<span class="hljs-params">array</span>) </span>&#123;
&nbsp; <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">merge</span>(<span class="hljs-params">leftArr, rightArr</span>) </span>&#123;
&nbsp; &nbsp; <span class="hljs-keyword">var</span> result = [];
&nbsp; &nbsp; <span class="hljs-keyword">while</span> (leftArr.length &gt; <span class="hljs-number">0</span> &amp;&amp; rightArr.length &gt; <span class="hljs-number">0</span>) &#123;
&nbsp; &nbsp; &nbsp; <span class="hljs-keyword">if</span> (leftArr[<span class="hljs-number">0</span>] &lt; rightArr[<span class="hljs-number">0</span>])
&nbsp; &nbsp; &nbsp; &nbsp; result.push(leftArr.shift());
&nbsp; &nbsp; &nbsp; <span class="hljs-keyword">else</span>
&nbsp; &nbsp; &nbsp; &nbsp; result.push(rightArr.shift());
&nbsp; &nbsp; &#125;
&nbsp; &nbsp; <span class="hljs-keyword">return</span> result.concat(leftArr).concat(rightArr);
&nbsp; &#125;
&nbsp; <span class="hljs-keyword">if</span> (array.length == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> array;
&nbsp; <span class="hljs-keyword">var</span> middle = <span class="hljs-built_in">Math</span>.floor(array.length / <span class="hljs-number">2</span>);
&nbsp; <span class="hljs-keyword">var</span> left = array.slice(<span class="hljs-number">0</span>, middle);
&nbsp; <span class="hljs-keyword">var</span> right = array.slice(middle);
&nbsp; <span class="hljs-keyword">return</span> merge(mergeSort(left), mergeSort(right));
&#125;
</code></pre>
<h3 data-nodeid="5254">总结</h3>
<p data-nodeid="5255">本课时首先介绍了算法的两个重要效率指标：时间复杂度和空间复杂度。时间复杂度根据执行次数来计算，空间复杂度根据临时变量的大小来计算。算法的复杂度用一个带有参数的函数 O 来表示，函数 O 的参数为 n 的多项式，为了方便比较，一般只会保留 n 的最高次项并省略系数。在常见的算法复杂度中，常数复杂度最优，指数复杂度最劣。</p>
<p data-nodeid="5256">在理解算法相关基础后重点分析了 JavaScript 的 Array.prototype.sort() 函数的底层实现算法 TimSort。TimSort 是一种混合排序算法，结合了折半插入排序和归并排序。</p>
<p data-nodeid="5257">TimSort 算法的优化思路，其实和性能优化的思路也有异曲同工之妙，在<a target="_blank" rel="noopener" href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=180#/detail/pc?id=3195" data-nodeid="5350">“第23讲：谈性能优化到底在谈什么？”</a>中提过，性能优化有两个方向：做减法和做除法。在 TimSort 中使用的归并排序将数据拆分 run，就带有做除法的思想，而在生成 run 的时候利用数据的有序性，这种和缓存类似的操作就是典型的做减法。</p>
<p data-nodeid="5258" class="">最后布置一道思考题：你在开发过程中还用到过哪些算法？欢迎在留言区分享你的经历。</p>

<hr>
<h3 id="精选评论"><a href="#精选评论" class="headerlink" title="精选评论"></a>精选评论</h3><h5 id="杰："><a href="#杰：" class="headerlink" title="*杰："></a>*杰：</h5><blockquote>
<p>timsort run栈里边第二个判断条件不是在第一个判断条件下的么pendingRuns[i].length  pendingRuns[i+1].length</p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-讲师回复："><a href="#amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; 3,2,1],[2,1],[1 就是一个满足第二个判断不满足第一个判断的例子。</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/11/02/%E5%88%B0%E5%BA%95%E8%AF%A5%E4%B8%8D%E8%AF%A5%E4%BA%86%E8%A7%A3%E7%AE%97%E6%B3%95%EF%BC%9F/" data-id="claxeer9v000sv8w1h3v1ha8h" data-title="到底该不该了解算法？" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-把路由放在前端意味着什么？" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/11/02/%E6%8A%8A%E8%B7%AF%E7%94%B1%E6%94%BE%E5%9C%A8%E5%89%8D%E7%AB%AF%E6%84%8F%E5%91%B3%E7%9D%80%E4%BB%80%E4%B9%88%EF%BC%9F/" class="article-date">
  <time class="dt-published" datetime="2022-11-02T02:54:56.000Z" itemprop="datePublished">2022-11-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/11/02/%E6%8A%8A%E8%B7%AF%E7%94%B1%E6%94%BE%E5%9C%A8%E5%89%8D%E7%AB%AF%E6%84%8F%E5%91%B3%E7%9D%80%E4%BB%80%E4%B9%88%EF%BC%9F/">把路由放在前端意味着什么？</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p data-nodeid="44690">当浏览器地址栏中的 URL 发生变化时，会请求对应的网络资源，而负责响应这个网络资源的服务就称为<strong data-nodeid="44756">路由</strong>。在早期的 Web 开发中，路由都是交由服务端处理，但随着前端技术的快速发展，路由模块逐渐转移交给了前端进行控制，而路由转移到前端，正是前后端分离和单页应用架构 的 基石。这一课时我们来深入理解前端路由的技术细节。</p>
<h3 data-nodeid="44691">前端路由实现基础</h3>
<p data-nodeid="44692">默认情况下，当地址栏的 URL 发生变化时，浏览器会向服务端发起新的请求。所以实现前端路由的重要基础就是在修改 URL 时，不引起浏览器向后端请求数据。根据浏览器提供的 API，有下面两种实现方案。</p>
<h4 data-nodeid="44693">基于 hash 实现</h4>
<p data-nodeid="44694">前面提到当 URL 变化时浏览器会发送请求，但有一种特例，那就是 hash 值的变化不会触发浏览器发起请求。</p>
<p data-nodeid="47382" class="">hash 值是指 URL“#”号后面的内容，通过 location.hash 属性可以读写 hash 值，这个值可以让浏览器将页面滚动到 ID 与 hash 值相等的 DOM 元素位置，不会传给服务端。</p>

<p data-nodeid="44696">要监听它的变化也比较简单，通过监听 window 对象的 hashchange 事件就可以感知到它的变化。</p>
<p data-nodeid="44697">这种实现方式占用了 hash 值，导致默认的页面滚动行为失效，对于有滚动定位需求的情况需要自行手动获取元素的位置并调用 BOM 相关 API 进行滚动。</p>
<h4 data-nodeid="44698">基于 history 实现</h4>
<p data-nodeid="44699">HTML 5 提出了一种更规范的前端路由实现方式，那就是通过 history 对象。</p>
<p data-nodeid="44700">history 提供了两个函数来修改 URL，即 history.pushState() 和 history.replaceState()，这两个 API 可以在不进行刷新的情况下，来操作浏览器的历史 记录 。唯一不同的是，前者是新增一个历史记录，后者是直接替换当前的历史记录。</p>
<p data-nodeid="44701">监听 URL 变化则可以通过监听 window 对象上的 popstate 事件来实现。但需要注意的是，history.pushState() 或 history.replaceState() 不会触发 popstate 事件，这时我们需要手动触发页面渲染。</p>
<p data-nodeid="44702">虽然能通过这种方式实现前端路由功能，但并不能拦截浏览器默认的请求行为，当用户修改地址栏网址时还是会向服务端发起请求，所以还需要服务端进行设置，将所有 URL 请求转向前端页面，交给前端进行解析。</p>
<p data-nodeid="44703">下面是 vue-router 官网的 Nginx 配置例子：表示对于匹配的路径，按照指定顺序依次检查对应路径文件是否存在，对应路径目录是否存在，如果没有找到任何文件 或目录 ，就返回 index.html。而 index.html 就会引入对应的 JavaScript 代码在浏览器端进行路由解析。</p>
<pre class="lang-js" data-nodeid="49148"><code data-language="js">location / &#123; 
  try_files $uri $uri/ /index.html; 
&#125; 
</code></pre>





<h3 data-nodeid="44705">路由解析</h3>
<p data-nodeid="44706">阻止浏览器在 URL 变化时向后端发送请求之后，就需要对路由进行解析了。 <a target="_blank" rel="noopener" href="https://router.vuejs.org/zh/" data-nodeid="44774">vue-router</a>和 <a target="_blank" rel="noopener" href="https://reactrouter.com/" data-nodeid="44778">react-router</a>都同时依赖了一个第三方库 <a target="_blank" rel="noopener" href="https://github.com/pillarjs/path-to-regexp" data-nodeid="44782">Path-to-RegExp</a>进行路由解析，下面通过分析 <a target="_blank" rel="noopener" href="https://github.com/pillarjs/path-to-regexp/archive/v1.8.0.zip" data-nodeid="44786">path-to-regexp 1.8 版本</a>的源码来理解路由是如何被解析的。</p>
<p data-nodeid="44707">路由解析又分为两个操作：<strong data-nodeid="44797">路由匹配</strong>和<strong data-nodeid="44798">路由生成</strong>。</p>
<h4 data-nodeid="44708">路由匹配</h4>
<p data-nodeid="44709">路由匹配就是当获取到请求路径后，如何找到对应的配置路径。在 path-to-regexp 源码中对应的是默认导出函数 pathToRegexp()，该函数接收 3 个参数：</p>
<ul data-nodeid="44710">
<li data-nodeid="44711">
<p data-nodeid="44712"><strong data-nodeid="44805">path</strong>，必传参数，值可以为自定义的请求路径，如 /user/:id，也可以是正则表达式，还可以是两者组成的数组；</p>
</li>
<li data-nodeid="44713">
<p data-nodeid="44714"><strong data-nodeid="44818">keys</strong>，可选参数， 值为 数组， 数组元素为 解析 正则表达式风格的字符串或冒号开头的占位符（下文简称为“特殊字符串”） 生成的令牌 ，比如字符串 /user/:id 对应的 keys 为 { name: 'id', delimiter: '/', optional: false, repeat: false } ，这个参数的值最终会被保存到返回的正则表达式对象的 keys 属性中，可用于后面的路由生成；</p>
</li>
<li data-nodeid="44715">
<p data-nodeid="44716"><strong data-nodeid="44823">options</strong>，可选参数，执行过程中的配置信息，比如是否大小写敏感。</p>
</li>
</ul>
<p data-nodeid="44717">函数返回值是一个带有 keys 属性的正则表达式，keys 属性值类型和 keys 参数相同，也是一个包含特殊字符串描述信息的数组。</p>
<p data-nodeid="44718">由于 path 参数可以是正则表达式、字符串、数组 3 种类型数据，所以在处理 path 参数的时候分别对应 3 个函数 regexpToRegexp()、stringToRegexp()、arrayToRegexp()。</p>
<pre class="lang-javascript" data-nodeid="44719"><code data-language="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span>&nbsp;<span class="hljs-title">pathToRegexp</span>&nbsp;(<span class="hljs-params">path,&nbsp;keys,&nbsp;options</span>)&nbsp;</span>&#123; 
&nbsp;&nbsp;<span class="hljs-keyword">if</span>&nbsp;(!isarray(keys))&nbsp;&#123; 
&nbsp;&nbsp;&nbsp;&nbsp;options&nbsp;=&nbsp;<span class="hljs-comment">/**&nbsp;@type&nbsp;&#123;!Object&#125;&nbsp;*/</span>&nbsp;(keys&nbsp;||&nbsp;options) 
&nbsp;&nbsp;&nbsp;&nbsp;keys&nbsp;=&nbsp;[] 
&nbsp;&nbsp;&#125; 
&nbsp;&nbsp;options&nbsp;=&nbsp;options&nbsp;||&nbsp;&#123;&#125; 
&nbsp;&nbsp;<span class="hljs-keyword">if</span>&nbsp;(path&nbsp;<span class="hljs-keyword">instanceof</span>&nbsp;<span class="hljs-built_in">RegExp</span>)&nbsp;&#123; 
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span>&nbsp;regexpToRegexp(path,&nbsp;<span class="hljs-comment">/**&nbsp;@type&nbsp;&#123;!Array&#125;&nbsp;*/</span>&nbsp;(keys)) 
&nbsp;&nbsp;&#125; 
&nbsp;&nbsp;<span class="hljs-keyword">if</span>&nbsp;(isarray(path))&nbsp;&#123; 
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span>&nbsp;arrayToRegexp(<span class="hljs-comment">/**&nbsp;@type&nbsp;&#123;!Array&#125;&nbsp;*/</span>&nbsp;(path),&nbsp;<span class="hljs-comment">/**&nbsp;@type&nbsp;&#123;!Array&#125;&nbsp;*/</span>&nbsp;(keys),&nbsp;options) 
&nbsp;&nbsp;&#125; 
&nbsp;&nbsp;<span class="hljs-keyword">return</span>&nbsp;stringToRegexp(<span class="hljs-comment">/**&nbsp;@type&nbsp;&#123;string&#125;&nbsp;*/</span>&nbsp;(path),&nbsp;<span class="hljs-comment">/**&nbsp;@type&nbsp;&#123;!Array&#125;&nbsp;*/</span>&nbsp;(keys),&nbsp;options) 
</code></pre>
<p data-nodeid="44720">arrayToRegexp() 函数会遍历 path 数组然后递归调用函数 pathToRegexp()，将所得的结果拼接成一个新的正则表达式并赋值 keys 属性。</p>
<pre class="lang-javascript" data-nodeid="44721"><code data-language="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span>&nbsp;<span class="hljs-title">arrayToRegexp</span>&nbsp;(<span class="hljs-params">path,&nbsp;keys,&nbsp;options</span>)&nbsp;</span>&#123; 
&nbsp;&nbsp;<span class="hljs-keyword">var</span>&nbsp;parts&nbsp;=&nbsp;[] 
&nbsp;&nbsp;<span class="hljs-keyword">for</span>&nbsp;(<span class="hljs-keyword">var</span>&nbsp;i&nbsp;=&nbsp;<span class="hljs-number">0</span>;&nbsp;i&nbsp;&lt;&nbsp;path.length;&nbsp;i++)&nbsp;&#123; 
&nbsp;&nbsp;&nbsp;&nbsp;parts.push(pathToRegexp(path[i],&nbsp;keys,&nbsp;options).source) 
&nbsp;&nbsp;&#125; 
&nbsp;&nbsp;<span class="hljs-keyword">var</span>&nbsp;regexp&nbsp;=&nbsp;<span class="hljs-keyword">new</span>&nbsp;<span class="hljs-built_in">RegExp</span>(<span class="hljs-string">'(?:'</span>&nbsp;+&nbsp;parts.join(<span class="hljs-string">'|'</span>)&nbsp;+&nbsp;<span class="hljs-string">')'</span>,&nbsp;flags(options)) 
&nbsp;&nbsp;<span class="hljs-keyword">return</span>&nbsp;attachKeys(regexp,&nbsp;keys) 
&#125; 
</code></pre>
<p data-nodeid="44722">regexpToRegexp() 函数会找寻正则表达式中的负向后行断言，记录到正则表达式实例的 keys 属性中。</p>
<pre class="lang-java" data-nodeid="50560"><code data-language="java"><span class="hljs-function">function&nbsp;<span class="hljs-title">regexpToRegexp</span>&nbsp;<span class="hljs-params">(path,&nbsp;keys)</span>&nbsp;</span>&#123; 
&nbsp;&nbsp;<span class="hljs-keyword">var</span>&nbsp;groups&nbsp;=&nbsp;path.source.match(/\((?!\?)/g) 
&nbsp;&nbsp;<span class="hljs-keyword">if</span>&nbsp;(groups)&nbsp;&#123; 
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">for</span>&nbsp;(<span class="hljs-keyword">var</span>&nbsp;i&nbsp;=&nbsp;<span class="hljs-number">0</span>;&nbsp;i&nbsp;&lt;&nbsp;groups.length;&nbsp;i++)&nbsp;&#123; 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;keys.push(&#123; 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name:&nbsp;i, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;prefix:&nbsp;<span class="hljs-keyword">null</span>, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;delimiter:&nbsp;<span class="hljs-keyword">null</span>, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;optional:&nbsp;<span class="hljs-keyword">false</span>, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;repeat:&nbsp;<span class="hljs-keyword">false</span>, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;partial:&nbsp;<span class="hljs-keyword">false</span>, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;asterisk:&nbsp;<span class="hljs-keyword">false</span>, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pattern:&nbsp;<span class="hljs-keyword">null</span> 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#125;) 
&nbsp;&nbsp;&nbsp;&nbsp;&#125; 
&nbsp;&nbsp;&#125; 
&nbsp;&nbsp;<span class="hljs-keyword">return</span>&nbsp;attachKeys(path,&nbsp;keys) 
&#125; 
</code></pre>




<p data-nodeid="44724">一般情况下会调用 stringToRegexp() 函数来将字符串转换成正则表达式。函数 stringToRegexp() 只是调用了两个函数 tokensTo Regexp () 和 parse()。</p>
<pre class="lang-javascript" data-nodeid="44725"><code data-language="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span>&nbsp;<span class="hljs-title">stringToRegexp</span>&nbsp;(<span class="hljs-params">path,&nbsp;keys,&nbsp;options</span>)&nbsp;</span>&#123; 
&nbsp;&nbsp;<span class="hljs-keyword">return</span>&nbsp;tokensToRegExp(parse(path,&nbsp;options),&nbsp;keys,&nbsp;options) 
&#125; 
</code></pre>
<p data-nodeid="44726">看到 parse() 这个函数不知道是否会让你想起前面几讲中提到的编译器，该函数的主要作用和编译器中的词法分析比较像，它会将字符串转化为令牌数组。这些令牌分为两类，一类是<strong data-nodeid="44838">非特殊字符串</strong>，不需要做任何处理，直接以字符串形式放入数组；另一类是<strong data-nodeid="44839">特殊字符串</strong>，需要依赖一个正则表达式来进行处理。这个核心的正则表达式如下所示：</p>
<pre class="lang-javascript" data-nodeid="44727"><code data-language="javascript"><span class="hljs-keyword">var</span> PATH_REGEXP = <span class="hljs-regexp">/(\\.)|([\/.])?(?:(?:\:(\w+)(?:\(((?:\\.|[^\\()])+)\))?|\(((?:\\.|[^\\()])+)\))([+*?])?|(\*))/g</span> 
</code></pre>
<p data-nodeid="44728">可以看到这个正则表达式中有多个通过圆括号形成的分组，通过调用 exec() 函数分别提取不同的信息，放入一个长度为 8 的数组中，对于不匹配的字符串则会返回 null。</p>
<pre class="lang-javascript" data-nodeid="44729"><code data-language="javascript">PATH_REGEXP.exec(<span class="hljs-string">"/:test(\\d+)?"</span>) <span class="hljs-comment">// ["/:test(\d+)?", undefined, "/", "test", "\d+", undefined, "?", undefined] </span>
PATH_REGEXP.exec(<span class="hljs-string">"/route(\\d+)"</span>) <span class="hljs-comment">// ["(\d+)", undefined, undefined, undefined, undefined, "\d+", undefined, undefined] </span>
PATH_REGEXP.exec(<span class="hljs-string">"/*"</span>) <span class="hljs-comment">// ["/*", undefined, "/", undefined, undefined, undefined, undefined, "*"] </span>
</code></pre>
<p data-nodeid="44730">词法分析过程和前面提到的一致，即利用 while 循环以及正则匹配，将匹配到的 子串 转换成令牌对象。例如，字符串 /user/:id，会被转换成包含一个非特殊字符串和特殊字符串的令牌数组：</p>
<pre class="lang-javascript" data-nodeid="44731"><code data-language="javascript">[<span class="hljs-string">"/user"</span>, 
&nbsp; &#123; 
&nbsp; &nbsp; <span class="hljs-attr">asterisk</span>: <span class="hljs-literal">false</span> 
&nbsp; &nbsp; <span class="hljs-attr">delimiter</span>: <span class="hljs-string">"/"</span> 
&nbsp; &nbsp; <span class="hljs-attr">name</span>: <span class="hljs-string">"id"</span> 
&nbsp; &nbsp; <span class="hljs-attr">optional</span>: <span class="hljs-literal">false</span> 
&nbsp; &nbsp; <span class="hljs-attr">partial</span>: <span class="hljs-literal">false</span> 
&nbsp; &nbsp; <span class="hljs-attr">pattern</span>: <span class="hljs-string">"[^\/]+?"</span> 
&nbsp; &nbsp; <span class="hljs-attr">prefix</span>: <span class="hljs-string">"/"</span> 
&nbsp; &nbsp; <span class="hljs-attr">repeat</span>: <span class="hljs-literal">false</span> 
&nbsp; &#125; 
] 
</code></pre>
<p data-nodeid="44732">在得到令牌数组之后，下一步是调用函数 tokensToRegExp() 将它转换成正则表达式。对于字符串令牌，直接转化成转义后的字符串，这个转义的过程也很简单，即在“/”“[”这类具有正则表达式功能的特殊字符前加上“\”。</p>
<pre class="lang-javascript" data-nodeid="44733"><code data-language="javascript">... 
if (<span class="hljs-keyword">typeof</span> token === <span class="hljs-string">'string'</span>) &#123; 
&nbsp; route += escapeString(token) 
&#125; 
... 
function escapeString (str) &#123; 
&nbsp; <span class="hljs-keyword">return</span> str.replace(<span class="hljs-regexp">/([.+*?=^!:$&#123;&#125;()[\]|\/\\])/g</span>, <span class="hljs-string">'\\$1'</span>) 
&#125; 
</code></pre>
<p data-nodeid="44734">对于正则表达式令牌，首先放到前面提到的 keys 数组中，然后再对正则表达式令牌的内容进行标准化处理，拼接到最终的正则表达式字符串 route 中，再将 route 实例化为正则表达式对象，并附上 keys 属性。</p>
<pre class="lang-javascript" data-nodeid="44735"><code data-language="javascript">... 
var prefix = escapeString(token.prefix) 
<span class="hljs-keyword">var</span> capture = <span class="hljs-string">'(?:'</span> + token.pattern + <span class="hljs-string">')'</span> 
keys.push(token) 
<span class="hljs-keyword">if</span> (token.repeat) &#123; 
&nbsp; capture += <span class="hljs-string">'(?:'</span> + prefix + capture + <span class="hljs-string">')*'</span> 
&#125; 
<span class="hljs-keyword">if</span> (token.optional) &#123; 
&nbsp; <span class="hljs-keyword">if</span> (!token.partial) &#123; 
&nbsp; &nbsp; capture = <span class="hljs-string">'(?:'</span> + prefix + <span class="hljs-string">'('</span> + capture + <span class="hljs-string">'))?'</span> 
&nbsp; &#125; <span class="hljs-keyword">else</span> &#123; 
&nbsp; &nbsp; capture = prefix + <span class="hljs-string">'('</span> + capture + <span class="hljs-string">')?'</span> 
&nbsp; &#125; 
&#125; <span class="hljs-keyword">else</span> &#123; 
&nbsp; capture = prefix + <span class="hljs-string">'('</span> + capture + <span class="hljs-string">')'</span> 
&#125; 
route += capture 
... 
return attachKeys(<span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">'^'</span> + route, flags(options)), keys) 
</code></pre>
<h4 data-nodeid="44736">路由生成</h4>
<p data-nodeid="44737">路由生成是指通过配置的请求路径字符串和参数生成对应的请求路径，比如配置的请求路径字符串 /user/:id 和参数 {id: "lagou"} 可以生成 /user/lagou，在 path-to-regexp 源码中对应的是函数 compile()。</p>
<p data-nodeid="44738">compile() 函数接收两个参数：str 和 options。str 为字符串，可能包含特殊字符串；options 同 pathToRegexp() 函数的 options 参数。</p>
<p data-nodeid="44739">从参数可以看出，compile() 函数并不直接生成结果字符串，而是返回一个生成函数，将参数传入这个函数中可以生成<strong data-nodeid="44860">结果字符串</strong>。</p>
<p data-nodeid="44740">compile() 函数的内部只调用了两个函数 parse() 和 tokensToFunction()，parse() 函数前面已经分析过了，下面来分析函数 tokensToFunction()。</p>
<pre class="lang-javascript" data-nodeid="44741"><code data-language="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span>&nbsp;<span class="hljs-title">compile</span>&nbsp;(<span class="hljs-params">str,&nbsp;options</span>)&nbsp;</span>&#123; 
&nbsp;&nbsp;<span class="hljs-keyword">return</span>&nbsp;tokensToFunction(parse(str,&nbsp;options),&nbsp;options) 
&#125; 
</code></pre>
<p data-nodeid="44742">函数 tokensToFunction()  的核心代码在于返回的匿名函数，匿名函数内部会遍历令牌数组，对于字符串令牌，直接拼接到生成的路径中；而对于正则表达式令牌，则会通过令牌 token.name 属性来找到参数对象 obj 对应的值。如果这个值为字符串，则判断是否匹配 token 中的正则表达式，匹配之后进行 URI 编码并拼接到结果字符串 path 中；如果为数组，则循环执行字符串匹配过程。返回的匿名函数部分代码如下：</p>
<pre class="lang-java" data-nodeid="51972"><code data-language="java"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; tokens.length; i++) &#123; 
&nbsp; <span class="hljs-keyword">var</span> token = tokens[i] 
&nbsp; <span class="hljs-keyword">if</span> (typeof token === <span class="hljs-string">'string'</span>) &#123; 
&nbsp; &nbsp; path += token 
&nbsp; &nbsp; <span class="hljs-keyword">continue</span> 
&nbsp; &#125; 
&nbsp; <span class="hljs-keyword">var</span> value = data[token.name] 
&nbsp; <span class="hljs-function"><span class="hljs-keyword">var</span> segment 
&nbsp; <span class="hljs-title">if</span> <span class="hljs-params">(isarray(value)</span>) </span>&#123; 
&nbsp; &nbsp; <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; value.length; j++) &#123; 
&nbsp; &nbsp; &nbsp; segment = encode(value[j]) 
&nbsp; &nbsp; &nbsp; path += (j === <span class="hljs-number">0</span> ? token.prefix : token.delimiter) + segment 
&nbsp; &nbsp; &#125; 
&nbsp; &nbsp; <span class="hljs-keyword">continue</span> 
&nbsp; &#125; 
&nbsp; segment = token.asterisk ? encodeAsterisk(value) : encode(value) 
&nbsp; path += token.prefix + segment 
&#125; 
<span class="hljs-keyword">return</span> path 
</code></pre>




<h3 data-nodeid="44744">总结</h3>
<p data-nodeid="44745">这一课时我们先介绍了前端路由的实现基础，包括基于 hash 实现和 history 实现。基于 hash 方式兼容性较好，但是占用了浏览器默认的定位行为，同时会加长 URL 字符串；基于 history 方式可以直接修改 URL 路径，较为美观。</p>
<p data-nodeid="44746" class="">然后分析了 vue-router 和 react-router 共同的依赖库 path-to-regexp 中的两个核心函数 pathToRegexp() 和 compile()。pathToRegexp() 会先将配置的请求路径字符串拆分成令牌数组，然后再转化成正则表达式对象，路由库可以通过正则表达式来进行路由匹配，从而将对应的组件渲染到页面；complie() 函数会将配置的请求路径字符串转化成一个匿名函数，这个函数可以传入参数并生成一个请求路径字符串。</p>
<p data-nodeid="52325">最后留一道思考题：你在使用前端路由的时候碰到过哪些问题，又是怎么解决的呢？欢迎在留言区写下你的答案和大家一起交流学习。</p>

<hr>
<h3 id="精选评论"><a href="#精选评论" class="headerlink" title="精选评论"></a>精选评论</h3><h5 id="飞："><a href="#飞：" class="headerlink" title="**飞："></a>**飞：</h5><blockquote>
<p>路由放前端到底意味着什么？</p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-讲师回复："><a href="#amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; 意味着web应用的解耦，前后端真正分离，只通过API进行交互~</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/11/02/%E6%8A%8A%E8%B7%AF%E7%94%B1%E6%94%BE%E5%9C%A8%E5%89%8D%E7%AB%AF%E6%84%8F%E5%91%B3%E7%9D%80%E4%BB%80%E4%B9%88%EF%BC%9F/" data-id="claxeera5001bv8w10npz5w2z" data-title="把路由放在前端意味着什么？" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-你是怎么理解组件这个概念的？" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/11/02/%E4%BD%A0%E6%98%AF%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3%E7%BB%84%E4%BB%B6%E8%BF%99%E4%B8%AA%E6%A6%82%E5%BF%B5%E7%9A%84%EF%BC%9F/" class="article-date">
  <time class="dt-published" datetime="2022-11-02T02:54:24.000Z" itemprop="datePublished">2022-11-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/11/02/%E4%BD%A0%E6%98%AF%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3%E7%BB%84%E4%BB%B6%E8%BF%99%E4%B8%AA%E6%A6%82%E5%BF%B5%E7%9A%84%EF%BC%9F/">你是怎么理解组件这个概念的？</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p data-nodeid="925" class="">不同框架、工具对组件的定义和实现各不相同，但可以用一句话来概括它们对组件的定义： <strong data-nodeid="1030">组件就是基于视图的模块</strong> 。</p>
<p data-nodeid="926">组件的核心任务就是将数据渲染到视图并监听用户在视图上的操作。这一课时，我们以主流的 Vue 2.6 和 React 16.13 的源码为例，讲解较为复杂的数据渲染到视图的实现过程。</p>
<h3 data-nodeid="927">视图</h3>
<p data-nodeid="928">虽然 Vue 和 React 在编写组件视图的方式上有所不同，前者采用模板语言，更偏向于 HTML 语法，后者推荐使用语法糖 JSX，更偏向于 JavaScript 语法，但两者都是浏览器所无法直接识别的，所以都需要通过编译器转换成对应的可执行代码。下面来看看它们的实现。</p>
<h4 data-nodeid="929">Vue</h4>
<p data-nodeid="930">Vue 的模板编译器可分为 3 步：解析、优化、生成代码。</p>
<p data-nodeid="931"><strong data-nodeid="1041">1. 解析</strong></p>
<p data-nodeid="932">解析过程包括 <strong data-nodeid="1051">词法分析</strong> 和 <strong data-nodeid="1052">语法分析</strong> ，其中词法分析是将字符串转化成令牌。Vue 有 3 个词法分析器，分别是 parseText()、parseFilter() 和 parseHTML()，其中 parseHTML() 用来解析视图模板字符串，词法分析的方式也是通过 while 循环截取视图模板字符串来实现的，下面的代码是截取的部分源码。</p>
<pre class="lang-typescript" data-nodeid="933"><code data-language="typescript"><span class="hljs-keyword">while</span> (html) &#123; 
&nbsp; <span class="hljs-keyword">if</span> (!lastTag || !isPlainTextElement(lastTag)) &#123; 
&nbsp; &nbsp; <span class="hljs-keyword">let</span> textEnd = html.indexOf(<span class="hljs-string">'&lt;'</span>) 
&nbsp; &nbsp; <span class="hljs-keyword">if</span> (textEnd === <span class="hljs-number">0</span>) &#123; 
&nbsp; &nbsp; &nbsp; <span class="hljs-keyword">if</span> (comment.test(html)) &#123; 
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">const</span> commentEnd = html.indexOf(<span class="hljs-string">'--&gt;'</span>) 
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">if</span> (commentEnd &gt;= <span class="hljs-number">0</span>) &#123; 
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">if</span> (options.shouldKeepComment) &#123; 
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; options.comment(html.substring(<span class="hljs-number">4</span>, commentEnd), index, index + commentEnd + <span class="hljs-number">3</span>) 
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &#125; 
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; advance(commentEnd + <span class="hljs-number">3</span>) 
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">continue</span> 
&nbsp; &nbsp; &nbsp; &nbsp; &#125; 
&nbsp; &nbsp; &nbsp; &#125; 
&nbsp; &nbsp; &nbsp; <span class="hljs-keyword">if</span> (conditionalComment.test(html)) &#123; 
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">if</span> (conditionalEnd &gt;= <span class="hljs-number">0</span>) &#123; 
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; advance(conditionalEnd + <span class="hljs-number">2</span>) 
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">continue</span> 
&nbsp; &nbsp; &nbsp; &nbsp; &#125; 
&nbsp; &nbsp; &nbsp; &#125; 
&nbsp; &nbsp; &#125; 
&nbsp; &#125; 
&#125; 
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">advance</span> (<span class="hljs-params">n</span>) </span>&#123; 
&nbsp; index += n 
&nbsp; html = html.substring(n) 
&#125;
</code></pre>
<p data-nodeid="934">编译器在调用 parseHTML() 函数时，还传入了一个回调函数 start()，让 parseHTML() 在进行词法分析时的同时通过调用 start() 函数将令牌传给编译器进行语法分析，最终生成 AST，如下所示。</p>
<pre class="lang-typescript" data-nodeid="935"><code data-language="typescript">parseHTML(template, &#123; 
&nbsp; start (tag, attrs, unary, start, end) &#123; 
&nbsp; &nbsp; <span class="hljs-keyword">const</span> ns = (currentParent &amp;&amp; currentParent.ns) || platformGetTagNamespace(tag) 
&nbsp; &nbsp; <span class="hljs-keyword">if</span> (isIE &amp;&amp; ns === <span class="hljs-string">'svg'</span>) &#123; 
&nbsp; &nbsp; &nbsp; attrs = guardIESVGBug(attrs) 
&nbsp; &nbsp; &#125; 
&nbsp; &nbsp; <span class="hljs-keyword">let</span> element: ASTElement = createASTElement(tag, attrs, currentParent) 
&nbsp; &nbsp; <span class="hljs-keyword">if</span> (ns) &#123; 
&nbsp; &nbsp; &nbsp; element.ns = ns 
&nbsp; &nbsp; &#125; 
&nbsp; &nbsp; <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; preTransforms.length; i++) &#123; 
&nbsp; &nbsp; &nbsp; element = preTransforms[i](element, options) || element 
&nbsp; &nbsp; &#125; 
&nbsp; &nbsp; <span class="hljs-keyword">if</span> (!inVPre) &#123; 
&nbsp; &nbsp; &nbsp; processPre(element) 
&nbsp; &nbsp; &nbsp; <span class="hljs-keyword">if</span> (element.pre) &#123; 
&nbsp; &nbsp; &nbsp; &nbsp; inVPre = <span class="hljs-literal">true</span> 
&nbsp; &nbsp; &nbsp; &#125; 
&nbsp; &nbsp; &#125; 
&nbsp; &nbsp; <span class="hljs-keyword">if</span> (platformIsPreTag(element.tag)) &#123; 
&nbsp; &nbsp; &nbsp; inPre = <span class="hljs-literal">true</span> 
&nbsp; &nbsp; &#125; 
&nbsp; &nbsp; <span class="hljs-keyword">if</span> (inVPre) &#123; 
&nbsp; &nbsp; &nbsp; processRawAttrs(element) 
&nbsp; &nbsp; &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!element.processed) &#123; 
&nbsp; &nbsp; &nbsp; processFor(element) 
&nbsp; &nbsp; &nbsp; processIf(element) 
&nbsp; &nbsp; &nbsp; processOnce(element) 
&nbsp; &nbsp; &#125; 
&nbsp; &nbsp; <span class="hljs-keyword">if</span> (!unary) &#123; 
&nbsp; &nbsp; &nbsp; currentParent = element 
&nbsp; &nbsp; &nbsp; stack.push(element) 
&nbsp; &nbsp; &#125; <span class="hljs-keyword">else</span> &#123; 
&nbsp; &nbsp; &nbsp; closeElement(element) 
&nbsp; &nbsp; &#125; 
&nbsp; &#125; 
&#125;)
</code></pre>
<p data-nodeid="936"><img src="https://s0.lgstatic.com/i/image/M00/39/02/Ciqc1F8espmAbE4lAAAX5545fVc183.png" alt="Drawing 0.png" data-nodeid="1056"></p>
<div data-nodeid="937"><p style="text-align:center">生成的 AST 结构示例图</p></div>
<p data-nodeid="938"><strong data-nodeid="1062">2. 优化</strong></p>
<p data-nodeid="939">Vue 并没有直接使用生成的 AST，而是进行一个优化操作。优化操作的目的就是将那些不会发生变化的静态 AST 节点进行标记，避免每次更新视图的时候操作它们。</p>
<pre class="lang-typescript" data-nodeid="940"><code data-language="typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">markStaticRoots</span> (<span class="hljs-params">node: ASTNode, isInFor: <span class="hljs-built_in">boolean</span></span>) </span>&#123; 
&nbsp; <span class="hljs-keyword">if</span> (node.type === <span class="hljs-number">1</span>) &#123; 
&nbsp; &nbsp; <span class="hljs-keyword">if</span> (node.static || node.once) &#123; 
&nbsp; &nbsp; &nbsp; node.staticInFor = isInFor 
&nbsp; &nbsp; &#125; 
&nbsp; &nbsp; <span class="hljs-keyword">if</span> (node.static &amp;&amp; node.children.length &amp;&amp; !( 
&nbsp; &nbsp; &nbsp; node.children.length === <span class="hljs-number">1</span> &amp;&amp; 
&nbsp; &nbsp; &nbsp; node.children[<span class="hljs-number">0</span>].type === <span class="hljs-number">3</span> 
&nbsp; &nbsp; )) &#123; 
&nbsp; &nbsp; &nbsp; node.staticRoot = <span class="hljs-literal">true</span> 
&nbsp; &nbsp; &nbsp; <span class="hljs-keyword">return</span> 
&nbsp; &nbsp; &#125; <span class="hljs-keyword">else</span> &#123; 
&nbsp; &nbsp; &nbsp; node.staticRoot = <span class="hljs-literal">false</span> 
&nbsp; &nbsp; &#125; 
&nbsp; &nbsp; <span class="hljs-keyword">if</span> (node.children) &#123; 
&nbsp; &nbsp; &nbsp; <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, l = node.children.length; i &lt; l; i++) &#123; 
&nbsp; &nbsp; &nbsp; &nbsp; markStaticRoots(node.children[i], isInFor || !!node.for) 
&nbsp; &nbsp; &nbsp; &#125; 
&nbsp; &nbsp; &#125; 
&nbsp; &nbsp; <span class="hljs-keyword">if</span> (node.ifConditions) &#123; 
&nbsp; &nbsp; &nbsp; <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>, l = node.ifConditions.length; i &lt; l; i++) &#123; 
&nbsp; &nbsp; &nbsp; &nbsp; markStaticRoots(node.ifConditions[i].block, isInFor) 
&nbsp; &nbsp; &nbsp; &#125; 
&nbsp; &nbsp; &#125; 
&nbsp; &#125; 
&#125;
</code></pre>
<p data-nodeid="941"><strong data-nodeid="1069">3. 生成代码</strong></p>
<p data-nodeid="942">编译的最后一步就是将优化后的 AST 转化成可执行的代码。这个转化的过程就是遍历 AST，然后判断节点类型，按照元素、指令解析成对应可执行的 JS 代码。</p>
<p data-nodeid="943">Vue 中的编译根据不同平台有所区别，下面是浏览器端的编译部分代码。</p>
<pre class="lang-javascript" data-nodeid="944"><code data-language="javascript"><span class="hljs-comment">// 视图模板 </span>
&lt;div&nbsp;id=<span class="hljs-string">"app"</span>&gt; 
&nbsp;&nbsp;<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello&nbsp;&#123;&#123;text&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span> 
&nbsp;&nbsp;<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&nbsp;<span class="hljs-attr">v-bind:id</span>=<span class="hljs-string">"message"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span> 
&lt;/div&gt; 
<span class="hljs-comment">// 可执行的 js 代码 </span>
<span class="hljs-string">"with(this)&#123;return _c('div',&#123;attrs:&#123;"</span>id<span class="hljs-string">":"</span>app<span class="hljs-string">"&#125;&#125;,[_c('h1',[_v("</span>Hello <span class="hljs-string">"+_s(text))]),_v("</span> <span class="hljs-string">"),_c('span',&#123;attrs:&#123;"</span>id<span class="hljs-string">":message&#125;&#125;)])&#125;"</span>
</code></pre>
<h4 data-nodeid="945">React</h4>
<p data-nodeid="946">React 组件视图则使用 JS 的语法糖 jsx 来编写（不用 jsx 也可以编写组件），这种语法糖其实就是混合了 HTML 和 JS 两种语言，浏览器也是无法直接识别的，所以用到了 babel 及其插件 babel-plugin-transform-react-jsx 对 jsx 进行预编译，编译步骤和之前提到的基本一致，这里就不再赘述了。</p>
<h3 data-nodeid="947">延伸 1：虚拟 DOM 是用来提升性能的吗？</h3>
<p data-nodeid="948">虽然 Vue 和 React 有着种种差异，但在某些地方达成了共识，比如都使用了虚拟 DOM 技术。对于使用过 React 或 Vue 的同学对虚拟 DOM 应该不陌生，其实就是 JavaScript 用来模拟真实 DOM 的数据对象。</p>
<p data-nodeid="949">DOM 的作用有以下两个。</p>
<ul data-nodeid="950">
<li data-nodeid="951">
<p data-nodeid="952"><strong data-nodeid="1085">优化性能</strong> 。DOM 操作是比较耗时的，对于大量、频繁的 DOM 操作，如果先在 JavaScript 中模拟进行，然后再通过计算比对，找到真正需要更新的节点，这样就有可能减少不必要的 DOM 操作，从而提升渲染性能。但并不是所有的 DOM 操作都能通过虚拟 DOM 提升性能，比如单次删除某个节点，直接操作 DOM 肯定比虚拟 DOM 计算比对之后再删除要快。总体而言， <strong data-nodeid="1086">虚拟 DOM 提升了 DOM 操作的性能下限，降低了 DOM 操作的性能上限。</strong> 所以会看到一些对渲染性能要求比较高的场景，比如在线文档、表格编辑，还是会使用原生 DOM 操作。</p>
</li>
<li data-nodeid="953">
<p data-nodeid="954"><strong data-nodeid="1091">跨平台</strong> 。由于虚拟 DOM 以 JavaScript 对象为基础，所以可根据不同的运行环境进行代码转换（比如浏览器、服务端、原生应用等），这使得它具有了跨平台的能力。</p>
</li>
</ul>
<h3 data-nodeid="955">数据模型</h3>
<p data-nodeid="956">虽然组件屏蔽了 DOM 操作，但提供了数据模型作为操作接口。下面来看看 Vue 和 React 组件的另一个要素“数据模型”。</p>
<h4 data-nodeid="957">Vue</h4>
<p data-nodeid="958">Vue 组件内部提供了一个值为函数的 data 属性，调用这个函数时会返回一个对象。下面的代码分别在组件声明时将 data 属性定义为函数和对象，当定义为对象时会报错。</p>
<pre class="lang-javascript" data-nodeid="959"><code data-language="javascript"><span class="hljs-comment">// 正确 </span>
Vue.component(<span class="hljs-string">'item'</span>, &#123; 
&nbsp; <span class="hljs-attr">template</span>: <span class="hljs-string">'&lt;p&gt;item:&#123;&#123;name&#125;&#125;&lt;/p&gt;'</span>, 
  <span class="hljs-comment">// data 必须是函数 </span>
&nbsp; data() &#123; 
  &nbsp; <span class="hljs-keyword">return</span>&nbsp;&#123; <span class="hljs-attr">name</span>: <span class="hljs-built_in">Math</span>.random() &#125; 
&nbsp; &#125; 
&#125;) 
<span class="hljs-comment">// 报错：The "data" option should be a function that returns a per-instance value in component definitions. </span>
Vue.component(<span class="hljs-string">'item'</span>, &#123; 
&nbsp; <span class="hljs-attr">template</span>: <span class="hljs-string">'&lt;p&gt;item:&#123;&#123;name&#125;&#125;&lt;/p&gt;'</span>, 
&nbsp; <span class="hljs-attr">data</span>: &#123; 
&nbsp; &nbsp; <span class="hljs-attr">name</span>: <span class="hljs-built_in">Math</span>.random() 
&nbsp; &#125; 
&#125;)
</code></pre>
<p data-nodeid="960">但我们在修改数据模型的时候，data 指代的却是一个对象。那为什么在声明的时候还要通过函数来返回对象呢？</p>
<p data-nodeid="961">按照官方的说法，是为了保证“每个实例可以维护一份对返回对象的独立复制”，具体实现就是调用 data() 函数，并将其 this 指向当前组件实例 vm，同时将当前实例作为参数传递给 data() 函数，然后将返回的数据对象存储到组件实例 vm._data 属性中。下面代码是截取的部分源码。</p>
<pre class="lang-plain" data-nodeid="962"><code data-language="plain">function initData (vm: Component) &#123; 
&nbsp; let data = vm.$options.data 
&nbsp; data = vm._data = typeof data === 'function' 
&nbsp; &nbsp; ? getData(data, vm) 
&nbsp; &nbsp; : data || &#123;&#125; 
&nbsp; if (!isPlainObject(data)) &#123; 
&nbsp; &nbsp; data = &#123;&#125; 
&nbsp; &nbsp; process.env.NODE_ENV !== 'production' &amp;&amp; warn( 
&nbsp; &nbsp; &nbsp; 'data functions should return an object:\n' + 
&nbsp; &nbsp; &nbsp; 'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function', 
&nbsp; &nbsp; &nbsp; vm 
&nbsp; &nbsp; ) 
&nbsp; &#125; 
&#125;
</code></pre>
<p data-nodeid="963">需要注意的是，有一种例外情况，那就是 Vue 实例中的 data 属性是一个对象，因为 Vue 实例是全局唯一的，所以不需要通过调用函数的方式来创建数据对象副本。</p>
<h4 data-nodeid="964">React</h4>
<p data-nodeid="965">虽然通过调用函数的方式确实可以保证每个组件实例拥有自己的数据，但如果 data 改成对象就一定不可以吗？</p>
<p data-nodeid="966">答案当然是否定的。在 <a target="_blank" rel="noopener" href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=180#/detail/pc?id=3178" data-nodeid="1106">第 07 课时“关于 JavaScript 的数据类型，你知多少</a>”中实现过一个深拷贝函数，理论上通过深拷贝函数来创建数据对象副本，也是完全可行的。</p>
<p data-nodeid="967">React 组件的数据模型 state，其值就是 <strong data-nodeid="1113">对象类型</strong> 。但 React 并没有直接采用深拷贝的方式来实现，因为深拷贝操作性能开销太大。下面的一段代码是创建对象和深拷贝对象的时间开销对比，耗时相差一倍，对于结构更加复杂的对象，这个差异可能会变得更大。</p>
<pre class="lang-java" data-nodeid="968"><code data-language="java"><span class="hljs-comment">// 创建对象 </span>
console.time(<span class="hljs-string">'create'</span>) 
<span class="hljs-keyword">var</span> obj = &#123;&#125; 
<span class="hljs-keyword">for</span>(let i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">100</span>;i++) &#123; 
&nbsp; obj[Math.random()] = Math.random() 
&#125; 
console.timeEnd(<span class="hljs-string">'create'</span>) <span class="hljs-comment">// create: 0.288818359375ms </span>
<span class="hljs-comment">// 深拷贝 </span>
console.time(<span class="hljs-string">'clone'</span>) 
_.cloneDeep(obj) 
console.timeEnd(<span class="hljs-string">'clone'</span>) <span class="hljs-comment">// clone: 0.637939453125ms</span>
</code></pre>
<p data-nodeid="969">React 组件是通过将 state 设置为不可变对象的方式来实现的，不可变对象指的就是当一个变量被创建后，它的值不可以被修改。这也就意味着当组件状态发生变化时，不修改 state 属性，而是重新创建新的 state 状态对象。</p>
<p data-nodeid="970">React 中的不可变对象通过 Structural Sharing（结构共享）的操作，大大减少了性能开销。这种操作的原理就是，如果对象中的一个属性发生变化，那么只深拷贝当前属性，然后将对象属性指向这个深拷贝的属性，其他节点仍然进行共享。</p>
<p data-nodeid="971">下面的示例代码，验证了 React 组件的状态对象 state 的不可变性。</p>
<pre class="lang-javascript" data-nodeid="972"><code data-language="javascript"><span class="hljs-keyword">let</span>&nbsp;o&nbsp;=&nbsp;&#123;<span class="hljs-attr">val</span>:&nbsp;<span class="hljs-number">0</span>&#125; 
<span class="hljs-keyword">let</span>&nbsp;b&nbsp;=&nbsp;&#123;<span class="hljs-attr">val</span>:&nbsp;<span class="hljs-number">0</span>&#125; 
<span class="hljs-class"><span class="hljs-keyword">class</span>&nbsp;<span class="hljs-title">Child</span>&nbsp;<span class="hljs-keyword">extends</span>&nbsp;<span class="hljs-title">React</span>.<span class="hljs-title">Component</span>&nbsp;</span>&#123; 
&nbsp;&nbsp;<span class="hljs-keyword">constructor</span>()&nbsp;&#123; 
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-built_in">super</span>() 
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-built_in">this</span>.state&nbsp;=&nbsp;&#123; 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;o, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b 
&nbsp;&nbsp;&nbsp;&nbsp;&#125; 
&nbsp;&nbsp;&#125; 
&nbsp;&nbsp;click(p)&nbsp;&#123; 
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-built_in">this</span>.setState(&#123; 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[p]:&nbsp;&#123; 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">val</span>:&nbsp;<span class="hljs-built_in">this</span>.state[p].val+<span class="hljs-number">1</span> 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#125; 
&nbsp;&nbsp;&nbsp;&nbsp;&#125;,&nbsp;<span class="hljs-function">()&nbsp;=&gt;</span>&nbsp;&#123; 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'o:'</span>,&nbsp;<span class="hljs-built_in">this</span>.state.o&nbsp;===&nbsp;o) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'b:'</span>,&nbsp;<span class="hljs-built_in">this</span>.state.b&nbsp;===&nbsp;b) 
&nbsp;&nbsp;&nbsp;&nbsp;&#125;) 
&nbsp;&nbsp;&#125; 
&nbsp;&nbsp;render()&nbsp;&#123; 
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span>&nbsp;( 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span> 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-tag">&lt;<span class="hljs-name">button</span>&nbsp;<span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.click.bind(this,</span>&nbsp;'<span class="hljs-attr">o</span>')&#125;&gt;</span>按钮o<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span> 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-tag">&lt;<span class="hljs-name">button</span>&nbsp;<span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.click.bind(this,</span>&nbsp;'<span class="hljs-attr">b</span>')&#125;&gt;</span>按钮b<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span> 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>o.val:&nbsp;&#123;this.state.o.val&#125;&nbsp;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span> 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>b.val:&nbsp;&#123;this.state.b.val&#125;&nbsp;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span> 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span> 
&nbsp;&nbsp;&nbsp;&nbsp;) 
&nbsp;&nbsp;&#125; 
&#125; 
<span class="hljs-class"><span class="hljs-keyword">class</span>&nbsp;<span class="hljs-title">App</span>&nbsp;<span class="hljs-keyword">extends</span>&nbsp;<span class="hljs-title">React</span>.<span class="hljs-title">Component</span>&nbsp;</span>&#123; 
&nbsp;&nbsp;render()&nbsp;&#123; 
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span>&nbsp;( 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span> 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-tag">&lt;<span class="hljs-name">Child</span>/&gt;</span> 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span> 
&nbsp;&nbsp;&nbsp;&nbsp;) 
&nbsp;&nbsp;&#125; 
&#125; 
<span class="hljs-built_in">window</span>.onload&nbsp;=&nbsp;<span class="hljs-function"><span class="hljs-keyword">function</span>&nbsp;(<span class="hljs-params"></span>)&nbsp;</span>&#123; 
&nbsp;&nbsp;ReactDOM.render(&nbsp;<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span>/&gt;</span></span>&nbsp;,&nbsp;<span class="hljs-built_in">window</span>.app) 
&#125;
</code></pre>
<p data-nodeid="973">创建两个值为对象的变量 o 和 b，在 Child 组件的构造函数中赋值给 state，Child 组件中有两个按钮，分别用来修改 state.o 属性和 state.b 属性。如果只点击“按钮o”，通过控制台输出结果可以观察到，state.o 进行了深拷贝之后发生了改变，所以不等于对象 o，而 state.b 没有改变，仍然等于对象 b。</p>
<h3 data-nodeid="974">渲染</h3>
<p data-nodeid="975">当数据发生变化时，如何修改视图呢？Vue 和 React 采取了两种不同的策略。</p>
<h4 data-nodeid="976">Vue</h4>
<p data-nodeid="977">Vue 采取的是响应式的视图更新方式，基于 Object.defineProperty() 函数，监听数据对象属性的变化，然后再更新到视图。下面深入分析它的实现细节。</p>
<p data-nodeid="978">Vue 在组件初始化的时候会将 data() 函数返回的数据对象传入 observe() 函数，在这个函数中会将数据对象作为参数来创建一个 Observer 实例，在这个实例的构造函数中将会通过 Object.defineProperty 为数据对象的每个属性设置监听。</p>
<pre class="lang-typescript" data-nodeid="979"><code data-language="typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> Observer &#123; 
&nbsp; value: <span class="hljs-built_in">any</span>; 
&nbsp; dep: Dep; 
&nbsp; vmCount: <span class="hljs-built_in">number</span>; 
&nbsp; <span class="hljs-keyword">constructor</span> (<span class="hljs-params">value: <span class="hljs-built_in">any</span></span>) &#123; 
&nbsp; &nbsp; <span class="hljs-built_in">this</span>.value = value 
&nbsp; &nbsp; <span class="hljs-built_in">this</span>.dep = <span class="hljs-keyword">new</span> Dep() 
&nbsp; &nbsp; <span class="hljs-built_in">this</span>.vmCount = <span class="hljs-number">0</span> 
&nbsp; &nbsp; def(value, <span class="hljs-string">'__ob__'</span>, <span class="hljs-built_in">this</span>) 
&nbsp; &nbsp; <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(value)) &#123; 
&nbsp; &nbsp; &nbsp; <span class="hljs-keyword">if</span> (hasProto) &#123; 
&nbsp; &nbsp; &nbsp; &nbsp; protoAugment(value, arrayMethods) 
&nbsp; &nbsp; &nbsp; &#125; <span class="hljs-keyword">else</span> &#123; 
&nbsp; &nbsp; &nbsp; &nbsp; copyAugment(value, arrayMethods, arrayKeys) 
&nbsp; &nbsp; &nbsp; &#125; 
&nbsp; &nbsp; &nbsp; <span class="hljs-built_in">this</span>.observeArray(value) 
&nbsp; &nbsp; &#125; <span class="hljs-keyword">else</span> &#123; 
&nbsp; &nbsp; &nbsp; <span class="hljs-built_in">this</span>.walk(value) 
&nbsp; &nbsp; &#125; 
&nbsp; &#125; 
&nbsp; walk (obj: <span class="hljs-built_in">Object</span>) &#123; 
&nbsp; &nbsp; <span class="hljs-keyword">const</span> keys = <span class="hljs-built_in">Object</span>.keys(obj) 
&nbsp; &nbsp; <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; keys.length; i++) &#123; 
&nbsp; &nbsp; &nbsp; defineReactive(obj, keys[i]) 
&nbsp; &nbsp; &#125; 
&nbsp; &#125; 
&nbsp; observeArray (items: <span class="hljs-built_in">Array</span>&lt;<span class="hljs-built_in">any</span>&gt;) &#123; 
&nbsp; &nbsp; <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, l = items.length; i &lt; l; i++) &#123; 
&nbsp; &nbsp; &nbsp; observe(items[i]) 
&nbsp; &nbsp; &#125; 
&nbsp; &#125; 
&#125;
</code></pre>
<p data-nodeid="980">当监听到数据变化时，该进行什么操作呢？这里我们查看 defineReactive() 的源码可以看到，除了为数据对象设置值之外，还会调用一个 dep.notify() 函数。</p>
<pre class="lang-typescript" data-nodeid="981"><code data-language="typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reactiveSetter</span>(<span class="hljs-params">newVal</span>) </span>&#123; 
&nbsp; <span class="hljs-keyword">const</span> value = getter ? getter.call(obj) : val 
&nbsp; <span class="hljs-keyword">if</span> (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123; 
&nbsp; &nbsp; <span class="hljs-keyword">return</span> 
&nbsp; &#125; 
&nbsp; <span class="hljs-keyword">if</span> (process.env.NODE_ENV !== <span class="hljs-string">'production'</span> &amp;&amp; customSetter) &#123; 
&nbsp; &nbsp; customSetter() 
&nbsp; &#125; 
&nbsp; <span class="hljs-keyword">if</span> (getter &amp;&amp; !setter) <span class="hljs-keyword">return</span> 
&nbsp; <span class="hljs-keyword">if</span> (setter) &#123; 
&nbsp; &nbsp; setter.call(obj, newVal) 
&nbsp; &#125; <span class="hljs-keyword">else</span> &#123; 
&nbsp; &nbsp; val = newVal 
&nbsp; &#125; 
&nbsp; childOb = !shallow &amp;&amp; observe(newVal) 
&nbsp; dep.notify() 
&#125;
</code></pre>
<p data-nodeid="982">这里的 dep 是在建立监听的时候创建的 Dep 实例，它相当于一个事件代理，内部有一个 subs 队列属性，用来存储依赖它的 Watcher 实例。当调用 dep.notify() 函数时，会遍历内部的 Watcher 队列，分别调用它们的 update() 函数。</p>
<pre class="lang-typescript" data-nodeid="983"><code data-language="typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> Dep &#123; 
&nbsp; <span class="hljs-keyword">static</span> target: ?Watcher; 
&nbsp; id: <span class="hljs-built_in">number</span>; 
&nbsp; subs: <span class="hljs-built_in">Array</span>&lt;Watcher&gt;; 
&nbsp; <span class="hljs-keyword">constructor</span> (<span class="hljs-params"></span>) &#123; 
&nbsp; &nbsp; <span class="hljs-built_in">this</span>.id = uid++ 
&nbsp; &nbsp; <span class="hljs-built_in">this</span>.subs = [] 
&nbsp; &#125; 
&nbsp; addSub (sub: Watcher) &#123; 
&nbsp; &nbsp; <span class="hljs-built_in">this</span>.subs.push(sub) 
&nbsp; &#125; 
&nbsp; removeSub (sub: Watcher) &#123; 
&nbsp; &nbsp; remove(<span class="hljs-built_in">this</span>.subs, sub) 
&nbsp; &#125; 
&nbsp; depend () &#123; 
&nbsp; &nbsp; <span class="hljs-keyword">if</span> (Dep.target) &#123; 
&nbsp; &nbsp; &nbsp; Dep.target.addDep(<span class="hljs-built_in">this</span>) 
&nbsp; &nbsp; &#125; 
&nbsp; &#125; 
&nbsp; notify () &#123; 
&nbsp; &nbsp; <span class="hljs-keyword">const</span> subs = <span class="hljs-built_in">this</span>.subs.slice() 
&nbsp; &nbsp; <span class="hljs-keyword">if</span> (process.env.NODE_ENV !== <span class="hljs-string">'production'</span> &amp;&amp; !config.async) &#123; 
&nbsp; &nbsp; &nbsp; subs.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a.id - b.id) 
&nbsp; &nbsp; &#125; 
&nbsp; &nbsp; <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, l = subs.length; i &lt; l; i++) &#123; 
&nbsp; &nbsp; &nbsp; subs[i].update() 
&nbsp; &nbsp; &#125; 
&nbsp; &#125; 
&#125;
</code></pre>
<p data-nodeid="1155" class="">Watcher 实例会在挂载组件的时候被创建，主要功能是一方面将自身添加到 Dep 实例的 subs 数组属性中；另一方面在收到更新通知后更新视图。值得注意的是，这个更新操作是延迟执行的，每次有新的数据变更要放入队列时都会进行判断，如果已存在则跳过，等所有变更都添加到队列后再进行统一更新操作。这么做的好处是如果同一个 watcher 被多次触发，只会被推入到队列中一次，从而避免了同一时刻重复操作 DOM 导致性能损耗。</p>
<p data-nodeid="985">具体实现是通过调用 queueWatcher() 函数，将当前 Watcher 实例放入到一个队列中进行缓冲。queueWatcher() 函数的源码如下所示。</p>
<pre class="lang-typescript" data-nodeid="986"><code data-language="typescript"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">queueWatcher</span> (<span class="hljs-params">watcher: Watcher</span>) </span>&#123; 
&nbsp; <span class="hljs-keyword">const</span> id = watcher.id 
&nbsp; <span class="hljs-keyword">if</span> (has[id] == <span class="hljs-literal">null</span>) &#123; 
&nbsp; &nbsp; has[id] = <span class="hljs-literal">true</span> 
&nbsp; &nbsp; <span class="hljs-keyword">if</span> (!flushing) &#123; 
&nbsp; &nbsp; &nbsp; queue.push(watcher) 
&nbsp; &nbsp; &#125; <span class="hljs-keyword">else</span> &#123; 
&nbsp; &nbsp; &nbsp; <span class="hljs-comment">// if already flushing, splice the watcher based on its id </span>
&nbsp; &nbsp; &nbsp; <span class="hljs-comment">// if already past its id, it will be run next immediately. </span>
&nbsp; &nbsp; &nbsp; <span class="hljs-keyword">let</span> i = queue.length - <span class="hljs-number">1</span> 
&nbsp; &nbsp; &nbsp; <span class="hljs-keyword">while</span> (i &gt; index &amp;&amp; queue[i].id &gt; watcher.id) &#123; 
&nbsp; &nbsp; &nbsp; &nbsp; i-- 
&nbsp; &nbsp; &nbsp; &#125; 
&nbsp; &nbsp; &nbsp; queue.splice(i + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, watcher) 
&nbsp; &nbsp; &#125; 
&nbsp; &nbsp; <span class="hljs-comment">// queue the flush </span>
&nbsp; &nbsp; <span class="hljs-keyword">if</span> (!waiting) &#123; 
&nbsp; &nbsp; &nbsp; waiting = <span class="hljs-literal">true</span> 


<p>&amp;nbsp; &amp;nbsp; &amp;nbsp; <span class="hljs-keyword">if</span> (process.env.NODE_ENV !&#x3D;&#x3D; <span class="hljs-string">‘production’</span> &amp;&amp; !config.async) &#123;<br>&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; flushSchedulerQueue()<br>&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; <span class="hljs-keyword">return</span><br>&amp;nbsp; &amp;nbsp; &amp;nbsp; &#125;<br>&amp;nbsp; &amp;nbsp; &amp;nbsp; nextTick(flushSchedulerQueue)<br>&amp;nbsp; &amp;nbsp; &#125;<br>&amp;nbsp; &#125;<br>&#125;<br></code></pre></p>
<p data-nodeid="987">在上面的代码中，flushSchedulerQueue 函数负责遍历队列并调用 watcher.run() 函数进行视图更新相关操作，实现异步队列的关键在于 nextTick() 函数，在调用该函数时，会将回调函数 flushSchedulerQueue() 放入一个 callbacks 数组中，然后执行一个 timerFunc() 函数，该函数会根据不同的运行环境选择可行的延迟执行方式，比如在现代浏览器中会优先使用 Promise.resolve().then，而在老版本的浏览器中会使用 setTimeout。</p>
<pre class="lang-typescript" data-nodeid="988"><code data-language="typescript"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Promise</span> !== <span class="hljs-string">'undefined'</span> &amp;&amp; isNative(<span class="hljs-built_in">Promise</span>)) &#123; 
&nbsp; <span class="hljs-keyword">const</span> p = <span class="hljs-built_in">Promise</span>.resolve() 
&nbsp; timerFunc = <span class="hljs-function">() =&gt;</span> &#123; 
&nbsp; &nbsp; p.then(flushCallbacks) 
&nbsp; &nbsp; <span class="hljs-keyword">if</span> (isIOS) <span class="hljs-built_in">setTimeout</span>(noop) 
&nbsp; &#125; 
&nbsp; isUsingMicroTask = <span class="hljs-literal">true</span> 
&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!isIE &amp;&amp; <span class="hljs-keyword">typeof</span> MutationObserver !== <span class="hljs-string">'undefined'</span> &amp;&amp; ( 
&nbsp; isNative(MutationObserver) || 
&nbsp; MutationObserver.toString() === <span class="hljs-string">'[object MutationObserverConstructor]'</span> 
)) &#123; 
&nbsp; <span class="hljs-keyword">let</span> counter = <span class="hljs-number">1</span> 
&nbsp; <span class="hljs-keyword">const</span> observer = <span class="hljs-keyword">new</span> MutationObserver(flushCallbacks) 
&nbsp; <span class="hljs-keyword">const</span> textNode = <span class="hljs-built_in">document</span>.createTextNode(<span class="hljs-built_in">String</span>(counter)) 
&nbsp; observer.observe(textNode, &#123; 
&nbsp; &nbsp; characterData: <span class="hljs-literal">true</span> 
&nbsp; &#125;) 
&nbsp; timerFunc = <span class="hljs-function">() =&gt;</span> &#123; 
&nbsp; &nbsp; counter = (counter + <span class="hljs-number">1</span>) % <span class="hljs-number">2</span> 
&nbsp; &nbsp; textNode.data = <span class="hljs-built_in">String</span>(counter) 
&nbsp; &#125; 
&nbsp; isUsingMicroTask = <span class="hljs-literal">true</span> 
&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> setImmediate !== <span class="hljs-string">'undefined'</span> &amp;&amp; isNative(setImmediate)) &#123; 
&nbsp; timerFunc = <span class="hljs-function">() =&gt;</span> &#123; 
&nbsp; &nbsp; setImmediate(flushCallbacks) 
&nbsp; &#125; 
&#125; <span class="hljs-keyword">else</span> &#123; 
&nbsp; timerFunc = <span class="hljs-function">() =&gt;</span> &#123; 
&nbsp; &nbsp; <span class="hljs-built_in">setTimeout</span>(flushCallbacks, <span class="hljs-number">0</span>) 
&nbsp; &#125; 
&#125;
</code></pre>
<p data-nodeid="989">虽然功能实现了，但 Object.defineProperty() 这个函数本身还存在一个缺陷，就是当属性值为对象类型的时候，无法监听对象内部的数据变化。像下面的代码，监听对象属性 obj 和数组属性 array 都会失败。</p>
<pre class="lang-javascript" data-nodeid="990"><code data-language="javascript">(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123; 
&nbsp; <span class="hljs-keyword">var</span> obj = &#123;<span class="hljs-attr">id</span>: <span class="hljs-number">1</span>&#125; 
&nbsp; <span class="hljs-keyword">var</span> array = [] 
&nbsp; <span class="hljs-built_in">Object</span>.defineProperty(o, <span class="hljs-string">'obj'</span>, &#123; 
&nbsp; &nbsp; <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>, 
&nbsp; &nbsp; <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>, 
&nbsp; &nbsp; <span class="hljs-attr">get</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123; 
&nbsp; &nbsp; &nbsp; <span class="hljs-keyword">return</span> obj 
&nbsp; &nbsp; &#125;, 
&nbsp; &nbsp; <span class="hljs-attr">set</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>) </span>&#123; 
&nbsp; &nbsp; &nbsp; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'set object'</span>) <span class="hljs-comment">// 不会执行 </span>
&nbsp; &nbsp; &nbsp; obj = val 
&nbsp; &nbsp; &#125; 
&nbsp; &#125;) 
&nbsp; <span class="hljs-built_in">Object</span>.defineProperty(o, <span class="hljs-string">'array'</span>, &#123; 
&nbsp; &nbsp; <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>, 
&nbsp; &nbsp; <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>, 
&nbsp; &nbsp; <span class="hljs-attr">get</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123; 
&nbsp; &nbsp; &nbsp; <span class="hljs-keyword">return</span> array 
&nbsp; &nbsp; &#125;, 
&nbsp; &nbsp; <span class="hljs-attr">set</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>) </span>&#123; 
&nbsp; &nbsp; &nbsp; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'set array'</span>) <span class="hljs-comment">// 不会执行 </span>
&nbsp; &nbsp; &nbsp; array = val 
&nbsp; &nbsp; &#125; 
&nbsp; &#125;) 
&#125;)() 
o.obj.id = <span class="hljs-number">2</span> 
<span class="hljs-built_in">console</span>.log(o.obj); <span class="hljs-comment">// &#123;id: 2&#125; </span>
o.array.push(<span class="hljs-number">1</span>) 
<span class="hljs-built_in">console</span>.log(o.array); <span class="hljs-comment">// [1]</span>
</code></pre>
<p data-nodeid="991">为了解决这个问题，Vue 分别采取了两个措施。对于对象属性，遍历对象属性逐层进行监听，下面是组件初始化断点调试的截图，从图中可看出，在组件初始化的时候分别对对象 data 的 o 属性和对象 o 的 name 属性进行了监听。</p>
<p data-nodeid="992"><img src="https://s0.lgstatic.com/i/image/M00/39/0D/CgqCHl8esvyAfqbBAABHCUKHL3U110.png" alt="Drawing 1.png" data-nodeid="1132"></p>
<p data-nodeid="993">同时监听了对象 data 的 o 属性和对象 data.o 的 name 属性</p>
<p data-nodeid="994">对于数组属性，修改了会引起数组变化的 7 个函数，包括：</p>
<ul data-nodeid="995">
<li data-nodeid="996">
<p data-nodeid="997">push()</p>
</li>
<li data-nodeid="998">
<p data-nodeid="999">pop()</p>
</li>
<li data-nodeid="1000">
<p data-nodeid="1001">shift()</p>
</li>
<li data-nodeid="1002">
<p data-nodeid="1003">unshift()</p>
</li>
<li data-nodeid="1004">
<p data-nodeid="1005">splice()</p>
</li>
<li data-nodeid="1006">
<p data-nodeid="1007">sort()</p>
</li>
<li data-nodeid="1008">
<p data-nodeid="1009">reverse()</p>
</li>
</ul>
<p data-nodeid="1010">具体实现包括两步，第一步是根据 Array.prototype 创建一个新的原型对象 arrayMethods，通过 Object.defineProperty() 函数对 arrayMethods 对象的上述 7 个函数进行劫持和修改，当调用这些方法时发送消息告知视图需要更新，下面是相关源码。</p>
<pre class="lang-typescript" data-nodeid="1011"><code data-language="typescript"><span class="hljs-keyword">const</span> arrayProto = <span class="hljs-built_in">Array</span>.prototype 
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> arrayMethods = <span class="hljs-built_in">Object</span>.create(arrayProto) 
<span class="hljs-keyword">const</span> methodsToPatch = [ 
&nbsp; <span class="hljs-string">'push'</span>, 
&nbsp; <span class="hljs-string">'pop'</span>, 
&nbsp; <span class="hljs-string">'shift'</span>, 
&nbsp; <span class="hljs-string">'unshift'</span>, 
&nbsp; <span class="hljs-string">'splice'</span>, 
&nbsp; <span class="hljs-string">'sort'</span>, 
&nbsp; <span class="hljs-string">'reverse'</span> 
] 
methodsToPatch.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">method</span>) </span>&#123; 
&nbsp; <span class="hljs-keyword">const</span> original = arrayProto[method] 
&nbsp; def(arrayMethods, method, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mutator</span> (<span class="hljs-params">...args</span>) </span>&#123; 
&nbsp; &nbsp; <span class="hljs-keyword">const</span> result = original.apply(<span class="hljs-built_in">this</span>, args) 
&nbsp; &nbsp; <span class="hljs-keyword">const</span> ob = <span class="hljs-built_in">this</span>.__ob__ 
&nbsp; &nbsp; <span class="hljs-keyword">let</span> inserted 
&nbsp; &nbsp; <span class="hljs-keyword">switch</span> (method) &#123; 
&nbsp; &nbsp; &nbsp; <span class="hljs-keyword">case</span> <span class="hljs-string">'push'</span>: 
&nbsp; &nbsp; &nbsp; <span class="hljs-keyword">case</span> <span class="hljs-string">'unshift'</span>: 
&nbsp; &nbsp; &nbsp; &nbsp; inserted = args 
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">break</span> 
&nbsp; &nbsp; &nbsp; <span class="hljs-keyword">case</span> <span class="hljs-string">'splice'</span>: 
&nbsp; &nbsp; &nbsp; &nbsp; inserted = args.slice(<span class="hljs-number">2</span>) 
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">break</span> 
&nbsp; &nbsp; &#125; 
&nbsp; &nbsp; <span class="hljs-keyword">if</span> (inserted) ob.observeArray(inserted) 
&nbsp; &nbsp; ob.dep.notify() 
&nbsp; &nbsp; <span class="hljs-keyword">return</span> result 
&nbsp; &#125;) 
&#125;)
</code></pre>
<p data-nodeid="1012">第二步就是当遇到值为数组类型的属性时，将它的原型指向 arrayMethods 对象。</p>
<pre class="lang-typescript" data-nodeid="1013"><code data-language="typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> Observer &#123; 
&nbsp; value: <span class="hljs-built_in">any</span>; 
&nbsp; dep: Dep; 
&nbsp; vmCount: <span class="hljs-built_in">number</span>; 
&nbsp; <span class="hljs-keyword">constructor</span> (<span class="hljs-params">value: <span class="hljs-built_in">any</span></span>) &#123; 
&nbsp; &nbsp; <span class="hljs-built_in">this</span>.value = value 
&nbsp; &nbsp; <span class="hljs-built_in">this</span>.dep = <span class="hljs-keyword">new</span> Dep() 
&nbsp; &nbsp; <span class="hljs-built_in">this</span>.vmCount = <span class="hljs-number">0</span> 
&nbsp; &nbsp; def(value, <span class="hljs-string">'__ob__'</span>, <span class="hljs-built_in">this</span>) 
&nbsp; &nbsp; <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(value)) &#123; 
&nbsp; &nbsp; &nbsp; <span class="hljs-keyword">if</span> (hasProto) &#123; 
&nbsp; &nbsp; &nbsp; &nbsp; protoAugment(value, arrayMethods) 
&nbsp; &nbsp; &nbsp; &#125; <span class="hljs-keyword">else</span> &#123; 
&nbsp; &nbsp; &nbsp; &nbsp; copyAugment(value, arrayMethods, arrayKeys) 
&nbsp; &nbsp; &nbsp; &#125; 
&nbsp; &nbsp; &nbsp; <span class="hljs-built_in">this</span>.observeArray(value) 
&nbsp; &nbsp; &#125; <span class="hljs-keyword">else</span> &#123; 
&nbsp; &nbsp; &nbsp; <span class="hljs-built_in">this</span>.walk(value) 
&nbsp; &nbsp; &#125; 
&nbsp; &#125; 
&nbsp; walk (obj: <span class="hljs-built_in">Object</span>) &#123; 
&nbsp; &nbsp; <span class="hljs-keyword">const</span> keys = <span class="hljs-built_in">Object</span>.keys(obj) 
&nbsp; &nbsp; <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; keys.length; i++) &#123; 
&nbsp; &nbsp; &nbsp; defineReactive(obj, keys[i]) 
&nbsp; &nbsp; &#125; 
&nbsp; &#125; 
&nbsp; observeArray (items: <span class="hljs-built_in">Array</span>&lt;<span class="hljs-built_in">any</span>&gt;) &#123; 
&nbsp; &nbsp; <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, l = items.length; i &lt; l; i++) &#123; 
&nbsp; &nbsp; &nbsp; observe(items[i]) 
&nbsp; &nbsp; &#125; 
&nbsp; &#125; 
&#125;
</code></pre>
<p data-nodeid="1014">当然 Vue 3 中使用 Proxy 能更好地解决这个问题，Proxy 可以直接监听整个数据对象而不再需要分别监听每个属性，同时还提供了更多的 API 函数，只是在兼容性方面不如 Object.defineProperty() 函数。</p>
<h4 data-nodeid="1015">React</h4>
<p data-nodeid="1016">React 组件中的视图更新，并不是像 Vue 中那样自动响应的，而是需要手动调用 setState() 函数来触发。</p>
<p data-nodeid="1017">React 为了提升组件更新时的性能，不仅将状态更新包装成任务放入了异步队列，而且还使用了类似协程的方式来调度这些队列中的更新任务。任务的执行顺序会根据每个任务的优先级来进行调整，并且任务的执行过程中可能会被中断，但状态会被保存，直到合适的时候会再次读取状态并继续执行任务。整个实现过程相当复杂，由于篇幅所限，不对其原理展开分析了，有兴趣的同学可自行查阅相关资料学习。</p>
<p data-nodeid="1018">对于组件的开发者而言，这种调度机制的具体表现就是：在组件内部调用 setState() 来修改状态时将异步更新视图，而在原生 DOM 事件或异步操作中（比如 setTimeout、setInterval、Promise）则是同步更新视图。</p>
<h3 data-nodeid="1019">总结</h3>
<p data-nodeid="1020">这一课时我们讲解了主流视图库 Vue 和 React 的组件实现机制。</p>
<p data-nodeid="1021">两种框架用了不同的方式来描述组件视图，Vue 采用风格偏向 HTML 的模板语言，React 则采用了风格偏向 JavaScript 的 JSX 语法糖，虽然两者风格迥异，但都必须通过编译器进行编译之后才能在浏览器端执行。</p>
<p data-nodeid="1022">在组件的数据定义上，两者也有明显的区别。Vue 通过函数来创建并返回数据对象，React 组件的状态对象则具有不可变性。这两种方式都保证了不同组件实例拥有独立的数据（状态）对象。</p>
<p data-nodeid="1023">在渲染机制上，Vue 通过监听数据对象属性实现响应式的数据绑定，通过建立异步更新队列来提升性能。React 则需要手动调用 setState() 函数才能触发更新，同时建立了异步任务队列来提升性能。通过类似协程的方式来调度这些任务。</p>
<p data-nodeid="1024" class="">最后布置一道思考题：你还知道哪些数据绑定的实现方式？</p>

<hr>
<h3 id="精选评论"><a href="#精选评论" class="headerlink" title="精选评论"></a>精选评论</h3><h5 id="虎："><a href="#虎：" class="headerlink" title="*虎："></a>*虎：</h5><blockquote>
<p>vue3 proxy</p>
</blockquote>
<h5 id="ezra-xu："><a href="#ezra-xu：" class="headerlink" title="ezra.xu："></a>ezra.xu：</h5><blockquote>
<p>Proxy</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/11/02/%E4%BD%A0%E6%98%AF%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3%E7%BB%84%E4%BB%B6%E8%BF%99%E4%B8%AA%E6%A6%82%E5%BF%B5%E7%9A%84%EF%BC%9F/" data-id="claxeer9u000ov8w12s68budl" data-title="你是怎么理解组件这个概念的？" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-如何让浏览器更快地加载网络资源？" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/11/02/%E5%A6%82%E4%BD%95%E8%AE%A9%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9B%B4%E5%BF%AB%E5%9C%B0%E5%8A%A0%E8%BD%BD%E7%BD%91%E7%BB%9C%E8%B5%84%E6%BA%90%EF%BC%9F/" class="article-date">
  <time class="dt-published" datetime="2022-11-02T02:53:49.000Z" itemprop="datePublished">2022-11-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/11/02/%E5%A6%82%E4%BD%95%E8%AE%A9%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9B%B4%E5%BF%AB%E5%9C%B0%E5%8A%A0%E8%BD%BD%E7%BD%91%E7%BB%9C%E8%B5%84%E6%BA%90%EF%BC%9F/">如何让浏览器更快地加载网络资源？</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 data-nodeid="140072">浏览器加载网络资源的速度</h3>


<p data-nodeid="137891">想要加快浏览器加载网络资源的速度，可以通过减少响应内容大小，比如使用 gzip 算法压缩响应体内容和 HTTP/2 的压缩头部功能；另一种更通用也更为重要的技术就是<strong data-nodeid="138007">使用缓存</strong>。</p>
<p data-nodeid="141290">下面两张截图分别是未使用缓存以及使用浏览器默认缓存的请求文件所消耗的时间，可以看出使用缓存之后加载时间大大缩短。</p>
<p data-nodeid="141291" class=""><img src="https://s0.lgstatic.com/i/image/M00/31/4D/CgqCHl8MKQyAOi4qAAAqnHUKGOQ421.png" alt="Drawing 0.png" data-nodeid="141295"></p>

<div data-nodeid="144350" class=""><p style="text-align:center">从服务端请求文件所消耗的时间</p></div>

<p data-nodeid="142513" class=""><img src="https://s0.lgstatic.com/i/image/M00/31/42/Ciqc1F8MKRaAVJdKAAAsNYhLc68530.png" alt="Drawing 1.png" data-nodeid="142517"></p>

<div data-nodeid="144959" class=""><p style="text-align:center">从缓存中获取文件所消耗的时间</p></div>

<p data-nodeid="137897">Web 缓存按存储位置来区分，包括<strong data-nodeid="138034">数据库缓存</strong>、<strong data-nodeid="138035">服务端缓存</strong>、<strong data-nodeid="138036">CDN 缓存</strong>和<strong data-nodeid="138037">浏览器缓存</strong>。这一课时我们着重介绍浏览器缓存。</p>
<p data-nodeid="137898">浏览器缓存的实现方式主要有两种：HTTP 和 ServiceWorker 。</p>
<h3 data-nodeid="137899">HTTP 缓存</h3>
<p data-nodeid="137900">使用缓存最大的问题往往不在于将资源缓存在什么位置或者如何读写资源，而在于如何保证缓存与实际资源一致的同时，提高缓存的命中率。也就是说尽可能地让浏览器从缓存中获取资源，但同时又要保证被使用的缓存与服务端最新的资源保持一致。</p>
<p data-nodeid="137901">为了达到这个目的，需要制定合适的缓存过期策略（简称“缓存策略”），HTTP 支持的缓存策略有两种：<strong data-nodeid="138050">强制缓存</strong>和<strong data-nodeid="138051">协商缓存</strong>。</p>
<h4 data-nodeid="137902">强制缓存</h4>
<p data-nodeid="137903">强制缓存是在浏览器加载资源的时候，先直接从缓存中查找请求结果，如果不存在该缓存结果，则直接向服务端发起请求。</p>
<p data-nodeid="137904"><strong data-nodeid="138061">1.</strong> <strong data-nodeid="138062">Expires</strong></p>
<p data-nodeid="146168">HTTP/1.0 中可以使用响应头部字段 Expires 来设置缓存时间，它对应一个未来的时间戳。客户端第一次请求时，服务端会在响应头部添加 Expires 字段。当浏览器再次发送请求时，先会对比当前时间和 Expires 对应的时间，如果当前时间早于 Expires 时间，那么直接使用缓存；反之，需要再次发送请求。</p>
<p data-nodeid="146169" class=""><img src="https://s0.lgstatic.com/i/image/M00/31/42/Ciqc1F8MKT-AbvemAAAGfctSoow363.png" alt="Drawing 2.png" data-nodeid="146173"></p>

<div data-nodeid="147395" class=""><p style="text-align:center">响应头部中的 Expires 信息</p></div>
<p></p>
<p data-nodeid="137908">上述 Expires 信息告诉浏览器：在 2020.10.10 日之前，可以直接使用该请求的缓存。但是使用 Expires 响应头时容易产生一个问题，那就是服务端和浏览器的时间很可能不同，因此这个缓存过期时间容易出现偏差。同样的，客户端也可以通过修改系统时间来继续使用缓存或提前让缓存失效。</p>
<p data-nodeid="137909">为了解决这个问题，HTTP/1.1 提出了 Cache-Control 响应头部字段。</p>
<p data-nodeid="137910"><strong data-nodeid="138077">2.</strong> <strong data-nodeid="138078">Cache-Control</strong></p>
<p data-nodeid="137911">它的常用值有下面几个：</p>
<ul data-nodeid="137912">
<li data-nodeid="137913">
<p data-nodeid="137914"><strong data-nodeid="138084">no-cache</strong>，表示使用协商缓存，即每次使用缓存前必须向服务端确认缓存资源是否更新；</p>
</li>
<li data-nodeid="137915">
<p data-nodeid="137916"><strong data-nodeid="138089">no-store</strong>，禁止浏览器以及所有中间缓存存储响应内容；</p>
</li>
<li data-nodeid="137917">
<p data-nodeid="137918"><strong data-nodeid="138094">public</strong>，公有缓存，表示可以被代理服务器缓存，可以被多个用户共享；</p>
</li>
<li data-nodeid="137919">
<p data-nodeid="137920"><strong data-nodeid="138099">private</strong>，私有缓存，不能被代理服务器缓存，不可以被多个用户共享；</p>
</li>
<li data-nodeid="137921">
<p data-nodeid="137922"><strong data-nodeid="138104">max-age</strong>，以秒为单位的数值，表示缓存的有效时间；</p>
</li>
<li data-nodeid="137923">
<p data-nodeid="137924"><strong data-nodeid="138109">must-revalidate</strong>，当缓存过期时，需要去服务端校验缓存的有效性。</p>
</li>
</ul>
<p data-nodeid="137925">这几个值可以组合使用，比如像下面这样：</p>
<pre class="lang-java" data-nodeid="148306"><code data-language="java">cache-control: <span class="hljs-keyword">public</span>, max-age=<span class="hljs-number">31536000</span>
</code></pre>


<p data-nodeid="137927">告诉浏览器该缓存为公有缓存，有效期 1 年。</p>
<p data-nodeid="137928">需要注意的是，cache-control 的 max-age 优先级高于 Expires，也就是说如果它们同时出现，浏览器会使用 max-age 的值。</p>
<p data-nodeid="137929">注意，虽然你可能在其他资料中看到可以使用 meta 标签来设置缓存，比如像下面的形式：</p>
<pre class="lang-xml" data-nodeid="137930"><code data-language="xml"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span>&nbsp;<span class="hljs-attr">http-equiv</span>=<span class="hljs-string">"expires"</span>&nbsp;<span class="hljs-attr">content</span>=<span class="hljs-string">"Wed,&nbsp;20&nbsp;Jun&nbsp;2021&nbsp;22:33:00&nbsp;GMT"</span>
</span></code></pre>
<p data-nodeid="137931">但在 HTML5 规范中，并不支持这种方式，所以尽量不要使用 meta 标签来设置缓存。</p>
<h4 data-nodeid="137932">协商缓存</h4>
<p data-nodeid="137933">协商缓存的更新策略是不再指定缓存的有效时间了，而是浏览器直接发送请求到服务端进行确认缓存是否更新，如果请求响应返回的 HTTP 状态为 304，则表示缓存仍然有效。控制缓存的难题就是从浏览器端转移到了服务端。</p>
<p data-nodeid="137934"><strong data-nodeid="138124">1.</strong> <strong data-nodeid="138125">Last-Modified 和 If-Modified-Since</strong></p>
<p data-nodeid="137935">服务端要判断缓存有没有过期，只能将双方的资源进行对比。若浏览器直接把资源文件发送给服务端进行比对的话，网络开销太大，而且也会失去缓存的意义，所以显然是不可取的。有一种简单的判断方法，那就是通过响应头部字段 Last-Modified 和请求头部字段 If-Modified-Since 比对双方资源的修改时间。</p>
<p data-nodeid="137936">具体工作流程如下：</p>
<ul data-nodeid="137937">
<li data-nodeid="137938">
<p data-nodeid="137939">浏览器第一次请求资源，服务端在返回资源的响应头中加入 Last-Modified 字段，该字段表示这个资源在服务端上的最近修改时间；</p>
</li>
<li data-nodeid="137940">
<p data-nodeid="137941">当浏览器再次向服务端请求该资源时，请求头部带上之前服务端返回的修改时间，这个请求头叫 If-Modified-Since；</p>
</li>
<li data-nodeid="137942">
<p data-nodeid="137943">服务端再次收到请求，根据请求头 If-Modified-Since 的值，判断相关资源是否有变化，如果没有，则返回 304 Not Modified，并且不返回资源内容，浏览器使用资源缓存值；否则正常返回资源内容，且更新 Last-Modified 响应头内容。</p>
</li>
</ul>
<p data-nodeid="137944">这种方式虽然能判断缓存是否失效，但也存在两个问题：</p>
<ul data-nodeid="137945">
<li data-nodeid="137946">
<p data-nodeid="137947"><strong data-nodeid="138136">精度问题</strong>，Last-Modified 的时间精度为秒，如果在 1 秒内发生修改，那么缓存判断可能会失效；</p>
</li>
<li data-nodeid="137948">
<p data-nodeid="137949"><strong data-nodeid="138141">准度问题</strong>，考虑这样一种情况，如果一个文件被修改，然后又被还原，内容并没有发生变化，在这种情况下，浏览器的缓存还可以继续使用，但因为修改时间发生变化，也会重新返回重复的内容。</p>
</li>
</ul>
<p data-nodeid="137950"><strong data-nodeid="138149">2.</strong> <strong data-nodeid="138150">ETag 和 If-None-Match</strong></p>
<p data-nodeid="137951">为了解决精度问题和准度问题，HTTP 提供了另一种不依赖于修改时间，而依赖于文件哈希值的精确判断缓存的方式，那就是响应头部字段 ETag 和请求头部字段 If-None-Match。</p>
<p data-nodeid="137952">具体工作流程如下：</p>
<ul data-nodeid="137953">
<li data-nodeid="137954">
<p data-nodeid="137955">浏览器第一次请求资源，服务端在返响应头中加入 Etag 字段，Etag 字段值为该资源的哈希值；</p>
</li>
<li data-nodeid="137956">
<p data-nodeid="137957">当浏览器再次跟服务端请求这个资源时，在请求头上加上 If-None-Match，值为之前响应头部字段 ETag 的值；</p>
</li>
<li data-nodeid="137958">
<p data-nodeid="137959">服务端再次收到请求，将请求头 If-None-Match 字段的值和响应资源的哈希值进行比对，如果两个值相同，则说明资源没有变化，返回 304 Not Modified；否则就正常返回资源内容，无论是否发生变化，都会将计算出的哈希值放入响应头部的 ETag 字段中。</p>
</li>
</ul>
<p data-nodeid="137960">这种缓存比较的方式也会存在一些问题，具体表现在以下两个方面。</p>
<ul data-nodeid="137961">
<li data-nodeid="137962">
<p data-nodeid="137963"><strong data-nodeid="138161">计算成本</strong>。生成哈希值相对于读取文件修改时间而言是一个开销比较大的操作，尤其是对于大文件而言。如果要精确计算则需读取完整的文件内容，如果从性能方面考虑，只读取文件部分内容，又容易判断出错。</p>
</li>
<li data-nodeid="137964">
<p data-nodeid="137965"><strong data-nodeid="138166">计算误差</strong>。HTTP 并没有规定哈希值的计算方法，所以不同服务端可能会采用不同的哈希值计算方式。这样带来的问题是，同一个资源，在两台服务端产生的 Etag 可能是不相同的，所以对于使用服务器集群来处理请求的网站来说，使用 Etag 的缓存命中率会有所降低。</p>
</li>
</ul>
<p data-nodeid="137966">需要注意的是，强制缓存的优先级高于协商缓存，在协商缓存中，Etag 优先级比 Last-Modified 高。既然协商缓存策略也存在一些缺陷，那么我们转移到浏览器端看看 ServiceWorker 能不能给我们带来惊喜。</p>
<h3 data-nodeid="137967">ServiceWorker</h3>
<p data-nodeid="137968">ServiceWorker 是浏览器在后台独立于网页运行的脚本，也可以这样理解，它是浏览器和服务端之间的代理服务器。ServiceWorker 非常强大，可以实现包括推送通知和后台同步等功能，更多功能还在进一步扩展，但其最主要的功能是<strong data-nodeid="138174">实现离线缓存</strong>。</p>
<h4 data-nodeid="137969">1. 使用限制</h4>
<p data-nodeid="137970">越强大的东西往往越危险，所以浏览器对 ServiceWorker 做了很多限制：</p>
<ul data-nodeid="150719">
<li data-nodeid="150720">
<p data-nodeid="150721">在 ServiceWorker 中无法直接访问 DOM，但可以通过 postMessage 接口发送的消息来与其控制的页面进行通信；</p>
</li>
<li data-nodeid="150722">
<p data-nodeid="150723">ServiceWorker 只能在本地环境下或 HTTPS 网站中使用；</p>
</li>
<li data-nodeid="150724">
<p data-nodeid="150725">ServiceWorker 有作用域的限制，一个 ServiceWorker 脚本只能作用于当前路径及其子路径；</p>
</li>
<li data-nodeid="150726">
<p data-nodeid="150727" class="te-preview-highlight">由于 ServiceWorker  属于实验性功能，所以兼容性方面会存在一些问题，具体兼容情况请看下面的截图。</p>
</li>
</ul>
<p data-nodeid="151340" class=""><img src="https://s0.lgstatic.com/i/image/M00/31/43/Ciqc1F8MKYGAMRqhAACGt0bNhOM842.png" alt="Drawing 3.png" data-nodeid="151344"></p>
<div data-nodeid="151341"><p style="text-align:center">ServiceWorker 在浏览器中的支持情况</p></div>





<h4 data-nodeid="137982">2. 使用方法</h4>
<p data-nodeid="137983">在使用 ServiceWorker 脚本之前先要通过“注册”的方式加载它。常见的注册代码如下所示：</p>
<pre class="lang-javascript" data-nodeid="137984"><code data-language="javascript"><span class="hljs-keyword">if</span>&nbsp;(<span class="hljs-string">'serviceWorker'</span>&nbsp;<span class="hljs-keyword">in</span>&nbsp;<span class="hljs-built_in">window</span>.navigator)&nbsp;&#123;
&nbsp;&nbsp;<span class="hljs-built_in">window</span>.navigator.serviceWorker
&nbsp;&nbsp;&nbsp;&nbsp;.register(<span class="hljs-string">'./sw.js'</span>)
&nbsp;&nbsp;&nbsp;&nbsp;.then(<span class="hljs-built_in">console</span>.log)
&nbsp;&nbsp;&nbsp;&nbsp;.catch(<span class="hljs-built_in">console</span>.error)
&#125;&nbsp;<span class="hljs-keyword">else</span>&nbsp;&#123;
&nbsp;&nbsp;<span class="hljs-built_in">console</span>.warn(<span class="hljs-string">'浏览器不支持&nbsp;ServiceWorker!'</span>)
</code></pre>
<p data-nodeid="137985">首先考虑到浏览器的兼容性，判断 window.navigator 中是否存在 serviceWorker 属性，然后通过调用这个属性的 register 函数来告诉浏览器 ServiceWorker 脚本的路径。</p>
<p data-nodeid="137986">浏览器获取到 ServiceWorker 脚本之后会进行解析，解析完成会进行安装。可以通过监听 “install” 事件来监听安装，但这个事件只会在第一次加载脚本的时候触发。要让脚本能够监听浏览器的网络请求，还需要激活脚本。</p>
<p data-nodeid="137987">在脚本被激活之后，我们就可以通过监听 fetch 事件来拦截请求并加载缓存的资源了。</p>
<p data-nodeid="137988">下面是一个利用 ServiceWorker 内部的 caches 对象来缓存文件的示例代码。</p>
<pre class="lang-javascript" data-nodeid="137989"><code data-language="javascript"><span class="hljs-keyword">const</span>&nbsp;CACHE_NAME&nbsp;=&nbsp;<span class="hljs-string">'ws'</span>
<span class="hljs-keyword">let</span>&nbsp;preloadUrls&nbsp;=&nbsp;[<span class="hljs-string">'/index.css'</span>]


<p>self.addEventListener(<span class="hljs-string">‘install’</span>,&amp;nbsp;<span class="hljs-function"><span class="hljs-keyword">function</span>&amp;nbsp;(<span class="hljs-params">event</span>)&amp;nbsp;</span>&#123;<br>&amp;nbsp;&amp;nbsp;event.waitUntil(<br>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;caches.open(CACHE_NAME)<br>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;.then(<span class="hljs-function"><span class="hljs-keyword">function</span>&amp;nbsp;(<span class="hljs-params">cache</span>)&amp;nbsp;</span>&#123;<br>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;<span class="hljs-keyword">return</span>&amp;nbsp;cache.addAll(preloadUrls);<br>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&#125;)<br>&amp;nbsp;&amp;nbsp;);<br>&#125;);<br>self.addEventListener(<span class="hljs-string">‘fetch’</span>,&amp;nbsp;<span class="hljs-function"><span class="hljs-keyword">function</span>&amp;nbsp;(<span class="hljs-params">event</span>)&amp;nbsp;</span>&#123;<br>&amp;nbsp;&amp;nbsp;event.respondWith(<br>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;caches.match(event.request)<br>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;.then(<span class="hljs-function"><span class="hljs-keyword">function</span>&amp;nbsp;(<span class="hljs-params">response</span>)&amp;nbsp;</span>&#123;<br>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;<span class="hljs-keyword">if</span>&amp;nbsp;(response)&amp;nbsp;&#123;<br>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;<span class="hljs-keyword">return</span>&amp;nbsp;response;<br>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&#125;<br>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;<span class="hljs-keyword">return</span>&amp;nbsp;caches.open(CACHE_NAME).then(<span class="hljs-function"><span class="hljs-keyword">function</span>&amp;nbsp;(<span class="hljs-params">cache</span>)&amp;nbsp;</span>&#123;<br>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;<span class="hljs-keyword">const</span>&amp;nbsp;path&amp;nbsp;&#x3D;&amp;nbsp;event.request.url.replace(self.location.origin,&amp;nbsp;<span class="hljs-string">‘’</span>)<br>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;<span class="hljs-keyword">return</span>&amp;nbsp;cache.add(path)<br>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&#125;)<br>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;.catch(<span class="hljs-function"><span class="hljs-params">e</span>&amp;nbsp;&#x3D;&gt;</span>&amp;nbsp;<span class="hljs-built_in">console</span>.error(e))<br>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&#125;)<br>&amp;nbsp;&amp;nbsp;);<br>&#125;)<br></code></pre></p>
<p data-nodeid="137990">这段代码首先监听 install 事件，在回调函数中调用了 event.waitUntil() 函数并传入了一个 Promise 对象。event.waitUntil 用来监听多个异步操作，包括缓存打开和添加缓存路径。如果其中一个操作失败，则整个 ServiceWorker 启动失败。</p>
<p data-nodeid="137991">然后监听了 fetch 事件，在回调函数内部调用了函数 event.respondWith() 并传入了一个 Promise 对象，当捕获到 fetch 请求时，会直接返回 event.respondWith 函数中 Promise 对象的结果。</p>
<p data-nodeid="137992">在这个 Promise 对象中，我们通过 caches.match 来和当前请求对象进行匹配，如果匹配上则直接返回匹配的缓存结果，否则返回该请求结果并缓存。</p>
<h3 data-nodeid="137993">总结</h3>
<p data-nodeid="137994">缓存是解决性能问题的重要手段，使用缓存的好处很多，除了能让浏览器更快地加载网络资源之外，还会带来其他好处，比如节省网络流量和带宽，以及减少服务端的负担。</p>
<p data-nodeid="137995">本课时介绍了 HTTP 缓存策略及 ServiceWorker，HTTP 缓存可以分为强制缓存和协商缓存，强制缓存就是在缓存有效期内直接使用浏览器缓存；协商缓存则需要先询问服务端资源是否发生改变，如果未改变再使用浏览器缓存。</p>
<p data-nodeid="137996">ServiceWorker 可以用来实现离线缓存，主要实现原理是拦截浏览器请求并返回缓存的资源文件。</p>
<p data-nodeid="139450">最后布置一道思考题：如果要让浏览器不缓存资源，你有哪些实现方式？</p>

<hr>
<h3 id="精选评论"><a href="#精选评论" class="headerlink" title="精选评论"></a>精选评论</h3><h5 id="3336："><a href="#3336：" class="headerlink" title="**3336："></a>**3336：</h5><blockquote>
<p>F5，或者清理缓存</p>
</blockquote>
<h5 id="锋："><a href="#锋：" class="headerlink" title="**锋："></a>**锋：</h5><blockquote>
<p>设置强缓存Cache-Control：no-store</p>
</blockquote>
<h5 id="道："><a href="#道：" class="headerlink" title="*道："></a>*道：</h5><blockquote>
<p>思考题：因为强制缓存的优先级高于协商缓存，在强制缓存中，max-age 优先级高于 expires；在协商缓存中，Etag 优先级高于 Last-Modified。所以，浏览器不缓存可以使用强制缓存的 control-cache: no-store 或 cache-control: no-cache。</p>
</blockquote>
<h5 id="旺："><a href="#旺：" class="headerlink" title="*旺："></a>*旺：</h5><blockquote>
<p>老师，强缓存和协商缓存是前端设置的还是后端设置的？</p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-讲师回复："><a href="#amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; 服务端返回数据的时候会在头部信息中设置哦~</p>
</blockquote>
<h5 id="材："><a href="#材：" class="headerlink" title="**材："></a>**材：</h5><blockquote>
<p>使用浏览器的无痕模式可以不缓存资源</p>
</blockquote>
<h5 id="锋：-1"><a href="#锋：-1" class="headerlink" title="**锋："></a>**锋：</h5><blockquote>
<p>或者Cache-Controlmax-age：0</p>
</blockquote>
<h5 id="辉："><a href="#辉：" class="headerlink" title="**辉："></a>**辉：</h5><blockquote>
<p>老师，前端缓存怎么做到一致性呢？</p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-1"><a href="#amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-1" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; 一致性是关于缓存的经典问题，其实协商缓存的出现就是为了解决这个问题，核心操作都是用一个特定的标识（修改时间或etag）将本地缓存资源和服务端的资源进行比对。</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/11/02/%E5%A6%82%E4%BD%95%E8%AE%A9%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9B%B4%E5%BF%AB%E5%9C%B0%E5%8A%A0%E8%BD%BD%E7%BD%91%E7%BB%9C%E8%B5%84%E6%BA%90%EF%BC%9F/" data-id="claxeera10013v8w1dcc93zre" data-title="如何让浏览器更快地加载网络资源？" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-手写-Promie、ayncawait" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/11/02/%E6%89%8B%E5%86%99-Promie%E3%80%81ayncawait/" class="article-date">
  <time class="dt-published" datetime="2022-11-02T02:53:12.000Z" itemprop="datePublished">2022-11-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/11/02/%E6%89%8B%E5%86%99-Promie%E3%80%81ayncawait/">手写 Promie、ayncawait</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p data-nodeid="909" class="">Promise、async/await 已经逐渐成为主流的异步处理方式，所以了解其实现原理非常重要。这一课时我们就来讲讲 Promise 和 async/await 的实现。</p>
<h3 data-nodeid="910">Promise/A+ 规范</h3>
<p data-nodeid="911">在编写 Promise 之前，我们必须了解 Promise/A+ 规范。由于内容较长，下面我总结了几点，更详细的内容可以查阅 <a target="_blank" rel="noopener" href="https://promisesaplus.com/" data-nodeid="1027">Promise/A+ 规范</a>。</p>
<p data-nodeid="912">Promise 是一个对象或者函数，对外提供了一个 then 函数，内部拥有 3 个状态。</p>
<h4 data-nodeid="913">then 函数</h4>
<p data-nodeid="914">then 函数接收两个函数作为可选参数：</p>
<pre class="lang-javascript" data-nodeid="915"><code data-language="javascript">promise.then(onFulfilled, onRejected)
</code></pre>
<p data-nodeid="916">同时遵循下面几个规则：</p>
<ul data-nodeid="917">
<li data-nodeid="918">
<p data-nodeid="919">如果可选参数不为函数时应该被忽略；</p>
</li>
<li data-nodeid="920">
<p data-nodeid="921">两个函数都应该是异步执行的，即放入事件队列等待下一轮 tick，而非立即执行；</p>
</li>
<li data-nodeid="922">
<p data-nodeid="923">当调用 onFulfilled 函数时，会将当前 Promise 的值作为参数传入；</p>
</li>
<li data-nodeid="924">
<p data-nodeid="925">当调用 onRejected 函数时，会将当前 Promise 的失败原因作为参数传入；</p>
</li>
<li data-nodeid="926">
<p data-nodeid="927">then 函数的返回值为 Promise。</p>
</li>
</ul>
<h4 data-nodeid="928">Promise 状态</h4>
<p data-nodeid="929">Promise 的 3 个状态分别为 pending、fulfilled 和 rejected。</p>
<ul data-nodeid="930">
<li data-nodeid="931">
<p data-nodeid="932">pending：“等待”状态，可以转移到 fulfilled 或者 rejected 状态</p>
</li>
<li data-nodeid="933">
<p data-nodeid="934">fulfilled：“执行”（或“履行”）状态，是 Promise 的最终态，表示执行成功，该状态下不可再改变。</p>
</li>
<li data-nodeid="935">
<p data-nodeid="936">rejected：“拒绝”状态，是 Promise 的最终态，表示执行失败，该状态不可再改变。</p>
</li>
</ul>
<h4 data-nodeid="937">Promise 解决过程</h4>
<p data-nodeid="1136" class="te-preview-highlight">Promise 解决过程是一个抽象的操作，即接收一个 promise 和一个值 x，目的就是对 Promise 形式的执行结果进行统一处理。需要考虑以下 4 种情况。</p>
<p data-nodeid="939"><strong data-nodeid="1048">情况 1： x 等于 promise</strong></p>
<p data-nodeid="940">抛出一个 TypeError 错误，拒绝 promise。</p>
<p data-nodeid="941"><strong data-nodeid="1053">情况 2：x 为 Promise 的实例</strong></p>
<p data-nodeid="942">如果 x 处于等待状态，那么 promise 继续等待至 x 执行或拒绝，否则根据 x 的状态执行/拒绝 promise。</p>
<p data-nodeid="943"><strong data-nodeid="1058">情况 3：x 为对象或函数</strong></p>
<p data-nodeid="944">该情况的核心是取出 x.then 并调用，在调用的时候将 this 指向 x。将 then 回调函数中得到结果 y 传入新的 Promise 解决过程中，形成一个递归调用。其中，如果执行报错，则以对应的错误为原因拒绝 promise。</p>
<p data-nodeid="945">这一步是处理拥有 then() 函数的对象或函数，这类对象或函数我们称之为“thenable”。注意，它只是拥有 then() 函数，并不是 Promise 实例。</p>
<p data-nodeid="946"><strong data-nodeid="1064">情况 4：如果 x 不为对象或函数</strong></p>
<p data-nodeid="947">以 x 作为值，执行 promise。</p>
<h3 data-nodeid="948">Promise 实现</h3>
<p data-nodeid="949">下面我们就根据规范来逐步实现一个 Promise。</p>
<h4 data-nodeid="950">Promise() 函数及状态</h4>
<p data-nodeid="951">由于 Promise 只有 3 个 状态，这里我们可以先创建 3 个“常量”来消除魔术字符串：</p>
<pre class="lang-javascript" data-nodeid="952"><code data-language="javascript">var&nbsp;PENDING&nbsp;=&nbsp;'pending'
var&nbsp;FULFILLED&nbsp;=&nbsp;'fulfilled'
var&nbsp;REJECTED&nbsp;=&nbsp;'rejected
</code></pre>
<p data-nodeid="953">由于 Promise 可以被实例化，所以可以定义成类或函数，这里为了增加难度，先考虑在 ES5 环境下实现，所以写成构造函数的形式。</p>
<p data-nodeid="954">使用过 Promise 的人肯定知道，在创建 Promise 的时候会传入一个回调函数，该回调函数会接收两个参数，分别用来执行或拒绝当前 Promise。同时考虑到 Promise 在执行时可能会有返回值，在拒绝时会给出拒绝原因，我们分别用 value 和 reason 两个变量来表示。具体代码如下：</p>
<pre class="lang-javascript" data-nodeid="955"><code data-language="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span>&nbsp;<span class="hljs-title">Promise</span>(<span class="hljs-params">execute</span>)&nbsp;</span>&#123;
&nbsp;&nbsp;<span class="hljs-keyword">var</span>&nbsp;self&nbsp;=&nbsp;<span class="hljs-keyword">this</span>;
&nbsp;&nbsp;self.state&nbsp;=&nbsp;PENDING;
&nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">function</span>&nbsp;<span class="hljs-title">resolve</span>(<span class="hljs-params">value</span>)&nbsp;</span>&#123;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">if</span>&nbsp;(self.state&nbsp;===&nbsp;PENDING)&nbsp;&#123;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.state&nbsp;=&nbsp;FULFILLED;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.value&nbsp;=&nbsp;value;
&nbsp;&nbsp;&nbsp;&nbsp;&#125;
&nbsp;&nbsp;&#125;
&nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">function</span>&nbsp;<span class="hljs-title">reject</span>(<span class="hljs-params">reason</span>)&nbsp;</span>&#123;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">if</span>&nbsp;(self.state&nbsp;===&nbsp;PENDING)&nbsp;&#123;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.state&nbsp;=&nbsp;REJECTED;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.reason&nbsp;=&nbsp;reason;
&nbsp;&nbsp;&nbsp;&nbsp;&#125;
&nbsp;&nbsp;&#125;
&nbsp;&nbsp;<span class="hljs-keyword">try</span>&nbsp;&#123;
&nbsp;&nbsp;&nbsp;&nbsp;execute(resolve,&nbsp;reject);
&nbsp;&nbsp;&#125;&nbsp;<span class="hljs-keyword">catch</span>&nbsp;(e)&nbsp;&#123;
&nbsp;&nbsp;&nbsp;&nbsp;reject(e);
&nbsp;&nbsp;&#125;
&#125;
</code></pre>
<p data-nodeid="956">我们在第 09 课时中提过，Promise 是单次执行的，所以需要判断状态为 PENDING 的时候再执行函数 resolve() 或函数 reject() 。同时 Promise 的内部异常不能直接抛出，所以要进行异常捕获。</p>
<h4 data-nodeid="957">then() 函数</h4>
<p data-nodeid="958">每个 Promise 实例都有一个 then() 函数，该函数会访问 Promise 内部的值或拒绝原因，所以通过函数原型 prototype 来实现。then() 函数接收两个回调函数作为参数，于是写成下面的形式：</p>
<pre class="lang-javascript" data-nodeid="959"><code data-language="javascript"><span class="hljs-built_in">Promise</span>.prototype.then = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">onFulfilled, onRejected</span>) </span>&#123;
&#125;
</code></pre>
<p data-nodeid="960">根据第 1 条原则，如果可选参数不为函数时应该被忽略，所以在函数 then() 内部加上对参数的判断：</p>
<pre class="lang-javascript" data-nodeid="961"><code data-language="javascript">onFulfilled = <span class="hljs-keyword">typeof</span> onFulfilled === <span class="hljs-string">"function"</span> ? onFulfilled : <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) </span>&#123;
&nbsp; <span class="hljs-keyword">return</span> x
&#125;;
onRejected = <span class="hljs-keyword">typeof</span> onRejected === <span class="hljs-string">"function"</span> ? onRejected : <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123;
&nbsp; <span class="hljs-keyword">throw</span> e
&#125;;
</code></pre>
<p data-nodeid="962">根据第 2 条规则，传入的回调函数是异步执行的。要模拟异步，可以通过 setTimeout 来延迟执行。再根据第 3 条和第 4 条规则，应根据 Promise 的状态来执行对应的回调，执行状态下调用 onFulfilled() 函数，拒绝状态下调用 onRejected() 函数。</p>
<pre class="lang-javascript" data-nodeid="963"><code data-language="javascript"><span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
<span class="hljs-keyword">switch</span> (self.state) &#123;
&nbsp; <span class="hljs-keyword">case</span> FULFILLED:
&nbsp; &nbsp; setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
&nbsp; &nbsp; &nbsp; onFulfilled(self.value);
&nbsp; &nbsp; &#125;)
&nbsp; &nbsp; <span class="hljs-keyword">break</span>;
&nbsp; <span class="hljs-keyword">case</span> REJECTED:
&nbsp; &nbsp; setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
&nbsp; &nbsp; &nbsp; onRejected(self.reason);
&nbsp; &nbsp; &#125;)
&nbsp; &nbsp; <span class="hljs-keyword">break</span>;
&nbsp; <span class="hljs-keyword">case</span> PENDING:
    <span class="hljs-comment">// todo</span>
&nbsp; &nbsp; <span class="hljs-keyword">break</span>;
&#125;
</code></pre>
<p data-nodeid="964">等待状态下就有些麻烦了，需要等到 Promise 状态转变时才能调用。</p>
<p data-nodeid="965">按照常规处理方式，可以建立一个监听，监听 Promise 的状态值改变。由于浏览器环境和 Node.js 环境的事件监听不一样，考虑兼容性，这种实现会比较复杂。</p>
<p data-nodeid="966">换个角度来看，在不考虑异常的情况下 Promise 的状态改变只依赖于构造函数中的 resolve() 函数和 reject() 函数执行。所以可考虑将 onFulfilled() 和 onRejected() 函数先保存到 Promise 属性 onFulfilledFn 和 onRejectedFn 中，等到状态改变时再调用。</p>
<pre class="lang-javascript" data-nodeid="967"><code data-language="javascript"><span class="hljs-keyword">case</span> PENDING:
&nbsp; self.onFulfilledFn = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
&nbsp; &nbsp; onFulfilled(self.value);
  &#125;
&nbsp; self.onRejectedFn = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
&nbsp; &nbsp; onRejected(self.reason);
&nbsp; &#125;
  <span class="hljs-keyword">break</span>;
</code></pre>
<p data-nodeid="968">最后看第 5 条规则，then() 被调用时应该返回一个新的 Promise，所以在上面的 3 种状态的处理逻辑中，都应该创建并返回一个 Promise 实例。以执行状态为例，可以改成下面的样子。</p>
<pre class="lang-javascript" data-nodeid="969"><code data-language="javascript"><span class="hljs-keyword">case</span> FULFILLED:
&nbsp; promise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>&#123;
&nbsp; &nbsp; setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
&nbsp; &nbsp; &nbsp; <span class="hljs-keyword">try</span> &#123;
&nbsp; &nbsp; &nbsp; &nbsp; onFulfilled(self.value);
&nbsp; &nbsp; &nbsp; &#125; <span class="hljs-keyword">catch</span> (e) &#123;
&nbsp; &nbsp; &nbsp; &nbsp; reject(e)
&nbsp; &nbsp; &nbsp; &#125;
&nbsp; &nbsp; &#125;)
&nbsp; &#125;);
&nbsp; <span class="hljs-keyword">break</span>;
</code></pre>
<p data-nodeid="970">同时，它带来的另一个效果是<strong data-nodeid="1086">支持链式调用</strong>。在链式调用的情况下，如果 Promise 实例处于等待状态，那么需要保存多个 resolve() 或 reject() 函数，所以 onFulfilledFn 和 onRejectedFn 应该改成数组。</p>
<pre class="lang-javascript" data-nodeid="971"><code data-language="javascript"><span class="hljs-keyword">case</span> PENDING:
&nbsp; promise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>&#123;
&nbsp; &nbsp; self.onFulfilledFn.push(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
&nbsp; &nbsp; &nbsp; <span class="hljs-keyword">try</span> &#123;
&nbsp; &nbsp; &nbsp; &nbsp; onFulfilled(self.value);
&nbsp; &nbsp; &nbsp; &#125; <span class="hljs-keyword">catch</span> (e) &#123;
&nbsp; &nbsp; &nbsp; &nbsp; reject(e)
&nbsp; &nbsp; &nbsp; &#125;
&nbsp; &nbsp; &#125;);
&nbsp; &nbsp; self.onRejectedFn.push(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
&nbsp; &nbsp; &nbsp; <span class="hljs-keyword">try</span> &#123;
&nbsp; &nbsp; &nbsp; &nbsp; onRejected(self.reason);
&nbsp; &nbsp; &nbsp; &#125; <span class="hljs-keyword">catch</span> (e) &#123;
&nbsp; &nbsp; &nbsp; &nbsp; reject(e)
&nbsp; &nbsp; &nbsp; &#125;
&nbsp; &nbsp; &#125;)
&nbsp; &#125;);
&nbsp; <span class="hljs-keyword">break</span>;
</code></pre>
<p data-nodeid="972">对应的，Promise 构造函数中应该初始化属性 onFulfilledFn 和 onRejectedFn 为数组，同时 resolve() 和 reject() 函数在改变状态时应该调用这个数组中的函数，并且这个调用过程应该是异步的。</p>
<pre class="lang-javascript" data-nodeid="973"><code data-language="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Promise</span>(<span class="hljs-params">execute</span>) </span>&#123;
  ...
&nbsp; self.onFulfilledFn = [];
&nbsp; self.onRejectedFn = [];
  ...
  function resolve(value) &#123;
    setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
      ...
  &nbsp; &nbsp; self.onFulfilledFn.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">f</span>) </span>&#123;
&nbsp;   &nbsp; &nbsp; f(self.value)
  &nbsp; &nbsp; &#125;)
    &#125;)
&nbsp; &#125;
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reject</span>(<span class="hljs-params">reason</span>) </span>&#123;
    setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
      ...
  &nbsp; &nbsp; self.onRejectedFn.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">f</span>) </span>&#123;
  &nbsp; &nbsp; &nbsp; f(self.reason)
  &nbsp; &nbsp; &#125;)
    &#125;)
&nbsp; &#125;
&#125;
</code></pre>
<h4 data-nodeid="974">resolvePromise() 函数</h4>
<p data-nodeid="975">前面提到解决过程函数有两个参数及 3 种情况，先来考虑第 1 种情况，promise 与 x 相等，应该直接抛出 TypeError 错误：</p>
<pre class="lang-javascript" data-nodeid="976"><code data-language="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resolvePromise</span>(<span class="hljs-params">promise, x</span>) </span>&#123;
  <span class="hljs-keyword">if</span> (promise === x) &#123;
&nbsp; &nbsp; <span class="hljs-keyword">return</span> reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">"x 不能与 promise 相等"</span>));
&nbsp; &#125;
&#125;
</code></pre>
<p data-nodeid="977">情况 2，x 为 Promise 的实例，应该尝试让 promise 接受 x 的状态，怎么接受呢？</p>
<p data-nodeid="978">直接改变 promise 状态肯定是不可取的，首先状态信息属于内部变量，其次也无法调用属性 onResolvedFn 和 onFulfilledFn 中的待执行函数。所以必须要通过调用 promise 在构造时的函数 resolve() 和 reject() 来改变。</p>
<p data-nodeid="979">如果 x 处于等待状态，那么 promise 继续保持等待状态，等待解决过程函数 resolvePromise() 执行，否则应该用相同的值执行或拒绝 promise。我们无法从外部拒绝或执行一个 Promise 实例，只能通过调用构造函数传入的 resolve() 和 reject() 函数来实现。所以还需要把这两个函数作为参数传递到 resolvePromise 函数中。</p>
<p data-nodeid="980">在函数 resolvePromise() 内部加上情况 2 的判断，代码如下：</p>
<pre class="lang-javascript" data-nodeid="981"><code data-language="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resolvePromise</span>(<span class="hljs-params">promise, x, resolve, reject</span>) </span>&#123;
  ...
  if (x <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Promise</span>) &#123;
&nbsp; &nbsp; <span class="hljs-keyword">if</span> (x.state === FULFILLED) &#123;
&nbsp; &nbsp; &nbsp; resolve(x.value)
&nbsp; &nbsp; &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x.state === REJECTED) &#123;
&nbsp; &nbsp; &nbsp; reject(x.reason)
&nbsp; &nbsp; &#125; <span class="hljs-keyword">else</span> &#123;
&nbsp; &nbsp; &nbsp; x.then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">y</span>) </span>&#123;
&nbsp; &nbsp; &nbsp; &nbsp; resolvePromise(promise, y, resolve, reject)
&nbsp; &nbsp; &nbsp; &#125;, reject)
&nbsp; &nbsp; &#125;
&nbsp; &#125;
&#125;
</code></pre>
<p data-nodeid="982">再来实现情况 3，将 x.then 取出然后执行，并将执行结果放入解决过程函数 resolvePromise() 中。 考虑到 x 可能只是一个 thenable 而非真正的 Promise，所以在调用 then() 函数的时候要设置一个变量 excuted 避免重复调用。同时记得在执行时添加异常捕获并及时拒绝当前 promise。</p>
<pre class="lang-javascript" data-nodeid="983"><code data-language="javascript"><span class="hljs-keyword">if</span> ((x !== <span class="hljs-literal">null</span>) &amp;&amp; ((<span class="hljs-keyword">typeof</span> x === <span class="hljs-string">'object'</span>) || (<span class="hljs-keyword">typeof</span> x === <span class="hljs-string">'function'</span>))) &#123;
&nbsp; <span class="hljs-keyword">var</span> executed;
&nbsp; <span class="hljs-keyword">try</span> &#123;
&nbsp; &nbsp; <span class="hljs-keyword">var</span> then = x.then;
&nbsp; &nbsp; <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> then === <span class="hljs-string">"function"</span>) &#123;
&nbsp; &nbsp; &nbsp; then.call(x, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">y</span>) </span>&#123;
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">if</span> (executed) <span class="hljs-keyword">return</span>;
&nbsp; &nbsp; &nbsp; &nbsp; executed = <span class="hljs-literal">true</span>;
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">return</span> resolvePromise(promise, y, resolve, reject)
&nbsp; &nbsp; &nbsp; &#125;, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123;
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">if</span> (executed) <span class="hljs-keyword">return</span>;
&nbsp; &nbsp; &nbsp; &nbsp; executed = <span class="hljs-literal">true</span>;
&nbsp; &nbsp; &nbsp; &nbsp; reject(e);
&nbsp; &nbsp; &nbsp; &#125;)
&nbsp; &nbsp; &#125; <span class="hljs-keyword">else</span> &#123;
&nbsp; &nbsp; &nbsp; resolve(x);
&nbsp; &nbsp; &#125;
&nbsp; &#125; <span class="hljs-keyword">catch</span> (e) &#123;
&nbsp; &nbsp; <span class="hljs-keyword">if</span> (executed) <span class="hljs-keyword">return</span>;
&nbsp; &nbsp; executed = <span class="hljs-literal">true</span>;
&nbsp; &nbsp; reject(e);
&nbsp; &#125;
&#125;
</code></pre>
<p data-nodeid="984">情况 4 就很简单了，直接把 x 作为值执行。</p>
<pre class="lang-javascript" data-nodeid="985"><code data-language="javascript">resolve(x);
</code></pre>
<h3 data-nodeid="986">Promise 测试</h3>
<p data-nodeid="987">编写测试代码永远是一个好习惯，为了验证编写的 Promise 正确性，引用一个专门用来测试 Promise 规范性的模块 <a target="_blank" rel="noopener" href="https://github.com/promises-aplus/promises-tests" data-nodeid="1100">promises-aplus-tests</a>，该模块内置了数百个测试案例，支持命令行一键测试。只是在导出模块的时候需要遵循 CommonJS 规范，并且按照要求导出对应的函数。<a target="_blank" rel="noopener" href="https://github.com/yalishizhude/course/tree/master/plus2" data-nodeid="1104">最终代码地址请点击这里获取</a>。</p>
<p data-nodeid="988">测试结果如下图所示：</p>
<p data-nodeid="989"><img src="https://s0.lgstatic.com/i/image/M00/2B/DD/CgqCHl7_DEeALZgpAAALJ4MkJtQ487.png" alt="image (16).png" data-nodeid="1109"></p>
<h3 data-nodeid="990">async/await</h3>
<p data-nodeid="991">async 是 ES2017 标准推出的用于处理异步操作的关键字，从本质上来说，它就是 Generator 函数的语法糖。</p>
<h4 data-nodeid="992">什么是 Generator 函数？</h4>
<p data-nodeid="993">Generator 函数是 ES6 提出的除 Promise 之外的另一种<strong data-nodeid="1118">异步解决方案</strong>，不同于常见的异步回调，它的用法有些“奇怪”。这里我们只简单介绍一下它的主要用法。</p>
<p data-nodeid="994">当声明一个 Generator 函数时，需要在 function 关键字与函数名之间加上一个星号，像下面这样：</p>
<pre class="lang-java" data-nodeid="995"><code data-language="java">function* fn() &#123;
  ...
&#125;
</code></pre>
<p data-nodeid="996">当调用 Generator 函数后，函数并不会立即执行，而是返回一个迭代器对象。</p>
<ul data-nodeid="997">
<li data-nodeid="998">
<p data-nodeid="999">函数体内部使用 yield 表达式，定义不同的内部状态。</p>
</li>
<li data-nodeid="1000">
<p data-nodeid="1001">当函数体外部调用迭代器的 next() 函数时，函数会执行到下一个 yield 表达式的位置，并返回一个对象，该对象包含属性 value 和 done，value 是调用 next() 函数时传入的参数，done 为布尔值表示是否执行完成。</p>
</li>
</ul>
<p data-nodeid="1002">下面是一个将异步回调函数改写成 Generator 函数的示例代码：</p>
<pre class="lang-javascript" data-nodeid="1003"><code data-language="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">asyncFn</span>(<span class="hljs-params">cb</span>) </span>&#123;
&nbsp; setTimeout(cb, <span class="hljs-number">1000</span>, <span class="hljs-number">1</span>)
&#125;
<span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>&#123;
&nbsp; <span class="hljs-keyword">var</span> result = <span class="hljs-keyword">yield</span> asyncFn(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>) </span>&#123;
&nbsp; &nbsp; it.next(data);
&nbsp; &#125;)
&nbsp; <span class="hljs-built_in">console</span>.log(result)  <span class="hljs-comment">// 1</span>
&#125;
<span class="hljs-keyword">var</span> it = fn() 
it.next()
</code></pre>
<p data-nodeid="1004">下面讲讲这段代码的执行逻辑。</p>
<ul data-nodeid="1005">
<li data-nodeid="1006">
<p data-nodeid="1007">asyncFn() 是一个自定义的异步回调函数，1 秒后返回数值 1。</p>
</li>
<li data-nodeid="1008">
<p data-nodeid="1009">先调用 Generator 函数得到迭代器 it，但此时函数并没有执行，需要执行迭代器的 next() 函数才能调用函数 fn() 。</p>
</li>
<li data-nodeid="1010">
<p data-nodeid="1011">Generator 函数 fn() 内部调用异步函数 asyncFn 时使用了 yield 关键字，代表此处暂停执行，等到异步函数 asyncFn 执行完成后再执行后面的代码。</p>
</li>
<li data-nodeid="1012">
<p data-nodeid="1013">1 秒后，匿名回调函数内部得到的返回值 1，通过 it.next() 函数返回这个值，并告诉迭代器继续执行后面的 console.log。</p>
</li>
</ul>
<h4 data-nodeid="1014">async/await 原理</h4>
<p data-nodeid="1015">虽然说 Generator 函数号称是解决异步回调问题，但却带来了一些麻烦，比如函数外部无法捕获异常，比如多个 yield 会导致调试困难。所以相较之下 Promise 是更优秀的异步解决方案。</p>
<p data-nodeid="1016">async/await 做的事情就是将 Generator 函数转换成 Promise。下面代码描述的是 async 的实现逻辑：</p>
<pre class="lang-javascript" data-nodeid="1017"><code data-language="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span>&nbsp;<span class="hljs-title">generator2promise</span>(<span class="hljs-params">generatorFn</span>)&nbsp;</span>&#123;
&nbsp;&nbsp;<span class="hljs-keyword">return</span>&nbsp;<span class="hljs-function"><span class="hljs-keyword">function</span>&nbsp;(<span class="hljs-params"></span>)&nbsp;</span>&#123;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">var</span>&nbsp;gen&nbsp;=&nbsp;generatorFn.apply(<span class="hljs-keyword">this</span>,&nbsp;<span class="hljs-built_in">arguments</span>);
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span>&nbsp;<span class="hljs-keyword">new</span>&nbsp;<span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>&nbsp;(<span class="hljs-params">resolve,&nbsp;reject</span>)&nbsp;</span>&#123;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">function</span>&nbsp;<span class="hljs-title">step</span>(<span class="hljs-params">key,&nbsp;arg</span>)&nbsp;</span>&#123;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">try</span>&nbsp;&#123;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">var</span>&nbsp;info&nbsp;=&nbsp;gen[key](arg);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">var</span>&nbsp;value&nbsp;=&nbsp;info.value;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#125;&nbsp;<span class="hljs-keyword">catch</span>&nbsp;(error)&nbsp;&#123;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reject(error);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span>;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#125;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">if</span>&nbsp;(info.done)&nbsp;&#123;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resolve(value);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#125;&nbsp;<span class="hljs-keyword">else</span>&nbsp;&#123;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span>&nbsp;<span class="hljs-built_in">Promise</span>.resolve(value).then(<span class="hljs-function"><span class="hljs-keyword">function</span>&nbsp;(<span class="hljs-params">value</span>)&nbsp;</span>&#123;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;step(<span class="hljs-string">"next"</span>,&nbsp;value);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#125;,&nbsp;<span class="hljs-function"><span class="hljs-keyword">function</span>&nbsp;(<span class="hljs-params">err</span>)&nbsp;</span>&#123;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;step(<span class="hljs-string">"throw"</span>,&nbsp;err);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#125;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#125;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#125;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span>&nbsp;step(<span class="hljs-string">"next"</span>);
&nbsp;&nbsp;&nbsp;&nbsp;&#125;);
&nbsp;&nbsp;&#125;;
&#125;
</code></pre>
<p data-nodeid="1018">它将 Generator 函数包装成了一个新的匿名函数，调用这个匿名函数时返回一个 Promise。在这个 Promise 内部会创建一个 step() 函数，该函数负责递归调用 Generator 函数对应的迭代器，当迭代器执行完成时执行当前的 Promise，失败时则拒绝 Promise。</p>
<h3 data-nodeid="1019">总结</h3>
<p data-nodeid="1020">本课时通过代码实例深入分析了 Promise/A+ 规范以及 async/await 的实现原理。对于手写 Promise 的过程，重点不在于实现结果，而在于实现过程，即先理解清楚规范，然后根据规范一步一步地去实现和优化。对于 async/await 语法糖，结合 Generator 函数，理解其封装原理即可。</p>
<p data-nodeid="1021" class="">最后布置一道练习题：学完本课时内容后，试着自己动手写一个 Promise，看看能否通过测试用例。</p>

<hr>
<h3 id="精选评论"><a href="#精选评论" class="headerlink" title="精选评论"></a>精选评论</h3><h5 id="晨："><a href="#晨：" class="headerlink" title="*晨："></a>*晨：</h5><blockquote>
<p>Promise 解决过程是一个抽象的操作，即接收一个 promise 和一个值 x，目的就是对 Promise 形式的执行结果进行统一处理。需要考虑以下 3 种情况。在这里讲到的一个值 x是什么意思呀？？这块儿的看的不是很明白</p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-讲师回复："><a href="#amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; 可以简单地理解为 Promise 执行成功的返回值。</p>
</blockquote>
<h5 id="翔："><a href="#翔：" class="headerlink" title="**翔："></a>**翔：</h5><blockquote>
<p>self.onFulfilledFn.forEach(function (f) {<br> f(self.value)<br>“&gt;self.onFulfilledFn.push(function () {<br>“&gt;try {</p>
</blockquote>
<p>“&gt;catch (e) {<br> reject(e)<br> }<br> })<br>老师这里的self.value参数可以不传的吧？我看后面也没用到呢</p>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-1"><a href="#amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-1" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; 嗯，也可以~</p>
</blockquote>
<h5 id="池："><a href="#池：" class="headerlink" title="**池："></a>**池：</h5><blockquote>
<p>虽然说 Generator 函数号称是解决异步回调问题，但却带来了一些麻烦，比如函数外部无法捕获异常，比如多个 yield 会导致调试困难。所以相较之下 Promise 是更优秀的异步解决方案。老师可以举例一下yield调试上的困难主要体现在什么地方吗？🙌</p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-2"><a href="#amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-2" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; 你可以把两个异步回调函数改成类似 Promise.all 的形式进行调用试试~</p>
</blockquote>
<h5 id="蕾："><a href="#蕾：" class="headerlink" title="*蕾："></a>*蕾：</h5><blockquote>
<p>在决议程序中的情况判断是不是可以不写，情况3中已经包含了这种判断</p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-3"><a href="#amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-3" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; 同学，建议你试一下去掉你认为多余的判断，并执行一下测试代码~</p>
</blockquote>
<h5 id="123："><a href="#123：" class="headerlink" title="123："></a>123：</h5><blockquote>
<p>写的很清晰</p>
</blockquote>
<h5 id="晨：-1"><a href="#晨：-1" class="headerlink" title="*晨："></a>*晨：</h5><blockquote>
<p>x 为对象或函数 为什么会有then？</p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-4"><a href="#amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-4" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; 比如 x &#x3D; {then() {…}}，这就是一个拥有 then 函数的对象</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/11/02/%E6%89%8B%E5%86%99-Promie%E3%80%81ayncawait/" data-id="claxeera5001cv8w11htlec2e" data-title="手写 Promie、ayncawait" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-浏览器如何执行-JavaScript-代码？" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/11/02/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C-JavaScript-%E4%BB%A3%E7%A0%81%EF%BC%9F/" class="article-date">
  <time class="dt-published" datetime="2022-11-02T02:52:34.000Z" itemprop="datePublished">2022-11-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/11/02/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C-JavaScript-%E4%BB%A3%E7%A0%81%EF%BC%9F/">浏览器如何执行 JavaScript 代码？</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p data-nodeid="909" class="">这一课时从编译过程和内存管理两个方面带你来探索 JavaScript 引擎的工作机制。</p>
<h3 data-nodeid="910">编译过程</h3>
<p data-nodeid="911">在“加餐1：手写 CSS 预处理器”中提过编译器的基本工作流程，大体上包括 3 个步骤：解析（Parsing）、转换（Transformation）及代码生成（Code Generation），JavaScript 引擎与之相比大体上也遵循这个过程，可分为解析、解释和优化 3 个步骤。下面我们就以 V8 引擎为例进行讲解。</p>
<h4 data-nodeid="912">解析</h4>
<p data-nodeid="913">解析步骤又可以拆分成 2 个小步骤：</p>
<ul data-nodeid="914">
<li data-nodeid="915">
<p data-nodeid="916"><strong data-nodeid="996">词法分析</strong>，将 JavaScript 代码解析成一个个的令牌（Token）；</p>
</li>
<li data-nodeid="917">
<p data-nodeid="918"><strong data-nodeid="1001">语法分析</strong>，将令牌组装成一棵抽象的语法树（AST）。</p>
</li>
</ul>
<p data-nodeid="919">下面是一段简单的代码，声明了一个字符串变量并调用函数 console.log 进行打印。</p>
<pre class="lang-javascript" data-nodeid="920"><code data-language="javascript"><span class="hljs-keyword">var</span> name = <span class="hljs-string">'web'</span>
<span class="hljs-built_in">console</span>.log(name)
</code></pre>
<p data-nodeid="921">通过<strong data-nodeid="1008">词法分析</strong>会对这段代码逐个字符进行解析，生成类似下面结构的令牌（Token），这些令牌类型各不相同，有关键字、标识符、符号、字符串。</p>
<pre class="lang-java" data-nodeid="922"><code data-language="java">Keyword(<span class="hljs-keyword">var</span>)
Identifier(name)
Punctuator(=)
String(<span class="hljs-string">'web'</span>)
Identifier(console)
Punctuator(.)
Identifier(log)
Punctuator(()
Identifier(name)
Punctuator())
</code></pre>
<p data-nodeid="923">语法分析阶段会用令牌生成类似下面结构的抽象语法树，生成树的过程并不是简单地把所有令牌都添加到树上，而是去除了不必要的符号令牌之后，按照语法规则来生成。</p>
<p data-nodeid="924"><img src="https://s0.lgstatic.com/i/image/M00/27/1E/Ciqc1F70ZQSAGf1cAAEehLtbbTk491.png" alt="1.png" data-nodeid="1012"><br>
抽象语法树</p>
<h4 data-nodeid="925">解释</h4>
<p data-nodeid="926">在加餐 1 中，我们将 AST 转换成新的 AST，而 JavaScript 引擎是通过解释器 Ignition 将 AST 转换成字节码。字节码是对机器码的一个抽象描述，相对于机器码而言，它的代码量更小，从而可以减少内存消耗。</p>
<p data-nodeid="927">下面代码是从示例代码生成的字节码中截取的一段。它的语法已经非常接近汇编语言了，有很多操作符，比如 StackCheck、Star、Return。考虑这些操作符过于底层，涉及处理器的累加器及寄存器操作，已经超出前端范围，这里就不详细介绍了。</p>
<pre class="lang-java" data-nodeid="928"><code data-language="java">[generated bytecode <span class="hljs-keyword">for</span> function: log (<span class="hljs-number">0x1e680d83fc59</span> &lt;SharedFunctionInfo log&gt;)]
Parameter count <span class="hljs-number">1</span>
Register count <span class="hljs-number">6</span>
Frame size <span class="hljs-number">48</span>
&nbsp;<span class="hljs-number">9646</span> E&gt; <span class="hljs-number">0x376a94a60ea6</span> @&nbsp; &nbsp; <span class="hljs-number">0</span> : a7&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; StackCheck&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;......
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-number">0x376a94a60ec9</span> @&nbsp; &nbsp;<span class="hljs-number">35</span> : <span class="hljs-number">26</span> f6&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Star r5
&nbsp;<span class="hljs-number">9683</span> E&gt; <span class="hljs-number">0x376a94a60ecb</span> @&nbsp; &nbsp;<span class="hljs-number">37</span> : <span class="hljs-number">5</span>a f9 <span class="hljs-number">02</span> f7 f6 <span class="hljs-number">06</span> CallProperty2 r2, &lt;<span class="hljs-keyword">this</span>&gt;, r4, r5, [<span class="hljs-number">6</span>]
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-number">0x376a94a60ed1</span> @&nbsp; &nbsp;<span class="hljs-number">43</span> : <span class="hljs-number">0</span>d&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LdaUndefined&nbsp;
&nbsp;<span class="hljs-number">9729</span> S&gt; <span class="hljs-number">0x376a94a60ed2</span> @&nbsp; &nbsp;<span class="hljs-number">44</span> : <span class="hljs-function">ab&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Return&nbsp;
Constant <span class="hljs-title">pool</span> <span class="hljs-params">(size = <span class="hljs-number">3</span>)</span>
Handler <span class="hljs-title">Table</span> <span class="hljs-params">(size = <span class="hljs-number">0</span>)</span>
Source Position <span class="hljs-title">Table</span> <span class="hljs-params">(size = <span class="hljs-number">24</span>)</span>
</span></code></pre>
<h4 data-nodeid="929">优化</h4>
<p data-nodeid="930">解释器在得到 AST 之后，会按需进行解释和执行，也就是说如果某个函数没有被调用，则不会去解释执行它。</p>
<p data-nodeid="931">在这个过程中解释器会将一些重复可优化的操作（比如类型判断）收集起来生成分析数据，然后将生成的字节码和分析数据传给编译器 TurboFan，编译器会依据分析数据来生成高度优化的机器码。</p>
<p data-nodeid="932">优化后的机器码的作用和缓存很类似，当解释器再次遇到相同的内容时，就可以直接执行优化后的机器码。当然优化后的代码有时可能会无法运行（比如函数参数类型改变），那么会再次反优化为字节码交给解释器。</p>
<p data-nodeid="933">整个过程如下面流程图所示：</p>
<p data-nodeid="934"><img src="https://s0.lgstatic.com/i/image/M00/27/29/CgqCHl70ZTqAR9m6AAEz8M57qjs116.png" alt="3.png" data-nodeid="1025"><br>
JavaScript 编译过程</p>
<h3 data-nodeid="935">内存管理</h3>
<p data-nodeid="936">JavaScript 引擎的内存空间分为<strong data-nodeid="1034">堆（Heap）和栈（Stack）</strong>。堆和栈是两种不同的数据结构，堆是具有树结构的数组，栈也是数组，但是遵循“先进后出”规则。</p>
<h4 data-nodeid="937">栈</h4>
<p data-nodeid="938">栈是一个临时存储空间，主要存储局部变量和函数调用（对于全局表达式会创建匿名函数并调用）。</p>
<p data-nodeid="939">对于基本数据类型（String、Undefined、Null、Boolean、Number、BigInt、Symbol）的局部变量，会直接在栈中创建，而对象数据类型局部变量会存储在堆中，栈中只存储它的引用地址，也就是我们常说的浅拷贝。全局变量以及闭包变量也是只存储引用地址。总而言之栈中存储的数据都是轻量的。</p>
<p data-nodeid="940">对于函数，解释器创建了“调用栈”（Call Stack）来记录函数的调用流程。每调用一个函数，解释器就会把该函数添加进调用栈，解释器会为被添加进的函数创建一个栈帧 （Stack Frame，这个栈帧用来保存函数的局部变量以及执行语句）并立即执行。如果正在执行的函数还调用了其它函数，那么新函数也将会被添加进调用栈并执行。一旦这个函数执行结束，对应的栈帧也会被立即销毁。</p>
<p data-nodeid="941">查看调用栈的方式有 2 种：</p>
<ul data-nodeid="942">
<li data-nodeid="943">
<p data-nodeid="944">调用函数 console.trace() 打印到控制台；</p>
</li>
<li data-nodeid="945">
<p data-nodeid="946">利用浏览器开发者工具进行断点调试。</p>
</li>
</ul>
<h4 data-nodeid="947">示例</h4>
<p data-nodeid="948">下面的代码是一个计算斐波那契数列的函数，分别通过调用 console.trace() 函数以及断点的方式得到了它的调用栈信息。</p>
<pre class="lang-javascript" data-nodeid="949"><code data-language="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fib</span>(<span class="hljs-params">n</span>) </span>&#123;
&nbsp; <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>
&nbsp; <span class="hljs-built_in">console</span>.trace();
&nbsp; <span class="hljs-keyword">return</span> fib(n<span class="hljs-number">-1</span>) + fib(n<span class="hljs-number">-2</span>)
&#125;
fib(<span class="hljs-number">4</span>)
</code></pre>
<p data-nodeid="950"><img src="https://s0.lgstatic.com/i/image/M00/27/16/Ciqc1F70SjGAI_8JAAANLDVx3V0087.png" alt="image (31).png" data-nodeid="1046"><br>
示例效果图</p>
<p data-nodeid="951"><img src="https://s0.lgstatic.com/i/image/M00/27/16/Ciqc1F70SjmAfUtiAAAkCGWd2MI629.png" alt="image (32).png" data-nodeid="1051"><br>
示例效果图</p>
<p data-nodeid="952">虽然栈很轻量，只会在使用时创建，使用结束时销毁，但它并不是可以无限增长的。当分配的调用栈空间被占满时，就会引发“栈溢出”错误。</p>
<p data-nodeid="953">下面是一个递归函数导致的栈溢出报错代码片段：</p>
<pre class="lang-javascript" data-nodeid="954"><code data-language="javascript">(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">recursive</span>(<span class="hljs-params"></span>) </span>&#123;
&nbsp; recursive()
&#125;)()
</code></pre>
<p data-nodeid="955"><img src="https://s0.lgstatic.com/i/image/M00/27/16/Ciqc1F70Sk6ANM__AAAQ-wQno2Q416.png" alt="image (33).png" data-nodeid="1058"><br>
栈溢出错误</p>
<p data-nodeid="956">所以我们在编写递归函数的时候一定要注意函数执行边界，也就是退出递归的条件。</p>
<h3 data-nodeid="957">延申：尾调用</h3>
<p data-nodeid="958">递归调用由于调用次数较多，同时每层函数调用都需要保存栈帧，所以通常是比较消耗内存的操作。对递归的优化一般有两个思路，<strong data-nodeid="1068">减少递归次数和使用尾调用</strong>。</p>
<p data-nodeid="959">尾调用（Tail Call）是指<strong data-nodeid="1074">函数的最后一步返回另一个函数的调用</strong>。例如下面的代码中，函数 a() 返回了函数 b() 的调用。</p>
<pre class="lang-javascript" data-nodeid="960"><code data-language="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params">x</span>)</span>&#123;
  <span class="hljs-keyword">return</span> b(x);
&#125;
</code></pre>
<p data-nodeid="961">像下面的示例中，返回缓存的函数调用结果，或者返回多个函数调用都不属于“尾调用”。</p>
<pre class="lang-javascript" data-nodeid="962"><code data-language="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params">x</span>)</span>&#123;
  <span class="hljs-keyword">let</span> c = b(x);
  <span class="hljs-keyword">return</span> c;
&#125;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params">x</span>)</span>&#123;
  <span class="hljs-keyword">return</span> b(x) + c(x);
&#125;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params"></span>) </span>&#123;
  b(x)
&#125;
</code></pre>
<p data-nodeid="963">尾调用由于是在 return 语句中，并且是函数的最后一步操作，所以局部变量等信息不需要再用到，从而可以立即释放节省内存空间。</p>
<p data-nodeid="964">下面的示例代码通过递归实现了求斐波那契额数列第 n 个数的功能。函数 fibTail() 相对于函数 fib() 就同时使用了尾调用以及减少调用次数两种优化方式。</p>
<pre class="lang-javascript" data-nodeid="965"><code data-language="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fib</span>(<span class="hljs-params">n</span>) </span>&#123;
&nbsp; <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>
&nbsp; <span class="hljs-keyword">return</span> fib(n<span class="hljs-number">-1</span>) + fib(n<span class="hljs-number">-2</span>)
&#125;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fibTail</span>(<span class="hljs-params">n, a = <span class="hljs-number">0</span>, b = <span class="hljs-number">1</span></span>) </span>&#123;
&nbsp; <span class="hljs-keyword">if</span> (n === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> a
&nbsp; <span class="hljs-keyword">return</span> fibTail(n - <span class="hljs-number">1</span>, b, a + b)
&#125;
</code></pre>
<p data-nodeid="966">但是由于尾调用也存在一些隐患，比如错误信息丢失、不方便调试，所以浏览器以及 Node.js 环境默认并没有支持这种优化方式。</p>
<h4 data-nodeid="967">堆</h4>
<p data-nodeid="968">堆空间存储的数据比较复杂，大致可以划分为下面 5 个区域：代码区（Code Space）、Map 区(Map Space)、大对象区（Large Object Space）、新生代（New Space）、老生代（Old Space）。这一课时重点讨论新生代和老生代的内存回收算法。</p>
<h4 data-nodeid="969">新生代</h4>
<p data-nodeid="970">大多数的对象最开始都会被分配在新生代，该存储空间相对较小，只有几十 MB，分为两个空间：from 空间和 to 空间。</p>
<p data-nodeid="971">程序中声明的对象首先会被分配到 from 空间，当进行垃圾回收时，会先将 from 空间中存活的的对象（存活对象可以理解为被引用的对象）复制到 to 空间进行保存，对未存活的对象空间进行回收。当复制完成后，from 空间和 to 空间进行调换，to 空间会变为新的 from 空间，原来的 from 空间则变为 to 空间，这种算法称之为 “Scavenge”。</p>
<p data-nodeid="1371">新生代的内存回收频率很高、速度也很快，但空间利用率较低，因为让一半的内存空间处于“闲置”状态。</p>
<p data-nodeid="2305" class="te-preview-highlight"><img src="https://s0.lgstatic.com/i/image6/M00/25/15/Cgp9HWBZVYuADfmqAACqB-v2Dq0515.png" alt="1.png" data-nodeid="2308"><br>
Scanvage 回收过程</p>







<h4 data-nodeid="974">老生代</h4>
<p data-nodeid="975">新生代中多次回收仍然存活的对象会被转移到空间较大的老生代。因为老生代空间较大，如果回收方式仍然采用 Scanvage 算法来频繁复制对象，那性能开销就太大了。</p>
<p data-nodeid="976">所以老生代采用的是另一种“<strong data-nodeid="1101">标记清除</strong>”（<strong data-nodeid="1102">Mark-Sweep</strong>）的方式来回收未存活的对象空间。</p>
<p data-nodeid="977">这种方式主要分为<strong data-nodeid="1112">标记</strong>和<strong data-nodeid="1113">清除</strong>两个阶段。标记阶段会遍历堆中所有对象，并对存活的对象进行标记；清除阶段则是对未标记对象的空间进行回收。</p>
<p data-nodeid="978"><img src="https://s0.lgstatic.com/i/image/M00/27/1E/Ciqc1F70ZZWAeo71AABOQKZ828k489.png" alt="5.png" data-nodeid="1116"><br>
标记清除回收过程</p>
<p data-nodeid="979">由于标记清除不会对内存一分为二，所以不会浪费空间。但是进行过标记清除之后的内存空间会产生很多不连续的碎片空间，这种不连续的碎片空间中，在遇到较大对象时可能会由于空间不足而导致无法存储的情况。</p>
<p data-nodeid="980">为了解决内存碎片的问题，提高对内存的利用，还需要使用到<strong data-nodeid="1125">标记整理（Mark-Compact）</strong> 算法。标记整理算法相对于标记清除算法在回收阶段进行了改进，标记整理对待未标记的对象并不是立即进行回收，而是将存活的对象移动到一边，然后再清理。当然这种移动对象的操作相对而言是比较耗时的，所以执行速度上，比标记清除要慢。</p>
<p data-nodeid="981"><img src="https://s0.lgstatic.com/i/image/M00/27/21/Ciqc1F70cS2AU5w_AABOiU6R39g235.png" alt="6.png" data-nodeid="1128"><br>
标记整理回收过程</p>
<h3 data-nodeid="982">总结</h3>
<p data-nodeid="983">本课时的内容偏于底层和抽象，重点在于理解和记忆。</p>
<p data-nodeid="984">首先讲解了 JavaScript 引擎的执行过程，包括解析、解释和优化，这一部分可以结合加餐 1 中提到的编译器知识进行理解。</p>
<p data-nodeid="985">然后讲到了 JavaScript 引擎的内存分为栈和堆两个部分，栈可以保存函数调用信息以及局部变量，特点是“先进后出”以及“用完立即销毁”。堆区存储的数据对象通常比较大，需要采用一定的回收算法来处理，包括用于新生代的 Scanvage 算法，以及用于老生代的标记清除和标记整理算法。</p>
<p data-nodeid="986" class="">最后布置一道思考题：你还了解过哪些内存回收算法，它们有什么优缺点？</p>

<hr>
<h3 id="精选评论"><a href="#精选评论" class="headerlink" title="精选评论"></a>精选评论</h3><h5 id="涛："><a href="#涛：" class="headerlink" title="**涛："></a>**涛：</h5><blockquote>
<p>感觉越往底层分析越明白算法的重要性</p>
</blockquote>
<h5 id="玲："><a href="#玲：" class="headerlink" title="**玲："></a>**玲：</h5><blockquote>
<p>老师讲得很好</p>
</blockquote>
<h5 id="童："><a href="#童：" class="headerlink" title="**童："></a>**童：</h5><blockquote>
<p>看完后不太懂，这到底是js的编译过程还是执行机制？解析的这一步是v8引擎做的是吗？v8引擎不是解释器吗，但是后面又有其他解释器…求解惑谢谢</p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-讲师回复："><a href="#amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; 以V8引擎为例讲解的 JavaScript 编译过程，V8可以编译和执行 JavaScript 代码。</p>
</blockquote>
<h5 id="ezra-xu："><a href="#ezra-xu：" class="headerlink" title="ezra.xu："></a>ezra.xu：</h5><blockquote>
<p>引用计数，标记清除，标记整理，分代回收…</p>
</blockquote>
<h5 id="超："><a href="#超：" class="headerlink" title="**超："></a>**超：</h5><blockquote>
<p>老师，关于获取摄像头以及麦克风，桌面这些是在哪个进程中实现的呢🙋</p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-1"><a href="#amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-1" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; 在启用摄像头&#x2F;麦克风的时候，浏览器会启动  Video Capture 进程。</p>
</blockquote>
<h5 id="随行："><a href="#随行：" class="headerlink" title="**随行："></a>**随行：</h5><blockquote>
<p>所以v8的垃圾回收方式跟Java中的是一样的么？</p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-2"><a href="#amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-2" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; 大体上是相同的</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/11/02/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C-JavaScript-%E4%BB%A3%E7%A0%81%EF%BC%9F/" data-id="claxeera7001iv8w106km1vne" data-title="浏览器如何执行 JavaScript 代码？" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-区分浏览器中的进程与线程" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/11/02/%E5%8C%BA%E5%88%86%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/" class="article-date">
  <time class="dt-published" datetime="2022-11-02T02:51:57.000Z" itemprop="datePublished">2022-11-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/11/02/%E5%8C%BA%E5%88%86%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/">区分浏览器中的进程与线程</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p data-nodeid="267459">浏览器作为前端代码运行的环境，也作为前端工程师的底层知识，熟悉它的结构及工作方式，无论是对于开发高性能 Web 应用，还是对于建立完善的前端知识框架，都起着至关重要的作用。这一课时我们就通过学习浏览器中的进程和线程来掌握它的整体架构。</p>
<h3 data-nodeid="267460">进程（Process）与线程（Thread）</h3>
<p data-nodeid="268688">我们先来好好梳理一下关于进程和线程的相关概念。<strong data-nodeid="268707">进程</strong>是操作系统进行<strong data-nodeid="268708">资源分配</strong>和调度的基本单位，<strong data-nodeid="268709">线程</strong>是操作系统<strong data-nodeid="268710">进行运算</strong>的最小单位。一个程序至少有一个进程，一个进程至少有一个线程。线程需要由进程来启动和管理。</p>
<p data-nodeid="270528"><img src="https://s0.lgstatic.com/i/image/M00/29/11/CgqCHl75yNOASzO5AABzFfz1nN0731.png" alt="image (7).png" data-nodeid="270536"><br>
　　Windows 下的进程信息</p>
<p data-nodeid="270529" class=""><img src="https://s0.lgstatic.com/i/image/M00/29/06/Ciqc1F75yOeAKk_WAABFeE0vWT8953.png" alt="image (8).png" data-nodeid="270545"><br>
　　Linux 下的进程信息</p>












<p data-nodeid="267466">通常程序需要执行多个任务，比如浏览器需要一边渲染页面一边请求后端数据同时还要响应用户事件，而单线程的进程在同一时间内只能执行一个任务，无法满足多个任务并行执行的需求。要解决这个问题，可以通过 3 种方式来实现：</p>
<ul data-nodeid="267467">
<li data-nodeid="267468">
<p data-nodeid="267469">多进程</p>
</li>
<li data-nodeid="267470">
<p data-nodeid="267471">多线程（同一进程）</p>
</li>
<li data-nodeid="267472">
<p data-nodeid="267473">多进程和多线程</p>
</li>
</ul>
<p data-nodeid="267474">由于第 3 种方式是前两种方式的结合，所以这里只比较多进程和多线程的特点。</p>
<p data-nodeid="267475">前面提到进程是操作系统资源分配的基本单位，这里隐含的意思就是，不同进程之间的资源是独享的，不可以相互访问。这种特性带来的最大好处就是建立了进程之间的隔离性，避免了多个进程同时操作同一份数据而产生问题。</p>
<p data-nodeid="267476">而多线程没有分配独立的资源，线程之间数据都是共享的，也就意味着创建线程的成本更小，因为不需要分配额外的存储空间。但线程的数据共享也带来了很多问题：首先是稳定性，进程中任意线程崩溃都会导致整个进程的崩溃，也就是说会“牵连”到进程中的其他线程。安全隐患就更容易理解了，如果有恶意线程启动，可以随意访问进程中的任意资源。</p>
<p data-nodeid="267477">总而言之，<strong data-nodeid="267571">多线程更轻量，多进程更安全更稳定</strong>。</p>
<p data-nodeid="267478">有了关于进程和线程的了解，下面以使用率最高的 Chrome 浏览器为例来进行分析，看看浏览器中用到了哪些进程和线程。</p>
<h3 data-nodeid="267479">浏览器架构</h3>
<p data-nodeid="271644">通过浏览器的任务管理器（快捷键 Shift + ESC）可以看到，当浏览器打开一个标签页时，启动了下面几个进程。</p>
<p data-nodeid="271645" class=""><img src="https://s0.lgstatic.com/i/image/M00/29/06/Ciqc1F75yPWAcTNpAABoToqDfx4887.png" alt="image (9).png" data-nodeid="271653"><br>
　　浏览器进程启动图</p>






<h4 data-nodeid="276327" class="">浏览器进程</h4>



<p data-nodeid="267484">浏览器的主进程负责界⾯显⽰（地址栏、导航栏、书签等）、处理用户事件、管理⼦进程等。</p>
<h4 data-nodeid="277868" class="">GPU 进程</h4>



<p data-nodeid="267486">处理来自其他进程的 GPU 任务，比如来自渲染进程或扩展程序进程的 CSS3 动画效果，来自浏览器进程的界面绘制等。</p>
<p data-nodeid="267487">在第 06 课时中提到过浏览器渲染页面的过程，在最后一个步骤“绘制”中我们提到了图层的合成，而这个图层的合成操作其实就是交给 GPU 进程来完成的。</p>
<p data-nodeid="267488">它还有一个重要的特性，那就是可以利用 GPU 硬件来加速渲染，包括 Canvas 绘制、CSS3 转换（Transitions）、CSS3 变换（Transforms）、WebGL 等。具体原理就是如果 DOM 元素使用了这些属性，GPU 进程就会在合成层的时候对它进行单独处理，提升到一个独立的层进行绘制，这样就能避免重新布局和重新绘制。</p>
<p data-nodeid="267489">下面一段代码利用了 keyframes 来实现一个绕正方形运动的动画效果。</p>
<pre class="lang-xml" data-nodeid="267490"><code data-language="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&nbsp;<span class="hljs-attr">class</span>=<span class="hljs-string">"gpu"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">
&nbsp;&nbsp;<span class="hljs-selector-class">.gpu</span>&nbsp;&#123;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attribute">background-color</span>:&nbsp;darkgreen;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attribute">width</span>:&nbsp;<span class="hljs-number">50px</span>;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attribute">height</span>:&nbsp;<span class="hljs-number">50px</span>;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attribute">transform</span>:&nbsp;<span class="hljs-built_in">translate</span>(<span class="hljs-number">0</span>,&nbsp;<span class="hljs-number">0</span>);
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attribute">animation</span>:&nbsp;slide&nbsp;<span class="hljs-number">3.7s</span>&nbsp;ease-in-out&nbsp;infinite;
&nbsp;&nbsp;&#125;
&nbsp;&nbsp;<span class="hljs-keyword">@keyframes</span>&nbsp;slide&nbsp;&#123;
&nbsp;&nbsp;&nbsp;&nbsp;25%&nbsp;&#123;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attribute">transform</span>:&nbsp;<span class="hljs-built_in">translate</span>(<span class="hljs-number">250px</span>,&nbsp;<span class="hljs-number">0</span>);
&nbsp;&nbsp;&nbsp;&nbsp;&#125;
&nbsp;&nbsp;&nbsp;&nbsp;50%&nbsp;&#123;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attribute">transform</span>:&nbsp;<span class="hljs-built_in">translate</span>(<span class="hljs-number">250px</span>,&nbsp;<span class="hljs-number">250px</span>);
&nbsp;&nbsp;&nbsp;&nbsp;&#125;
&nbsp;&nbsp;&nbsp;&nbsp;75%&nbsp;&#123;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attribute">transform</span>:&nbsp;<span class="hljs-built_in">translate</span>(<span class="hljs-number">0</span>,&nbsp;<span class="hljs-number">250px</span>);
&nbsp;&nbsp;&nbsp;&nbsp;&#125;
&nbsp;&nbsp;&#125;
</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
</code></pre>
<p data-nodeid="272398">通过浏览器性能分析工具来记录整个页面绘制过程，可以看到页面绘制完成后，浏览器没有再进行布局或绘制相关的操作。因此此时元素的绘制工作已经脱离了渲染引擎，交由 GPU 进程来维护。</p>
<p data-nodeid="273184" class=""><img src="https://s0.lgstatic.com/i/image/M00/29/12/CgqCHl75yP6AZbcnAABVpE0iXCY958.png" alt="image (10).png" data-nodeid="273191"><br>
　　使用 GPU 加速进行渲染图</p>






<p data-nodeid="267494">为了进行对比，我们再将代码稍稍修改，通过固定定位来修改元素位置。</p>
<pre class="lang-xml" data-nodeid="267495"><code data-language="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&nbsp;<span class="hljs-attr">class</span>=<span class="hljs-string">"cpu"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">
&nbsp;&nbsp;<span class="hljs-selector-class">.cpu</span>&nbsp;&#123;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attribute">background-color</span>:&nbsp;darkgreen;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attribute">width</span>:&nbsp;<span class="hljs-number">50px</span>;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attribute">height</span>:&nbsp;<span class="hljs-number">50px</span>;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attribute">left</span>:&nbsp;<span class="hljs-number">0</span>;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attribute">top</span>:&nbsp;<span class="hljs-number">0</span>;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attribute">position</span>:&nbsp;fixed;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attribute">animation</span>:&nbsp;move&nbsp;<span class="hljs-number">3.7s</span>&nbsp;ease-in-out&nbsp;infinite;
&nbsp;&nbsp;&#125;
&nbsp;&nbsp;<span class="hljs-keyword">@keyframes</span>&nbsp;move&nbsp;&#123;
&nbsp;&nbsp;&nbsp;&nbsp;25%&nbsp;&#123;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attribute">left</span>:&nbsp;<span class="hljs-number">250px</span>;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attribute">top</span>:&nbsp;<span class="hljs-number">0</span>;
&nbsp;&nbsp;&nbsp;&nbsp;&#125;
&nbsp;&nbsp;&nbsp;&nbsp;50%&nbsp;&#123;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attribute">left</span>:&nbsp;<span class="hljs-number">250px</span>;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attribute">top</span>:&nbsp;<span class="hljs-number">250px</span>;
&nbsp;&nbsp;&nbsp;&nbsp;&#125;
&nbsp;&nbsp;&nbsp;&nbsp;75%&nbsp;&#123;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attribute">left</span>:&nbsp;<span class="hljs-number">0</span>;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attribute">top</span>:&nbsp;<span class="hljs-number">250px</span>;
&nbsp;&nbsp;&nbsp;&nbsp;&#125;
&nbsp;&nbsp;&#125;
</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
</code></pre>
<p data-nodeid="273952">发现页面在循环进行布局和绘制操作。</p>
<p data-nodeid="274754" class=""><img src="https://s0.lgstatic.com/i/image/M00/29/06/Ciqc1F75yQmAeLhpAABTOiBQjDo080.png" alt="image (11).png" data-nodeid="274761"><br>
　　不使用 GPU 加速进行渲染图</p>






<p data-nodeid="267499"><strong data-nodeid="267606">Network Service 进程</strong></p>
<p data-nodeid="267500">负责⻚⾯的⽹络资源加载，比如在地址栏输入一个网页地址，网络进程会将请求后得到的资源交给渲染进程处理。本来只是浏览器主进程的一个模块，现在为了将浏览器进程进行“服务化”，被抽取出来，成了一个单独的进程。</p>
<h4 data-nodeid="267501"><strong data-nodeid="267611">V8 代理解析工具进程</strong></h4>
<p data-nodeid="267502">Chrome 支持使用 JavaScript 来写连接代理服务器脚本，称为 pac 代理脚本。</p>
<p data-nodeid="267503">由于 pac 代理脚本是用 JavaScript 编写的，要能够解析 pac 代理脚本就必须要用到 JavaScript 脚本引擎，直接在浏览器主进程中引入 JavaScript 引擎并不符合进程“服务化”的设计理念，所以就把这个解析功能独立成一个进程。</p>
<h4 data-nodeid="267504">渲染进程</h4>
<p data-nodeid="267505">浏览器会为每个标签页单独启动一个渲染进程，所以它和上述进程不同，并不是唯一的。</p>
<p data-nodeid="267506">渲染进程的任务是将 HTML、CSS 和 JavaScript 转化为⽤户可以与之交互的网页，每个渲染进程都会启动单独的渲染引擎线程和 JavaScript 引擎线程。关于渲染引擎的工作细节我们在第 06 课时中已经详细讨论过了，JavaScript 引擎线程也在第 12 课时中详细讨论过，这里就不重复讨论了。</p>
<p data-nodeid="267507">除此之外还包括事件触发线程，负责接收事件，并将回调函数放入 JavaScript 引擎线程的事件队列中，以及负责处理定时任务的定时器线程。</p>
<p data-nodeid="267508">这种设计保障了程序与系统的安全性，可以通过操作系统提供的权限机制来为每个渲染进程建立一个沙箱运行环境，从而防止恶意破坏用户系统或影响其他标签页的行为。</p>
<p data-nodeid="267509">同时也保障了渲染进程的稳定性，因为如果某个标签页失去响应，用户可以关掉这个标签页，此时其他标签页依然运行着，可以正常使用。如果所有标签页都运行在同一进程上，那么当某个失去响应，所有标签页都会失去响应。</p>
<h4 data-nodeid="267510">扩展程序进程</h4>
<p data-nodeid="267511">主要是负责插件的运⾏，和渲染进程一样，也不是唯一的，浏览器会为每个插件都启动一个进程。这样的设计也是从安全性和稳定性考虑。</p>
<h4 data-nodeid="267512">进程的服务化</h4>
<p data-nodeid="267513">Chrome 官方团队在 2016年 提出了<a target="_blank" rel="noopener" href="https://docs.google.com/document/d/15I7sQyQo6zsqXVNAlVd520tdGaS8FCicZHrN0yRu-oU/edit#heading=h.cyhu8vkfrzar" data-nodeid="267626">面向服务的设计模型</a>，在系统资源允许的情况下，将浏览器主进程的各种模块拆分成独⽴的服务，每个服务在独立的进程中运行。通过高内聚、低耦合的结构让 Chrome 变得更稳定更安全。</p>
<p data-nodeid="267514">同时这种设计也具有一定的伸缩性，当运行在资源有限的设备上时，会将这些服务聚合到浏览器主进程中，从而减少内存占用。</p>
<h3 data-nodeid="267515">总结</h3>
<p data-nodeid="267516">这一课时我们分析了 Chrome 浏览器的架构，至少可以得到以下 3 个启示：</p>
<ul data-nodeid="267517">
<li data-nodeid="267518">
<p data-nodeid="267519">多进程在稳定性和安全性上有优势，但是资源占用较多；</p>
</li>
<li data-nodeid="267520">
<p data-nodeid="267521">对于复杂的应用我们可以采取服务化的设计方式，将功能模块单独拆分成进程来提供服务；</p>
</li>
<li data-nodeid="267522">
<p data-nodeid="267523">合理利用 GPU 进程可以加速渲染。</p>
</li>
</ul>
<p data-nodeid="278248">最后布置一道思考题：说一说你还了解过哪些多进程与多线程设计的应用，它们的结构又是什么样的呢？</p>

<hr>
<h3 id="精选评论"><a href="#精选评论" class="headerlink" title="精选评论"></a>精选评论</h3><h5 id="强："><a href="#强：" class="headerlink" title="*强："></a>*强：</h5><blockquote>
<p>我们打开windows自带任务管理器也可以看到相关的进程，除去浏览器进程、GPU进程、network service 进程、 v8解析代理工具进程等，再有就是拓展程序进程了，但如图所示，windows任务管理器列出了8个浏览器相关的进程，但是在浏览器自带任务管理器中可以看到，其实并不只8个，但是将拓展程序进程统计为1个的话，数量上就能对上了。<img src="https://i.loli.net/2020/12/12/P6LgFznjThJWrba.png">那么浏览器中每个拓展程序是个单独的进程吗，还是一个进程中的多个线程呢</p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-讲师回复："><a href="#amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; 课程中已经提到过，各个插件都是单独的进程，可以从浏览器的任务管理器中看到它们有不同的进程ID，也可以使用命令行程序进程查看，比如 Mac 下 ps -ef|grep 扩展程序进程号</p>
</blockquote>
<h5 id="鹏："><a href="#鹏：" class="headerlink" title="*鹏："></a>*鹏：</h5><blockquote>
<p>Chromium 提供了四种进程模式，他们影响了浏览器分配页面给渲染进程的行为，比如采用某个模式况会给 tab 分配新进程，而采用另外一个模式则不会，下面是四种模式的介绍，Chrome 默认采用第一个模式。Process-per-site-instance (default)同一个 site-instance 使用一个进程Process-per-site同一个 site 使用一个进程Process-per-tab每个 tab 使用一个进程Single process所有 tab 共用一个进程</p>
</blockquote>
<h5 id="杰："><a href="#杰：" class="headerlink" title="*杰："></a>*杰：</h5><blockquote>
<p>chrome中遇到过一个问题，访问一个网站打开多个标签页，但是只要其中一个标签页失去响应，其他同站的标签页也失去响应，这是否意味着同一个网站只用了一个渲染进程？</p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-1"><a href="#amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-1" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; 很可能是的，可以通过浏览器的任务管理器进行查看。<br>Chrome 浏览器中，通过a标签或者 window.open() 函数来打开同一个根主机名下的网站（ 比如在 <a target="_blank" rel="noopener" href="https://kaiwu.lagou.com/">https://kaiwu.lagou.com</a> 中打开 <a target="_blank" rel="noopener" href="https://lagou.com),不会创建渲染进程而是用的多线程/">https://lagou.com），不会创建渲染进程而是用的多线程</a></p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/11/02/%E5%8C%BA%E5%88%86%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/" data-id="claxeer9w000tv8w1gt485r6a" data-title="区分浏览器中的进程与线程" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/3/">&laquo; 上一页</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/5/">下一页 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/11/">十一月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">十月 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/11/26/%E4%B8%BA%E4%BB%80%E4%B9%88React16%E8%A6%81%E6%9B%B4%E6%94%B9%E7%BB%84%E4%BB%B6%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-%EF%BC%88%E4%B8%8B%EF%BC%89/">为什么React16要更改组件的生命周期?（下）</a>
          </li>
        
          <li>
            <a href="/2022/11/26/%E8%A6%81%E6%9B%B4%E6%94%B9%E7%BB%84%E4%BB%B6%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%9F%EF%BC%88%E4%B8%8A%EF%BC%89/">(no title)</a>
          </li>
        
          <li>
            <a href="/2022/11/26/%E4%BB%A3%E7%A0%81%E8%BD%ACdom/">代码转dom</a>
          </li>
        
          <li>
            <a href="/2022/11/26/React%E7%9F%A5%E8%AF%86%E9%93%BE/">React知识链</a>
          </li>
        
          <li>
            <a href="/2022/11/02/%E6%8E%92%E5%BA%8F%E2%80%9C/">排序“</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 XuJiaDi<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>