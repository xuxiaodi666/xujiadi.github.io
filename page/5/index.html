<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>徐嘉迪的个人网站</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="没有永远的失败者，只有努力的成功者">
<meta property="og:type" content="website">
<meta property="og:title" content="徐嘉迪的个人网站">
<meta property="og:url" content="http://example.com/page/5/index.html">
<meta property="og:site_name" content="徐嘉迪的个人网站">
<meta property="og:description" content="没有永远的失败者，只有努力的成功者">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="XuJiaDi">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="徐嘉迪的个人网站" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">徐嘉迪的个人网站</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">没有永远的失败者，只有努力的成功者</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS 订阅"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-如何合理搭建前端项目？" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/11/02/%E5%A6%82%E4%BD%95%E5%90%88%E7%90%86%E6%90%AD%E5%BB%BA%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%EF%BC%9F/" class="article-date">
  <time class="dt-published" datetime="2022-11-02T02:51:13.000Z" itemprop="datePublished">2022-11-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/11/02/%E5%A6%82%E4%BD%95%E5%90%88%E7%90%86%E6%90%AD%E5%BB%BA%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%EF%BC%9F/">如何合理搭建前端项目？</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p data-nodeid="114953">通过上一课时的学习，我们分析了前端构建工具 webpack 的底层原理，在理解原理之后再来探索构建工具的具体应用——如何合理搭建前端项目。当然，前端项目搭建并不只是使用构建工具这么简单，本课时我们将从项目组织、代码规范 2 个方面来进行分析。</p>
<h3 data-nodeid="114954">项目组织</h3>
<p data-nodeid="114955">考虑这样一个场景，在开发项目 projectA 的时候，发现其中的 codeX 也可以用于项目 projectB，最简单直接的处理方式就是把 codeX 的代码直接复制到 projectB 下，按照“三次原则”（三次原则是指同一段代码被使用到 3 次时再考虑抽象）这种处理方式没什么问题。但如果此时项目 projectC 和 projectD 也会用到 codeX，那么这种方式维护起来会很麻烦。</p>
<p data-nodeid="114956">有经验的工程师会想到将 codeX 发布成模块，作为依赖模块引入所需的项目中。此时对于 codeX 会涉及两种组织代码的方式：<strong data-nodeid="115034">multirepo</strong> 和 <strong data-nodeid="115035">monorepo</strong>。</p>
<h4 data-nodeid="114957">multirepo</h4>
<p data-nodeid="117062" class="">multirepo 就是将项目中的模块拆分出来，放在不同的仓库中进行独立管理。例如，用于 Node.js 的 Web 框架 <a target="_blank" rel="noopener" href="https://github.com/koajs/koa" data-nodeid="117066">Koa</a>，它依赖的模块 <a target="_blank" rel="noopener" href="https://github.com/koajs/convert" data-nodeid="117070">koa-convert</a> 和 <a target="_blank" rel="noopener" href="https://github.com/koajs/compose" data-nodeid="117074">koa-compose</a> 分别拆分成了两个仓库进行管理。</p>



<p data-nodeid="114959">这种方式的好处是保证仓库的独立性，方便不同团队维护对应的仓库代码，可以根据团队情况选择擅长的工具、工作流等。</p>
<p data-nodeid="114960">但这种方式也会存在一些问题，具体如下。</p>
<ul data-nodeid="114961">
<li data-nodeid="114962">
<p data-nodeid="114963"><strong data-nodeid="115056">开发调试及版本更新效率低下</strong>。比如在仓库 A 用到的仓库 B 中发现了一个 bug，就必须到仓库 B 里修复它、打包、发版本，然后再回到仓库 A 继续工作。在不同的仓库间，你不仅需要处理不同的代码、工具，甚至是不同的工作流程；还有，你只能去问维护这个仓库的人，能不能为你做出改变，然后等着他们去解决。</p>
</li>
<li data-nodeid="114964">
<p data-nodeid="114965"><strong data-nodeid="115061">团队技术选型分散</strong>。不同的库实现风格可能存在较大差异（比如有的库依赖 Vue，有的依赖 React），还有可能会采用不同的测试库及校验规则，维护起来比较困难。</p>
</li>
</ul>
<p data-nodeid="114966">而 monorepo 方式恰好就能解决这些问题。</p>
<h4 data-nodeid="114967">monorepo</h4>
<p data-nodeid="114968">monorepo 就是将所有相关的模块放在同一个项目仓库中。这种方式在管理上会更加方便，项目所有代码可以使用统一的规范及构建、测试、发布流程。</p>
<p data-nodeid="117818">很多著名的开源项目都采取了这种管理方式，比如开源项目 babel，它依赖的模块都放在了 packages 目录下。</p>
<p data-nodeid="118212"><img src="https://s0.lgstatic.com/i/image/M00/40/59/CgqCHl8yWpuAcwJgAAAqnGP7ZbA995.png" alt="image (9).png" data-nodeid="118220"></p>
<div data-nodeid="119359" class=""><p style="text-align:center">babel 的依赖模块</p> </div>





<p data-nodeid="114972">通过查看 babel 项目，发现根目录下有一个  lerna.json  的配置文件，这是开源工具 <a target="_blank" rel="noopener" href="https://github.com/lerna/lerna" data-nodeid="115073">lerna</a>的配置文件。lerna 是一个用于管理带有多个包的 JavaScript 项目工具，用 lerna 管理的项目会有 3 个文件目录：packages 目录、learna.json 文件和 package.json 文件。通过 lerna 命令行工具在初始化项目的时候就可以创建它们。</p>
<p data-nodeid="114973">lerna 支持两种模式，分别是 Fixed/Locked 和 Independent&nbsp;模式。</p>
<p data-nodeid="114974">Fixed/Locked 模式为默认模式，babel 采用的就是这种模式，该模式的特点是，开发者执行 lerna publish 后，lerna 会在 lerna.json 中找到指定 version 版本号。如果这一次发布包含某个项目的更新，那么会自动更新 version 版本号。对于各个项目相关联的场景，这样的模式非常有利，任何一个项目大版本升级，其他项目的大版本号也会更新。</p>
<p data-nodeid="114975">Independent&nbsp;模式顾名思义，各个项目都是相互独立。开发者需要独立管理多个包的版本更新。也就是说，我们可以具体到更新每个包的版本。每次发布，lerna 会配合 Git，检查相关包文件的变动，只发布有改动的 package。</p>
<p data-nodeid="114976">虽然众多开源项目采用了 monorepo，但它也并不是最完美的代码组织方式，也会带来一些问题，比如由于将多个模块集中在一个仓库中会导致仓库体积变大，目录结构也会变得更复杂。而 monorepo 也需要额外的工具来管理各个模块，这意味着相对 multirepo 而言会有一定的学习成本。</p>
<h3 data-nodeid="114977">代码规范</h3>
<p data-nodeid="114978">什么样的代码才是好代码？不同的工程师可能给出不同的答案，比如：</p>
<ul data-nodeid="114979">
<li data-nodeid="114980">
<p data-nodeid="114981">少用全局变量</p>
</li>
<li data-nodeid="114982">
<p data-nodeid="114983">高内聚、低耦合</p>
</li>
<li data-nodeid="114984">
<p data-nodeid="114985">遵循单一原则</p>
</li>
<li data-nodeid="114986">
<p data-nodeid="114987">拥有注释说明</p>
</li>
</ul>
<p data-nodeid="114988">切换角度思考会帮助我们得到更全面的答案：从人的角度考虑，维护代码的开发者会不断地变更；从时间的角度考虑，代码会不断地被修改。我们可以总结一个最简单实用的答案：风格一致。 “风格一致”就是让参与项目开发的工程师形成一种开发上的契约，从而降低维护成本。要达到这个目的，我们可以从代码编写和代码管理两个方向入手，分别对应编写规范和提交规范。</p>
<h4 data-nodeid="114989">编写规范</h4>
<p data-nodeid="114990">网上关于 HTML、JavaScript、CSS 编写规范（也称编写风格）之类的文档资料很多，一般大型互联网公司都会制定自己的编写规范，比如 <a target="_blank" rel="noopener" href="https://google.github.io/styleguide/jsguide.html" data-nodeid="115090">Google 的 JavaScript 风格指南</a>、 <a target="_blank" rel="noopener" href="https://github.com/airbnb/javascript" data-nodeid="115094">Airbnb 风格指南</a>，而对应的工具也不少。以 JavaScript 为例，比如 JSLint、JSHint、JSCS、ESLint 等多种规则校验工具。</p>
<p data-nodeid="114991">不管我们在团队中制定怎样的编写规范，只要把握好下面 3 个核心原则，就能制定出合理的编写规范。</p>
<ul data-nodeid="114992">
<li data-nodeid="114993">
<p data-nodeid="114994"><strong data-nodeid="115101">可执行</strong>。制定编写规范首先要保证的就是规范的可执行性。制定好规范如果只能靠工程师的自觉性去执行，靠代码审核去检查，那么执行效率会很低。所以建议编写规范中的每一条规则都能有对应的校验工具规则与之对应。</p>
</li>
<li data-nodeid="114995">
<p data-nodeid="114996"><strong data-nodeid="115106">可配置</strong>。代码的可读性有时候是一个比较主观的问题，比如空格缩进问题，有的工程师认为 2 个空格缩进可以查看更多代码内容，而有的会认为 4 个空格缩进层次感更强。使用具有丰富配置项的代码校验工具就可以很轻松地解决这些分歧。</p>
</li>
<li data-nodeid="114997">
<p data-nodeid="114998"><strong data-nodeid="115111">可扩展</strong>。这一点也是对于校验工具的要求，即当校验工具的已有配置规则无法支持项目需求时，可以自行编写插件来扩展校验规则。</p>
</li>
</ul>
<p data-nodeid="114999">最常用的 ESlint 就可以满足可配置、可扩展的原则，它的核心功能是通过一个叫 verify() 的函数来实现的，该函数有两个必传参数：要验证的源码文本和一个配置对象（通过准备好的配置文件加命令行操作会生成配置）。该函数首先使用解析器生成抽象语法树（AST），同时为规则中所有的选择器添加监听事件，在触发时执行；然后从上到下遍历 AST。在每个节点触发与该节点类型同名的一个事件（即 “Identifier”“WithStatement” 等），监听函数校验完相关的代码之后把不符合规则的问题推送到 lintingProblems 数组中返回。</p>
<h4 data-nodeid="115000">提交规范</h4>
<p data-nodeid="120109">虽然在开发过程中，每次在使用 Git 提交代码时都会编写提交消息（Commit Message），但提交规范仍然是一个很容易被忽视的点。而良好的提交规范和编写规范一样，也能较大地提升代码的可维护性，一方面能保证在代码回退时能快速找到对应的提交记录，另一方面也可以直接将提交消息生成修改日志（Change Log）。</p>
<p data-nodeid="120110" class=""><img src="https://s0.lgstatic.com/i/image/M00/40/59/CgqCHl8yWsqAN-CGAAHUx-NKShw605.png" alt="image (10).png" data-nodeid="120119"></p>
<div data-nodeid="120111"><p style="text-align:center">Angular 的提交日志</p> </div>





<p data-nodeid="120506" class="">虽然 Git 自带 template 功能，这个功能可以定义一个提交消息的模板文件，然后通过 git config 命令指向这个模板文件。这样在每次提交的时候就会使用默认的编辑器打开一个模板文件，编辑对应信息后保存即可。但不具有强制性，推荐使用工具 <a target="_blank" rel="noopener" href="https://commitlint.js.org/#/" data-nodeid="120510">@commitlint/cli</a> 和 <a target="_blank" rel="noopener" href="https://www.npmjs.com/package/husky" data-nodeid="120514">husky</a>。commitlint 可以设置提交消息模板并校验，而 husky 可以设置 pre-commit 钩子，在提交代码时调用 commitlint 进行强制校验，避免生成不符合规范的提交消息。</p>
<p data-nodeid="115005">下面的 husky 配置文件会在提交之前执行命令 npm test，在生成提交消息时执行 commitlint。</p>
<pre class="lang-json" data-nodeid="115006"><code data-language="json"><span class="hljs-comment">// .huskyrc </span>
&#123; 
<span class="hljs-attr">"hooks"</span>:&nbsp;&#123; 
<span class="hljs-attr">"pre-commit"</span>:&nbsp;<span class="hljs-string">"npm&nbsp;test"</span>, 
<span class="hljs-attr">"commit-msg"</span>:&nbsp;<span class="hljs-string">"commitlint"</span> 
&#125; 
&#125; 
</code></pre>
<p data-nodeid="115007">从上面的例子可以看到，husky 同构监听 git 钩子，不仅可以校验提交消息，还可以调用自定义的 npm 脚本进行代码校验或执行测试代码。随着项目不断增大，对整个项目上运行 lint 或 test 会变得非常耗时，我们一般只想对更改的文件进行检查，这时候可以借助 <a target="_blank" rel="noopener" href="https://www.npmjs.com/package/lint-staged" data-nodeid="115132">lint-staged</a>。</p>
<p data-nodeid="115008">下面是 Vue 的 lint-staged 相关配置。它表示对于 js 后缀的文件执行 eslint --fix 命令来校验和修复代码 ，通过之后再进行 git add 添加到暂存区。</p>
<pre class="lang-java" data-nodeid="122063"><code data-language="java"><span class="hljs-comment">// package.json </span>
&#123; 
... 
<span class="hljs-string">"lint-staged"</span>: &#123; 
<span class="hljs-string">"*.js"</span>: [ 
<span class="hljs-string">"eslint --fix"</span>, 
<span class="hljs-string">"git add"</span> 
] 
&#125;, 
... 
&#125; 
</code></pre>




<h3 data-nodeid="115010">总结</h3>
<p data-nodeid="115011">这一课时站在前端工程的角度，从项目组织和代码规范两个方面分析了如何搭建可维护性的前端项目。</p>
<ul data-nodeid="115012">
<li data-nodeid="115013">
<p data-nodeid="115014">在项目组织上，对于相关性低的模块可以采用 multirepo 方式进行独立管理，相关度高的模块则可以采用 monorepo 方式对其进行集中管理。</p>
</li>
<li data-nodeid="115015">
<p data-nodeid="115016">在制定代码规范时，对于编写规范，尽量做到可执行、可配置、可扩展，对于提交规范，可以选择适当的工具，比如 commitlint、husky 来保证提交消息的规范化和可读性。</p>
</li>
</ul>
<p data-nodeid="115017">希望你通过本课时的内容，能对前端项目搭建有更深入的理解和思考，不只是停留在会用命令行工具或脚手架来创建项目的层次。而是在空间维度和时间维度上来考虑如何组织项目代码和规范项目代码。</p>
<p data-nodeid="115018">最后布置一道思考题：你在开发中还用到了哪些代码校验工具，它们都有什么特点？欢迎你在留言区一起分享交流。</p>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/11/02/%E5%A6%82%E4%BD%95%E5%90%88%E7%90%86%E6%90%AD%E5%BB%BA%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%EF%BC%9F/" data-id="claxeera0000zv8w19dsdcqii" data-title="如何合理搭建前端项目？" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-框架到底用了哪些设计模式？" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/11/02/%E6%A1%86%E6%9E%B6%E5%88%B0%E5%BA%95%E7%94%A8%E4%BA%86%E5%93%AA%E4%BA%9B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9F/" class="article-date">
  <time class="dt-published" datetime="2022-11-02T02:50:29.000Z" itemprop="datePublished">2022-11-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/11/02/%E6%A1%86%E6%9E%B6%E5%88%B0%E5%BA%95%E7%94%A8%E4%BA%86%E5%93%AA%E4%BA%9B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9F/">框架到底用了哪些设计模式？</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p data-nodeid="102221">这一讲我们继续来讲一个重要的抽象知识——设计模式，先来看看维基百科对设计模式的定义：</p>
<blockquote data-nodeid="102222">
<p data-nodeid="102223">设计模式（Design Pattern）是对软件设计中普遍存在（反复出现）的各种问题所提出的解决方案。设计模式并不直接用来完成代码的编写，而是描述在各种不同情况下，要怎么解决问题的一种方案。</p>
</blockquote>
<p data-nodeid="102224">从这个定义不难看出，设计模式就是一套抽象的理论，属于编程知识中的“道”而非“术”，对于理论的学习我们最好的学习方式就是通过与实践结合来加深理解，所以接下来我们在分析设计模式相关概念的同时通过具体实例来加深对其理解。</p>
<h3 data-nodeid="102225">设计模式原则</h3>
<p data-nodeid="102226">设计模式其实是针对面向对象编程范式总结出来的解决方案，所以设计模式的原则都是围绕“类”和“接口”这两个概念来提出的，其中下面 6 个原则非常重要，因为这 6 个原则决定了设计模式的规范和标准。</p>
<h4 data-nodeid="102227">开闭原则</h4>
<p data-nodeid="102228">开闭原则指的就是对扩展开放、对修改关闭。编写代码的时候不可避免地会碰到修改的情况，而遵循开闭原则就意味着当代码需要修改时，可以通过编写新的代码来扩展已有的代码，而不是直接修改已有代码本身。</p>
<p data-nodeid="102229">下面的伪代码是一个常见的表单校验功能，校验内容包括<strong data-nodeid="102362">用户名</strong>、<strong data-nodeid="102363">密码</strong>、<strong data-nodeid="102364">验证码</strong>，每个校验项都通过判断语句 if-else 来控制。</p>
<pre class="lang-typescript" data-nodeid="102230"><code data-language="typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">validate</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-comment">// 校验用户名</span>
&nbsp; &nbsp; <span class="hljs-keyword">if</span> (!username) &#123;
&nbsp; &nbsp; &nbsp; &nbsp; ...
&nbsp; &nbsp; &#125; <span class="hljs-keyword">else</span> &#123;
&nbsp; &nbsp; &nbsp; &nbsp; ...
&nbsp; &nbsp; &#125;
    <span class="hljs-comment">// 校验密码</span>
&nbsp; &nbsp; <span class="hljs-keyword">if</span> (!pswd)&#123;
&nbsp; &nbsp; &nbsp; &nbsp; ...
&nbsp; &nbsp; &#125; <span class="hljs-keyword">else</span> &#123;
&nbsp; &nbsp; &nbsp; &nbsp; ...
&nbsp; &nbsp; &#125;
    <span class="hljs-comment">// 校验验证码</span>
&nbsp; &nbsp; <span class="hljs-keyword">if</span> (!captcha) &#123;
&nbsp; &nbsp; &nbsp; &nbsp; ...
&nbsp; &nbsp; &#125; <span class="hljs-keyword">else</span> &#123;
&nbsp; &nbsp; &nbsp; &nbsp; ...
&nbsp; &nbsp; &#125;
&#125;
</code></pre>
<p data-nodeid="102231">这么写看似没有问题，但其实可扩展性并不好，如果此时增加一个校验条件，就要修改 validate()  函数内容。</p>
<p data-nodeid="102232">下面的伪代码遵循开闭原则，将校验规则抽取出来，实现共同的接口 IValidateHandler，同时将函数 validate() 改成 Validation 类，通过 addValidateHandler() 函数添加校验规则，通过 validate() 函数校验表单。这样，当有新的校验规则出现时，只要实现 IValidateHandler 接口并调用 addValidateHandler() 函数即可，不需要修改类 Validation 的代码。</p>
<pre class="lang-typescript" data-nodeid="102233"><code data-language="typescript"><span class="hljs-keyword">class</span> Validation &#123;
    <span class="hljs-keyword">private</span> validateHandlers: ValidateHandler[] = [];
    <span class="hljs-keyword">public</span> addValidateHandler(handler: IValidateHandler) &#123;
        <span class="hljs-built_in">this</span>.validateHandlers.push(handler)
    &#125;
    <span class="hljs-keyword">public</span> validate() &#123;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">this</span>.validateHandlers.length; i++) &#123;
            <span class="hljs-built_in">this</span>.validateHandlers[i].validate();
        &#125;
    &#125;
&#125;
<span class="hljs-keyword">interface</span> IValidateHandler &#123;
    validate(): <span class="hljs-built_in">boolean</span>;
&#125;
<span class="hljs-keyword">class</span> UsernameValidateHandler <span class="hljs-keyword">implements</span> IValidateHandler &#123;
    <span class="hljs-keyword">public</span> validate() &#123;
      ...
    &#125;
&#125;
<span class="hljs-keyword">class</span> PwdValidateHandler <span class="hljs-keyword">implements</span> IValidateHandler &#123;
    <span class="hljs-keyword">public</span> validate() &#123;
      ...
    &#125;
&#125;
<span class="hljs-keyword">class</span> CaptchaValidateHandler <span class="hljs-keyword">implements</span> IValidateHandler &#123;
    <span class="hljs-keyword">public</span> validate() &#123;
      ...
    &#125;
&#125;
</code></pre>
<h4 data-nodeid="102234">里氏替换原则</h4>
<p data-nodeid="102235">里氏替换原则是指在使用父类的地方可以用它的任意子类进行替换。里氏替换原则是对类的继承复用作出的要求，要求子类可以随时替换掉其父类，同时功能不被破坏，父类的方法仍然能被使用。</p>
<p data-nodeid="102236">下面的代码就是一个违反里氏替换原则的例子，子类 Sparrow 重载了父类 Bird 的 getFood() 函数，但返回值发生了修改。那么如果使用 Bird 类实例的地方改成  Sparrow 类实例则会报错。</p>
<pre class="lang-typescript" data-nodeid="102237"><code data-language="typescript"><span class="hljs-keyword">class</span> Bird &#123;
&nbsp; getFood() &#123;
&nbsp; &nbsp; <span class="hljs-keyword">return</span> <span class="hljs-string">'虫子'</span>
&nbsp; &#125;
&#125;


<p><span class="hljs-keyword">class</span> Sparrow <span class="hljs-keyword">extends</span> Bird &#123;<br>&amp;nbsp; getFood() &#123;<br>&amp;nbsp; &amp;nbsp; <span class="hljs-keyword">return</span> [<span class="hljs-string">‘虫子’</span>, <span class="hljs-string">‘稻谷’</span>]<br>&amp;nbsp; &#125;<br>&#125;<br></code></pre></p>
<p data-nodeid="102238">对于这种需要重载的类，正确的做法应该是让子类和父类共同实现一个抽象类或接口。下面的代码就是实现了一个 IBird 接口来遵循里氏替换原则。</p>
<pre class="lang-typescript" data-nodeid="102239"><code data-language="typescript"><span class="hljs-keyword">interface</span> IBird &#123;
&nbsp; getFood(): <span class="hljs-built_in">string</span>[]
&#125;
<span class="hljs-keyword">class</span> Bird <span class="hljs-keyword">implements</span> IBird&#123;
&nbsp; getFood() &#123;
&nbsp; &nbsp; <span class="hljs-keyword">return</span> [<span class="hljs-string">'虫子'</span>]
&nbsp; &#125;
&#125;


<p><span class="hljs-keyword">class</span> Sparrow <span class="hljs-keyword">implements</span> IBird &#123;<br>&amp;nbsp; getFood() &#123;<br>&amp;nbsp; &amp;nbsp; <span class="hljs-keyword">return</span> [<span class="hljs-string">‘虫子’</span>, <span class="hljs-string">‘稻谷’</span>]<br>&amp;nbsp; &#125;<br>&#125;<br></code></pre></p>
<h4 data-nodeid="102240">依赖倒置原则</h4>
<p data-nodeid="102241">准确说应该是避免依赖倒置，好的依赖关系应该是类依赖于抽象接口，不应依赖于具体实现。这样设计的好处就是当依赖发生变化时，只需要传入对应的具体实例即可。</p>
<p data-nodeid="102242">下面的示例代码中，类 Passenger 的构造函数需要传入一个 Bike 类实例，然后在 start() 函数中调用 Bike 实例的 run() 函数。此时类 Passenger 和类 Bike 的耦合非常紧，如果现在要支持一个 Car 类则需要修改 Passenger 代码。</p>
<pre class="lang-typescript" data-nodeid="102243"><code data-language="typescript"><span class="hljs-keyword">class</span> Bike &#123;
&nbsp; run() &#123;
&nbsp; &nbsp; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Bike run'</span>)
&nbsp; &#125;
&#125;
<span class="hljs-keyword">class</span> Passenger &#123;
&nbsp; construct(Bike: bike) &#123;
&nbsp; &nbsp; <span class="hljs-built_in">this</span>.tool = bike
&nbsp; &#125;
&nbsp; <span class="hljs-keyword">public</span> start() &#123;
&nbsp; &nbsp; <span class="hljs-built_in">this</span>.tool.run()
&nbsp; &#125;
&#125;
</code></pre>
<p data-nodeid="102244">如果遵循依赖倒置原则，可以声明一个接口 ITransportation，让 Passenger 类的构造函数改为 ITransportation 类型，从而做到 Passenger 类和 Bike 类解耦，这样当 Passenger 需要支持 Car 类的时候，只需要新增 Car 类即可。</p>
<pre class="lang-typescript" data-nodeid="102245"><code data-language="typescript"><span class="hljs-keyword">interface</span> ITransportation &#123;
&nbsp; run(): <span class="hljs-built_in">void</span>
&#125;
<span class="hljs-keyword">class</span> Bike <span class="hljs-keyword">implements</span> ITransportation &#123;
&nbsp; run() &#123;
&nbsp; &nbsp; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Bike run'</span>)
&nbsp; &#125;
&#125;
<span class="hljs-keyword">class</span> Car <span class="hljs-keyword">implements</span> ITransportation &#123;
&nbsp; run() &#123;
&nbsp; &nbsp; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Car run'</span>)
&nbsp; &#125;
&#125;
<span class="hljs-keyword">class</span> Passenger &#123;
  construct(ITransportation&nbsp;: transportation) &#123;
    <span class="hljs-built_in">this</span>.tool = transportation
  &#125;
  <span class="hljs-keyword">public</span> start() &#123;
    <span class="hljs-built_in">this</span>.tool.run()
  &#125;
&#125;
</code></pre>
<h4 data-nodeid="102246">接口隔离原则</h4>
<p data-nodeid="102247">不应该依赖它不需要的接口，也就是说一个类对另一个类的依赖应该建立在最小的接口上。目的就是为了降低代码之间的耦合性，方便后续代码修改。</p>
<p data-nodeid="102248">下面就是一个违反接口隔离原则的反例，类 Dog 和类 Bird 都继承了接口 IAnimal，但是 Bird类并没有 swim函数，只能实现一个空函数 swim()。</p>
<pre class="lang-typescript" data-nodeid="102249"><code data-language="typescript"><span class="hljs-keyword">interface</span> IAnimal &#123;
  eat(): <span class="hljs-built_in">void</span>
  swim(): <span class="hljs-built_in">void</span>
&#125;
<span class="hljs-keyword">class</span> Dog <span class="hljs-keyword">implements</span> IAnimal &#123;
  eat() &#123;
    ...
  &#125;
  swim() &#123;
    ...
  &#125;
&#125;
<span class="hljs-keyword">class</span> Bird <span class="hljs-keyword">implements</span> IAnimal &#123;
  eat() &#123;
    ...
  &#125;
  swim() &#123;
    <span class="hljs-comment">// do nothing</span>
  &#125;
&#125;
</code></pre>
<h4 data-nodeid="102250">迪米特原则</h4>
<p data-nodeid="102251">一个类对于其他类知道得越少越好，就是说一个对象应当对其他对象尽可能少的了解。这一条原则要求任何一个对象或者方法只能调用该对象本身和内部创建的对象实例，如果要调用外部的对象，只能通过参数的形式传递进来。这一点和纯函数的思想相似。</p>
<p data-nodeid="102252">下面的类 Store 就违反了迪米特原则，类内部使用了全局变量。</p>
<pre class="lang-typescript" data-nodeid="102253"><code data-language="typescript"><span class="hljs-keyword">class</span> Store &#123;
  set(key, value) &#123;
    <span class="hljs-built_in">window</span>.localStorage.setItem(key, value)
  &#125;
&#125;
</code></pre>
<p data-nodeid="102254">一种改造方式就是在初始化的时候将 window.localstorage 作为参数传递给 Store 实例。</p>
<pre class="lang-typescript" data-nodeid="102255"><code data-language="typescript"><span class="hljs-keyword">class</span> Store &#123;
  construct(s) &#123;
    <span class="hljs-built_in">this</span>._store = s
  &#125;
  set(key, value) &#123;
    <span class="hljs-built_in">this</span>._store.setItem(key, value)
  &#125;
&#125;
<span class="hljs-keyword">new</span> Store(<span class="hljs-built_in">window</span>.localstorage)
</code></pre>
<h4 data-nodeid="102256">单一职责原则</h4>
<p data-nodeid="102257">应该有且仅有一个原因引起类的变更。这个原则很好理解，一个类代码量越多，功能就越复杂，维护成本也就越高。遵循单一职责原则可以有效地控制类的复杂度。</p>
<p data-nodeid="102258">像下面这种情形经常在项目中看到，一个公共类聚集了很多不相关的函数，这就违反了单一职责原则。</p>
<pre class="lang-java" data-nodeid="106525"><code data-language="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Util</span> </span>&#123;
  <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-title">toTime</span><span class="hljs-params">(date)</span> </span>&#123;
    ...
  &#125;
  <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-title">formatString</span><span class="hljs-params">(str)</span> </span>&#123;
    ...
  &#125;
  <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-title">encode</span><span class="hljs-params">(str)</span> </span>&#123;
    ...
  &#125;
&#125;
</code></pre>




<p data-nodeid="102260">了解了设计模式原则之后，下面再来看看具体的设计模式。</p>
<h3 data-nodeid="102261">设计模式的分类</h3>
<p data-nodeid="107184" class="">经典的设计模式有 3 大类，共 23 种，包括<strong data-nodeid="107198">创建型</strong>、<strong data-nodeid="107199">结构型</strong>和<strong data-nodeid="107200">行为型</strong>。</p>
<h4 data-nodeid="102263">创建型</h4>
<p data-nodeid="102264">创建型模式的主要关注点是“如何创建和使用对象”，这些模式的核心特点就是将对象的创建与使用进行分离，从而降低系统的耦合度。使用者不需要关注对象的创建细节，对象的创建由相关的类来完成。</p>
<p data-nodeid="102265">具体包括下面几种模式：</p>
<ul data-nodeid="102266">
<li data-nodeid="102267">
<p data-nodeid="102268"><strong data-nodeid="102412">抽象工厂模</strong>，提供一个超级工厂类来创建其他工厂类，然后通过工厂类创建类实例；</p>
</li>
<li data-nodeid="102269">
<p data-nodeid="102270"><strong data-nodeid="102417">生成器模式</strong>，将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象；</p>
</li>
<li data-nodeid="102271">
<p data-nodeid="102272"><strong data-nodeid="102422">工厂方法模式</strong>，定义一个用于创建生成类的工厂类，由调用者提供的参数决定生成什么类实例；</p>
</li>
<li data-nodeid="102273">
<p data-nodeid="102274"><strong data-nodeid="102427">原型模式</strong>，将一个对象作为原型，通过对其进行克隆创建新的实例；</p>
</li>
<li data-nodeid="102275">
<p data-nodeid="102276"><strong data-nodeid="102432">单例模式</strong>，生成一个全局唯一的实例，同时提供访问这个实例的函数。</p>
</li>
</ul>
<p data-nodeid="102277">下面的代码示例是 Vue.js 源码中使用单例模式的例子。其中，构造了一个唯一的数组 _installedPlugins 来保存插件，并同时提供了 Vue.use() 函数来新增插件。</p>
<pre class="lang-javascript" data-nodeid="102278"><code data-language="javascript"><span class="hljs-comment">// src/core/global-api/use.js</span>
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">initUse</span> (<span class="hljs-params">Vue: GlobalAPI</span>) </span>&#123;
&nbsp; Vue.use = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">plugin: Function | Object</span>) </span>&#123;
&nbsp; &nbsp; <span class="hljs-keyword">const</span> installedPlugins = (<span class="hljs-built_in">this</span>._installedPlugins || (<span class="hljs-built_in">this</span>._installedPlugins = []))
&nbsp; &nbsp; <span class="hljs-keyword">if</span> (installedPlugins.indexOf(plugin) &gt; <span class="hljs-number">-1</span>) &#123;
&nbsp; &nbsp; &nbsp; <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>
&nbsp; &nbsp; &#125;
&nbsp; &nbsp; ......
&nbsp; &#125;
&#125;
</code></pre>
<p data-nodeid="102279">下面的代码中，cloneVNode() 函数通过已有 vnode 实例来克隆新的实例，用到了原型模式。</p>
<pre class="lang-javascript" data-nodeid="102280"><code data-language="javascript"><span class="hljs-comment">// src/core/vdom/vnode.js</span>
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cloneVNode</span> (<span class="hljs-params">vnode: VNode</span>): <span class="hljs-title">VNode</span> </span>&#123;
&nbsp; <span class="hljs-keyword">const</span> cloned = <span class="hljs-keyword">new</span> VNode(
&nbsp; &nbsp; vnode.tag,
&nbsp; &nbsp; vnode.data,
&nbsp; &nbsp; <span class="hljs-comment">// #7975</span>
&nbsp; &nbsp; <span class="hljs-comment">// clone children array to avoid mutating original in case of cloning</span>
&nbsp; &nbsp; <span class="hljs-comment">// a child.</span>
&nbsp; &nbsp; vnode.children &amp;&amp; vnode.children.slice(),
&nbsp; &nbsp; vnode.text,
&nbsp; &nbsp; vnode.elm,
&nbsp; &nbsp; vnode.context,
&nbsp; &nbsp; vnode.componentOptions,
&nbsp; &nbsp; vnode.asyncFactory
&nbsp; )
&nbsp; cloned.ns = vnode.ns
&nbsp; cloned.isStatic = vnode.isStatic
&nbsp; cloned.key = vnode.key
&nbsp; cloned.isComment = vnode.isComment
&nbsp; cloned.fnContext = vnode.fnContext
&nbsp; cloned.fnOptions = vnode.fnOptions
&nbsp; cloned.fnScopeId = vnode.fnScopeId
&nbsp; cloned.asyncMeta = vnode.asyncMeta
&nbsp; cloned.isCloned = <span class="hljs-literal">true</span>
&nbsp; <span class="hljs-keyword">return</span> cloned
&#125;
</code></pre>
<h4 data-nodeid="102281">结构型</h4>
<p data-nodeid="102282">结构型模式描述如何将类或对象组合在一起形成更大的结构。它分为类结构型模式和对象结构型模式，类结构型模式采用继承机制来组织接口和类，对象结构型模式釆用组合或聚合来生成新的对象。</p>
<p data-nodeid="102283">具体包括下面几种模式：</p>
<ul data-nodeid="102284">
<li data-nodeid="102285">
<p data-nodeid="102286"><strong data-nodeid="102444">适配器模式</strong>，将一个类的接口转换成另一个类的接口，使得原本由于接口不兼容而不能一起工作的类能一起工作；</p>
</li>
<li data-nodeid="102287">
<p data-nodeid="102288"><strong data-nodeid="102449">桥接模式</strong>，将抽象与实现分离，使它们可以独立变化，它是用组合关系代替继承关系来实现的，从而降低了抽象和实现这两个可变维度的耦合度；</p>
</li>
<li data-nodeid="102289">
<p data-nodeid="102290"><strong data-nodeid="102454">组合模式</strong>，将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性；</p>
</li>
<li data-nodeid="102291">
<p data-nodeid="102292"><strong data-nodeid="102459">装饰器模式</strong>，动态地给对象增加一些职责，即增加其额外的功能；</p>
</li>
<li data-nodeid="102293">
<p data-nodeid="102294"><strong data-nodeid="102464">外观模式</strong>，为多个复杂的子系统提供一个统一的对外接口，使这些子系统更加容易被访问；</p>
</li>
<li data-nodeid="102295">
<p data-nodeid="102296"><strong data-nodeid="102469">享元模式</strong>，运用共享技术来有效地支持大量细粒度对象的复用；</p>
</li>
<li data-nodeid="102297">
<p data-nodeid="102298"><strong data-nodeid="102474">代理模式</strong>，为某对象提供一种代理以控制对该对象的访问，即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。</p>
</li>
</ul>
<p data-nodeid="102299">Vue.js 在判断浏览器支持 Proxy 的情况下会使用代理模式，下面是具体源码：</p>
<pre class="lang-javascript" data-nodeid="102300"><code data-language="javascript"><span class="hljs-comment">// src/core/instance/proxy.js</span>
initProxy = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">initProxy</span> (<span class="hljs-params">vm</span>) </span>&#123;
&nbsp; <span class="hljs-keyword">if</span> (hasProxy) &#123;
&nbsp; &nbsp; <span class="hljs-comment">// determine which proxy handler to use</span>
&nbsp; &nbsp; <span class="hljs-keyword">const</span> options = vm.$options
&nbsp; &nbsp; <span class="hljs-keyword">const</span> handlers = options.render &amp;&amp; options.render._withStripped
&nbsp; &nbsp; &nbsp; ? getHandler
&nbsp; &nbsp; &nbsp; : hasHandler
&nbsp; &nbsp; vm._renderProxy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(vm, handlers)
&nbsp; &#125; <span class="hljs-keyword">else</span> &#123;
&nbsp; &nbsp; vm._renderProxy = vm
&nbsp; &#125;
&#125;
</code></pre>
<p data-nodeid="102301">Vue 的 Dep 类则应用了代理模式，调用 notify() 函数来通知 subs 数组中的 Watcher 实例。</p>
<pre class="lang-javascript" data-nodeid="102302"><code data-language="javascript"><span class="hljs-comment">// src/core/observer/dep.js</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dep</span> </span>&#123;
&nbsp; <span class="hljs-keyword">static</span> target: ?Watcher;
&nbsp; id: number;
&nbsp; subs: <span class="hljs-built_in">Array</span>&lt;Watcher&gt;;


<p>&amp;nbsp; <span class="hljs-keyword">constructor</span> () &#123;<br>&amp;nbsp; &amp;nbsp; <span class="hljs-built_in">this</span>.id &#x3D; uid++<br>&amp;nbsp; &amp;nbsp; <span class="hljs-built_in">this</span>.subs &#x3D; []<br>&amp;nbsp; &#125;</p>
<p>&amp;nbsp; addSub (sub: Watcher) &#123;<br>&amp;nbsp; &amp;nbsp; <span class="hljs-built_in">this</span>.subs.push(sub)<br>&amp;nbsp; &#125;</p>
<p>&amp;nbsp; removeSub (sub: Watcher) &#123;<br>&amp;nbsp; &amp;nbsp; remove(<span class="hljs-built_in">this</span>.subs, sub)<br>&amp;nbsp; &#125;</p>
<p>&amp;nbsp; depend () &#123;<br>&amp;nbsp; &amp;nbsp; <span class="hljs-keyword">if</span> (Dep.target) &#123;<br>&amp;nbsp; &amp;nbsp; &amp;nbsp; Dep.target.addDep(<span class="hljs-built_in">this</span>)<br>&amp;nbsp; &amp;nbsp; &#125;<br>&amp;nbsp; &#125;</p>
<p>&amp;nbsp; notify () &#123;<br>&amp;nbsp; &amp;nbsp; <span class="hljs-comment">&#x2F;&#x2F; stabilize the subscriber list first</span><br>&amp;nbsp; &amp;nbsp; <span class="hljs-keyword">const</span> subs &#x3D; <span class="hljs-built_in">this</span>.subs.slice()<br>&amp;nbsp; &amp;nbsp; <span class="hljs-keyword">if</span> (process.env.NODE_ENV !&#x3D;&#x3D; <span class="hljs-string">‘production’</span> &amp;&amp; !config.async) &#123;<br>&amp;nbsp; &amp;nbsp; &amp;nbsp; <span class="hljs-comment">&#x2F;&#x2F; subs aren’t sorted in scheduler if not running async</span><br>&amp;nbsp; &amp;nbsp; &amp;nbsp; <span class="hljs-comment">&#x2F;&#x2F; we need to sort them now to make sure they fire in correct</span><br>&amp;nbsp; &amp;nbsp; &amp;nbsp; <span class="hljs-comment">&#x2F;&#x2F; order</span><br>&amp;nbsp; &amp;nbsp; &amp;nbsp; subs.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) &#x3D;&gt;</span> a.id - b.id)<br>&amp;nbsp; &amp;nbsp; &#125;<br>&amp;nbsp; &amp;nbsp; <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i &#x3D; <span class="hljs-number">0</span>, l &#x3D; subs.length; i &lt; l; i++) &#123;<br>&amp;nbsp; &amp;nbsp; &amp;nbsp; subs[i].update()<br>&amp;nbsp; &amp;nbsp; &#125;<br>&amp;nbsp; &#125;<br>&#125;<br></code></pre></p>
<h4 data-nodeid="102303">行为型</h4>
<p data-nodeid="102304">行为型模式用于描述程序在运行时复杂的流程控制，即描述多个类或对象之间怎样相互协作共同完成单个对象无法单独完成的任务，它涉及算法与对象间职责的分配。</p>
<p data-nodeid="102305">行为型模式分为<strong data-nodeid="102488">类行为模式</strong>和<strong data-nodeid="102489">对象行为</strong>模式，类的行为模式采用继承机制在子类和父类之间分配行为，对象行为模式采用多态等方式来分配子类和父类的职责。</p>
<p data-nodeid="102306">具体包括下面几种模式：</p>
<ul data-nodeid="102307">
<li data-nodeid="102308">
<p data-nodeid="102309"><strong data-nodeid="102495">责任链模式</strong>，把请求从链中的一个对象传到下一个对象，直到请求被响应为止，通过这种方式去除对象之间的耦合；</p>
</li>
<li data-nodeid="102310">
<p data-nodeid="102311"><strong data-nodeid="102500">命令模式</strong>，将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开；</p>
</li>
<li data-nodeid="102312">
<p data-nodeid="102313"><strong data-nodeid="102505">策略模式</strong>，定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的用户；</p>
</li>
<li data-nodeid="102314">
<p data-nodeid="102315"><strong data-nodeid="102510">解释器模式</strong>，提供如何定义语言的文法，以及对语言句子的解释方法，即解释器；</p>
</li>
<li data-nodeid="102316">
<p data-nodeid="102317"><strong data-nodeid="102515">迭代器模式</strong>，提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示；</p>
</li>
<li data-nodeid="102318">
<p data-nodeid="102319"><strong data-nodeid="102520">中介者模式</strong>，定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解；</p>
</li>
<li data-nodeid="102320">
<p data-nodeid="102321"><strong data-nodeid="102525">备忘录模式</strong>，在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它；</p>
</li>
<li data-nodeid="102322">
<p data-nodeid="102323"><strong data-nodeid="102530">观察者模式</strong>，多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为；</p>
</li>
<li data-nodeid="102324">
<p data-nodeid="102325"><strong data-nodeid="102535">状态模式</strong>，类的行为基于状态对象而改变；</p>
</li>
<li data-nodeid="102326">
<p data-nodeid="102327"><strong data-nodeid="102540">访问者模式</strong>，在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问；</p>
</li>
<li data-nodeid="102328">
<p data-nodeid="102329"><strong data-nodeid="102545">模板方法模式</strong>，定义一个操作中的算法骨架，将算法的一些步骤延迟到子类中，使得子类在可以不改变该算法结构的情况下重定义该算法的某些特定步骤。</p>
</li>
</ul>
<p data-nodeid="102330">下面是 Vue.js 中使用状态对象 renderContext 的部分源码：</p>
<pre class="lang-javascript" data-nodeid="102331"><code data-language="javascript"><span class="hljs-comment">// src/core/instance/render.js</span>
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">initRender</span> (<span class="hljs-params">vm: Component</span>) </span>&#123;
&nbsp; vm._vnode = <span class="hljs-literal">null</span> <span class="hljs-comment">// the root of the child tree</span>
&nbsp; vm._staticTrees = <span class="hljs-literal">null</span> <span class="hljs-comment">// v-once cached trees</span>
&nbsp; <span class="hljs-keyword">const</span> options = vm.$options
&nbsp; <span class="hljs-keyword">const</span> parentVnode = vm.$vnode = options._parentVnode <span class="hljs-comment">// the placeholder node in parent tree</span>
&nbsp; <span class="hljs-keyword">const</span> renderContext = parentVnode &amp;&amp; parentVnode.context
&nbsp; vm.$slots = resolveSlots(options._renderChildren, renderContext)
&nbsp; vm.$scopedSlots = emptyObject
&nbsp; <span class="hljs-comment">// bind the createElement fn to this instance</span>
&nbsp; <span class="hljs-comment">// so that we get proper render context inside it.</span>
&nbsp; <span class="hljs-comment">// args order: tag, data, children, normalizationType, alwaysNormalize</span>
&nbsp; <span class="hljs-comment">// internal version is used by render functions compiled from templates</span>
  ......
&#125;
</code></pre>
<p data-nodeid="102332">Vue.js 中通过 Object.defineProperty 劫持再发送消息则属于观察者模式。</p>
<pre class="lang-javascript" data-nodeid="102333"><code data-language="javascript"><span class="hljs-comment">// src/core/observer/index.js</span>
<span class="hljs-built_in">Object</span>.defineProperty(obj, key, &#123;
&nbsp; <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,
&nbsp; <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,
&nbsp; <span class="hljs-attr">get</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reactiveGetter</span> (<span class="hljs-params"></span>) </span>&#123;
&nbsp; &nbsp; ......
&nbsp; &#125;,
&nbsp; <span class="hljs-attr">set</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reactiveSetter</span> (<span class="hljs-params">newVal</span>) </span>&#123;
&nbsp; &nbsp; <span class="hljs-keyword">const</span> value = getter ? getter.call(obj) : val
&nbsp; &nbsp; <span class="hljs-comment">/* eslint-disable no-self-compare */</span>
&nbsp; &nbsp; <span class="hljs-keyword">if</span> (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123;
&nbsp; &nbsp; &nbsp; <span class="hljs-keyword">return</span>
&nbsp; &nbsp; &#125;
&nbsp; &nbsp; <span class="hljs-comment">/* eslint-enable no-self-compare */</span>
&nbsp; &nbsp; <span class="hljs-keyword">if</span> (process.env.NODE_ENV !== <span class="hljs-string">'production'</span> &amp;&amp; customSetter) &#123;
&nbsp; &nbsp; &nbsp; customSetter()
&nbsp; &nbsp; &#125;
&nbsp; &nbsp; <span class="hljs-comment">// #7981: for accessor properties without setter</span>
&nbsp; &nbsp; <span class="hljs-keyword">if</span> (getter &amp;&amp; !setter) <span class="hljs-keyword">return</span>
&nbsp; &nbsp; <span class="hljs-keyword">if</span> (setter) &#123;
&nbsp; &nbsp; &nbsp; setter.call(obj, newVal)
&nbsp; &nbsp; &#125; <span class="hljs-keyword">else</span> &#123;
&nbsp; &nbsp; &nbsp; val = newVal
&nbsp; &nbsp; &#125;
&nbsp; &nbsp; childOb = !shallow &amp;&amp; observe(newVal)
&nbsp; &nbsp; dep.notify()
&nbsp; &#125;
&#125;)
</code></pre>
<h3 data-nodeid="102334">总结</h3>
<p data-nodeid="102335">虽然 JavaScript 并不是一门面向对象的语言，但设计模式的原则和思想对我们编写代码仍有很重要的指导意义。</p>
<p data-nodeid="102336">本课时介绍了设计模式的 6 个重要原则，包括开闭原则、里氏替换原则、依赖倒置原则、接口隔离原则、迪米特原则、单一职责原则，重点讨论了接口和类的使用方式；然后介绍了 3 类设计模式以及对应的例子，创建型模式重点关注如何创建类实例，结构型模式重点关注类之间如何组合，行为型模式关注多个类之间的函数调用关系。</p>
<p data-nodeid="102337">要全部记住 23 种设计模式有些困难，重点在于理解其背后的思想与目的，从而做到心中有数，在此之上配合编码实践，才能最终完全掌握。</p>
<p data-nodeid="102338">最后布置一道思考题：你还在框架代码中找到过哪些设计模式的应用？</p>

<hr>
<h3 id="精选评论"><a href="#精选评论" class="headerlink" title="精选评论"></a>精选评论</h3><h5 id="召："><a href="#召：" class="headerlink" title="*召："></a>*召：</h5><blockquote>
<p>23种设计模式，与设计模式的原则、思想和目的</p>
</blockquote>
<h5 id="浩："><a href="#浩：" class="headerlink" title="*浩："></a>*浩：</h5><blockquote>
<p>有人说设计模式更像是一种艺术行为而非科学行为</p>
</blockquote>
<h5 id="宇："><a href="#宇：" class="headerlink" title="*宇："></a>*宇：</h5><blockquote>
<p>写的太好了</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/11/02/%E6%A1%86%E6%9E%B6%E5%88%B0%E5%BA%95%E7%94%A8%E4%BA%86%E5%93%AA%E4%BA%9B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9F/" data-id="claxeera6001gv8w1c2fq6spb" data-title="框架到底用了哪些设计模式？" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-你都了解过哪些编程方式" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/11/02/%E4%BD%A0%E9%83%BD%E4%BA%86%E8%A7%A3%E8%BF%87%E5%93%AA%E4%BA%9B%E7%BC%96%E7%A8%8B%E6%96%B9%E5%BC%8F/" class="article-date">
  <time class="dt-published" datetime="2022-11-02T02:49:01.000Z" itemprop="datePublished">2022-11-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/11/02/%E4%BD%A0%E9%83%BD%E4%BA%86%E8%A7%A3%E8%BF%87%E5%93%AA%E4%BA%9B%E7%BC%96%E7%A8%8B%E6%96%B9%E5%BC%8F/">你都了解过哪些编程方式</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p data-nodeid="315946">程序代码虽然在机器上运行，但终究是由人来编写和维护的，因此代码的可读性、可维护性在软件开发中尤为重要。所以我们在编写代码的时候通常会遵循一些编码规范或风格，比如 Google 提出了最著名的关于主流语言的<a target="_blank" rel="noopener" href="https://zh-google-styleguide.readthedocs.io/en/latest/" data-nodeid="316009">风格指南</a>，但这些都比较微观和具体，如果宏观且抽象地来看，编码风格可以上升为<strong data-nodeid="316015">编程范式</strong>。</p>
<p data-nodeid="315947">编程范式（Programming Paradigm）也称“编程泛型”或“程序设计法”，是对代码编写方式的一种抽象，体现出了开发者对程序执行的看法。例如，在面向对象编程中，开发者认为程序是一系列相互作用的对象，而在函数式编程中一个程序会被看作是一个无状态的函数计算的序列。常见的编程范式有 2 种：命令式编程和声明式编程。</p>
<h3 data-nodeid="315948">命令式编程（Imperative Programming）</h3>
<p data-nodeid="315949">命令式编程是一种古老的编程范式，它的出现与冯·诺依曼架构（现代计算机的基础，一种将程序指令存储器和数据存储器合并在一起的电脑设计结构）有紧密关系。冯·诺依曼架构的基本工作原理是通过赋值语句来更改程序状态，然后根据这些状态来逐步执行任务。而命令式编程方式就是对这个工作过程的抽象，主要关注点是如何通过具体步骤得到计算结果。</p>
<p data-nodeid="315950">命令式编程比较重要的子类有 2 个：面向过程、面向对象。</p>
<h4 data-nodeid="315951">面向过程（Procedural Programming）</h4>
<p data-nodeid="315952">面向过程是一种以过程为中心的编程思想，在编程过程中分析出解决问题所需要的步骤，然后再按照执行过程编写代码。 这种编程范式比较具象，很符合人的直觉思维，我们在入门学习 JavaScript 的时候就已经学会了。比如，下面的代码就是一个面向过程的例子，calc() 函数接收两个参数，第一个是待遍历的数组 arr，第二个是计算类型 type：</p>
<pre class="lang-javascript" data-nodeid="315953"><code data-language="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">calc</span>(<span class="hljs-params">arr, type</span>) </span>&#123;
&nbsp; <span class="hljs-keyword">switch</span>(type) &#123;
&nbsp; &nbsp; <span class="hljs-keyword">case</span> <span class="hljs-string">'add'</span>:
&nbsp; &nbsp; &nbsp; <span class="hljs-keyword">return</span> arr.reduce(<span class="hljs-function">(<span class="hljs-params">acc, cur</span>) =&gt;</span> acc + cur, <span class="hljs-number">0</span>)
&nbsp; &nbsp; &nbsp; <span class="hljs-keyword">break</span>;
&nbsp; &nbsp; <span class="hljs-keyword">case</span> <span class="hljs-string">'multiple'</span>:
&nbsp; &nbsp; &nbsp; <span class="hljs-keyword">return</span> arr.reduce(<span class="hljs-function">(<span class="hljs-params">acc, cur</span>) =&gt;</span> acc * cur, <span class="hljs-number">1</span>)
&nbsp; &nbsp; &nbsp; <span class="hljs-keyword">break</span>;
&nbsp; &#125;
&#125;
</code></pre>
<p data-nodeid="315954">这种编程范式流程明确，也不需要像面向对象那样生成实例，占用额外的存储空间，但它有个问题，就是代码的可扩展性不够。比如现在要加一个操作类型，那么又要修改 calc() 函数，添加一个逻辑分支。</p>
<h4 data-nodeid="315955">面向对象（Object-oriented Programming）</h4>
<p data-nodeid="315956">面向过程的编程范式要求按照流程步骤逐个地分析每个问题。很显然，并不是所有问题都适合这种过程化的思维方式，这也就导致了其他编程范式的出现，比如面向对象。</p>
<p data-nodeid="315957">面向对象的核心是对象，它不是把问题抽象成流程步骤，而是抽象成对象，对象是程序代码中的基本单位，对应代码中的类或类的实例，对象内部封装了数据和方法。这种编程范式主要包含 3 个特性：封装、继承、多态。</p>
<h5 data-nodeid="318457" class="">1. 封装（Encapsulation）</h5>




<p data-nodeid="315959">封装是通过限制只有特定类的对象可以访问这一特定类的成员，而它们通常利用接口实现消息的传入传出。简单说，就是给类的属性设定“权限”，将类的属性分为 3 类：公有成员、私有成员和受保护成员。公有成员可以由外部调用，私有成员只能在类内部访问，受保护的成员也只能在类内部或由子类访问。</p>
<p data-nodeid="315960">下面两段代码分别是使用 JavaScript （ES5）和 TypeScript 实现封装特性的例子。在 JavaScript 中需要通过函数作用域来实现私有变量，在 TypeScript中则和面向对象语言 Java 的写法比较相近，通过关键字 private 和 public 声明即可。</p>
<pre class="lang-typescript" data-nodeid="315961"><code data-language="typescript"><span class="hljs-comment">// ES5 写法</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Animal</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-keyword">var</span> name = <span class="hljs-string">''</span>
  <span class="hljs-built_in">this</span>.setName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a</span>) </span>&#123;
    name = a
  &#125;
  <span class="hljs-built_in">this</span>.getName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-keyword">return</span> name
  &#125;
&#125;
<span class="hljs-comment">// TypeScript 写法</span>
<span class="hljs-keyword">class</span> Animal &#123;
    <span class="hljs-keyword">private</span> name:<span class="hljs-built_in">string</span>;
    <span class="hljs-keyword">public</span> setName(name:<span class="hljs-built_in">string</span>):<span class="hljs-built_in">void</span> &#123;
        <span class="hljs-built_in">this</span>.name = name
    &#125;
    <span class="hljs-keyword">public</span> getName():<span class="hljs-built_in">string</span> &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name
    &#125;
&#125;
</code></pre>
<h5 data-nodeid="320383" class="">2. 继承（Inheritance）</h5>





<p data-nodeid="315963">继承这个概念和生物学中的遗传有些类似，在创建子类的时候，会默认获得父类的一些非私有属性和方法。</p>
<p data-nodeid="315964">下面两段代码分别是使用 JavaScript （ES5）和 TypeScript 实现继承特性的例子。</p>
<p data-nodeid="315965">在 JavaScript 中需要通过原型对象 prototype 来实现继承，在 TypeScript中则和面向对象语言 Java 的写法比较相近，通过 extends 来继承父类。虽然在 JavaScript/TypeScript 都能实现基础的继承，但对于继承自多个父类的情况，实现起来会比较复杂。</p>
<pre class="lang-typescript" data-nodeid="315966"><code data-language="typescript"><span class="hljs-comment">// ES5 写法</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Dog</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-built_in">this</span>.bark = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-keyword">return</span> <span class="hljs-string">'wang wang wang!!!'</span>
  &#125;
&#125;
Dog.prototype = <span class="hljs-keyword">new</span> Animal()
<span class="hljs-comment">// TypeScript 写法</span>
<span class="hljs-keyword">class</span> Dog <span class="hljs-keyword">extends</span> Animal &#123;
    <span class="hljs-keyword">public</span> bark():<span class="hljs-built_in">string</span> &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-string">'wang wang wang!!!'</span>
    &#125;
&#125;
</code></pre>
<h5 data-nodeid="323491" class="">3. 多态（Polymorphism）</h5>









<p data-nodeid="315968">多态是指由继承而产生的相关的不同的类，其对象对同一消息会作出不同的响应。JavaScript/TypeScript 对多态的支持是不友好的，只能在函数内部通过判断参数类型来实现。</p>
<p data-nodeid="315969">下面是一个简单的例子：</p>
<pre class="lang-javascript" data-nodeid="315970"><code data-language="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Cat</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-built_in">this</span>.bark = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">sound</span>) </span>&#123;
        <span class="hljs-keyword">if</span>(<span class="hljs-literal">undefined</span> !== sound &amp;&amp; <span class="hljs-literal">null</span> !== sound) &#123;
            <span class="hljs-keyword">return</span> sound
        &#125; <span class="hljs-keyword">else</span> &#123;
            <span class="hljs-keyword">return</span> <span class="hljs-string">'...'</span>
        &#125;
    &#125;
&#125;
</code></pre>
<h3 data-nodeid="315971">声明式编程（Declarative Programming）</h3>
<p data-nodeid="315972">在计算机科学中，声明式编程是一种构建程序的样式，该表达式表示计算逻辑而无须谈论其控制流程。它通常将程序视为某种逻辑理论，可以简化编写并行程序的过程。重点是需要完成的工作，而不是应该如何完成。它只是声明我们想要的结果，而并不关注这个结果如何产生，这是命令式（如何做）和声明式（做什么）编程范式之间的唯一区别。</p>
<p data-nodeid="315973">声明式编程也有一些子类，常见的包括：逻辑式编程、数据驱动编程和函数式编程。</p>
<h4 data-nodeid="315974">逻辑式编程（Logic Programming）</h4>
<p data-nodeid="315975">逻辑式编程通过设置答案须符合的规则来解决问题，而非设置步骤来解决问题。</p>
<p data-nodeid="315976">这种风格很符合数学家和哲学家分析问题的方式，当我们需要解答一个新的问题时，先提出一个新的假设，然后再证明它跟现在的理论无冲突。逻辑提供了一个证明问题是真还是假的方法，创建证明的方法是人所皆知的，故逻辑是解答问题的可靠方法。逻辑式编程系统则自动化了这个程序，人工智能在逻辑式编程的发展中发挥了重要的影响。</p>
<p data-nodeid="315977">逻辑式编程在 Web 开发中并不常见，<a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2019/01/prolog.html" data-nodeid="316066">有兴趣的同学可以查阅阮一峰老师介绍逻辑编程语言 Prolog 的文章</a>。</p>
<h4 data-nodeid="315978">数据驱动编程（Data-driven Programming）</h4>
<p data-nodeid="315979">这种编程方法基于数​​据，程序语句由数据定义而非执行步骤。</p>
<p data-nodeid="315980">数据库程序是业务信息系统的核心，并提供文件创建、数据输入、更新、查询和报告功能。有几种主要针对数据库应用程序开发的编程语言，比如 SQL，它应用于结构化数据流，以进行过滤、转换、聚合（如计算统计信息）或调用其他程序。</p>
<h4 data-nodeid="315981">函数式编程（Functional Programming）</h4>
<p data-nodeid="315982">函数式编程范式来源于数学而非编程语言，它的关键原理是通过执行一系列的数学函数来得到结果。核心依赖是用于某些特定计算的功能，而非数据结构，也就是说，数据与函数是松散耦合的，甚至严格说，数据应该是不可见的，因为它隐藏在函数的实现内部。</p>
<p data-nodeid="315983">它主要有下面几个核心概念。</p>
<h5 data-nodeid="325223" class="">1. 纯函数</h5>





<p data-nodeid="315985">若一个函数符合幂等性且无副作用那么就可以称为<strong data-nodeid="316085">纯函数</strong>。幂等性是指在相同的输入值时，需产生相同的输出，与函数的输出和输入值以外的其他隐藏信息或状态无关。</p>
<pre class="lang-javascript" data-nodeid="315986"><code data-language="javascript"><span class="hljs-comment">// 非幂等</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">rand</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.random()
&#125;
<span class="hljs-comment">// 幂等</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">zero</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>
&#125;
</code></pre>
<p data-nodeid="315987">副作用是指除了返回函数值之外，还对调用函数产生附加的影响。例如，修改全局变量（函数外的变量）、修改参数或改变外部存储。</p>
<pre class="lang-javascript" data-nodeid="315988"><code data-language="javascript"><span class="hljs-comment">// 无副作用</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">a, b</span>)</span>&#123;
  <span class="hljs-keyword">return</span> a + b
&#125;
<span class="hljs-comment">// 有副作用</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setAddition</span>(<span class="hljs-params">a, b</span>) </span>&#123;
  localstorage.setItem(<span class="hljs-string">'sum'</span>, a + b)
&#125;
</code></pre>
<p data-nodeid="315989">从上面的例子我们还可以看出纯函数的输出可以不用和所有的输入值有关，甚至可以与所有的输入值都无关。</p>
<p data-nodeid="315990">纯函数会带来很多优点。首先它是无状态的，这也就意味着函数内部不需要额外的存储空间来保存数据；其次具有高度的可测试性，在前端框架中体现比较明显，之前用 jQuery 这类库来开发项目时，代码测试非常困难，因为很多函数是不纯的，内部可能涉及 DOM 操作、AJAX 请求、浏览器存储等各种副作用操作。</p>
<p data-nodeid="315991">纯函数的使用也比较广泛，JavaScript 一些原生函数，例如 JSON.stringify() 就是纯函数，React 中也有与之对应的函数式组件。</p>
<h5 data-nodeid="326895" class="">2. 高阶函数</h5>





<p data-nodeid="315993">高阶函数是指接收一个函数作为参数，然后返回另一个函数的函数。它体现的是一种高级的抽象思维，使用场景也比较多，例如 TypeScript 提供的装饰器功能来扩展函数，以及 React 中使用高阶组件来扩展组件行为。</p>
<h5 data-nodeid="328507" class="">3. 柯里化</h5>

<p>柯里化可以翻译成卡瑞化或加里化，是指把接受多个参数的函数变换成接受一个单一参数的函数，并且返回接受余下的参数且返回结果的新函数。这种处理函数的方式由克里斯托弗·斯特雷奇以逻辑学家哈斯凯尔·加里命名。<br>简单来说，就是在一个函数中预先填充几个参数，这个函数返回另一个函数，这个返回的新函数将其参数和预先填充的参数进行合并，再执行函数逻辑。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/11/02/%E4%BD%A0%E9%83%BD%E4%BA%86%E8%A7%A3%E8%BF%87%E5%93%AA%E4%BA%9B%E7%BC%96%E7%A8%8B%E6%96%B9%E5%BC%8F/" data-id="claxeer9v000qv8w1c5qj48jy" data-title="你都了解过哪些编程方式" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-常用的数据结构了解多少" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/11/02/%E5%B8%B8%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%86%E8%A7%A3%E5%A4%9A%E5%B0%91/" class="article-date">
  <time class="dt-published" datetime="2022-11-02T02:48:26.000Z" itemprop="datePublished">2022-11-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/11/02/%E5%B8%B8%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%86%E8%A7%A3%E5%A4%9A%E5%B0%91/">常用的数据结构了解多少</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p data-nodeid="43964">你好，我是你的前端课老师朱德龙，欢迎你和我一起学习第 26 课时的内容：“常用的数据结构了解多少”。</p>
<p data-nodeid="43965">数据结构是计算机中组织和存储数据的特定方式，也是对基本数据类型的一种高级抽象，它描述了数据之间的关系，以及操作数据的方法。</p>
<p data-nodeid="43966">数据结构不仅是编程语言和算法的基础，对于前端工程师而言，也变得越来越重要。随着 Web 应用的快速发展，前端工程师面临的场景也越来越复杂，无论 React、Vue 这些框架，还是大型 Web 应用，都离不开数据结构的支持。而且越来越多的公司也将数据结构列为面试考察点，所以掌握数据结构，是高级前端工程师的必备技能。</p>
<p data-nodeid="43967">这一课时我们就来分析最常用的 5 种数据结构：数组、栈、队列、链表、树。</p>
<h3 data-nodeid="43968">数组</h3>
<p data-nodeid="43969">高级语言的原生数据类型一般都提供了数组类型，所以数组结构并不需要特别的实现方式。</p>
<p data-nodeid="43970">数组虽然看似简单，但基于它可以生成一些更复杂的数据结构，比如多维数组、栈、队列等，本课时如无特殊说明，数组都指代一维数组。</p>
<p data-nodeid="43971">数组的最大优势在于可以通过索引来快速访问特定的元素，尤其是在有序数组中，比如要在一个升序数组 arr 中找到第 6 小的元素，那么可以直接通过下标 5 获取。</p>
<p data-nodeid="43972">大家在工作中对数组应该比较熟悉了，所以这里就不再详细介绍了，只介绍一下数组的实现原理。V8 引擎将 JavaScript 数组分为两类：</p>
<ul data-nodeid="43973">
<li data-nodeid="43974">
<p data-nodeid="43975">FixedArray，使用连续的内存进行存储，可以使用索引直接定位，新创建的空数组默认为 FixedArray 类型，当数组超过最大长度会进行动态地扩容；</p>
</li>
<li data-nodeid="43976">
<p data-nodeid="43977">HashTable，以哈希表的形式存储在内存空间里，存储地址不连续，与 FixedArray 类型相比，性能相对较差。</p>
</li>
</ul>
<p data-nodeid="43978">这两者之间在实际使用时可以相互转换：</p>
<ul data-nodeid="43979">
<li data-nodeid="43980">
<p data-nodeid="43981">FixedArray 转 HashTable，当新增元素的索引值相对于数组长度大于等于 1024  或者新容量 &gt;= 3 × 扩容后的容量 × 2；</p>
</li>
<li data-nodeid="43982">
<p data-nodeid="43983">HashTable 转 FixedArray，当 HashTable 数组的元素可存放在 FixedArray 数组中且长度在 smi 之间且仅节省了 50% 的空间时发生转换，其中 smi 值在不同操作系统下有所不同。</p>
</li>
</ul>
<p data-nodeid="43984">小结一下，FixedArray 数组通过牺牲空间来提升操作效率，HashTable 数组则相反，不必申请连续的空间，节省了内存，但需要付出效率变差的代价。</p>
<h3 data-nodeid="43985">栈</h3>
<p data-nodeid="43986">栈是一种操作受限的线性结构，限定只能在尾部进行插入和删除操作，尾部被称为栈顶，而头部称为栈底。向一个栈插入新元素又称作进栈、入栈或压栈，从一个栈删除元素又称作出栈或退栈。这种受限的操作方式让栈元素的入栈出栈遵循一种特殊的原则——先进后出（First In Last Out，FILO）。</p>
<p data-nodeid="43987">栈的应用非常广泛，这里列举 3 种：</p>
<ul data-nodeid="43988">
<li data-nodeid="43989">
<p data-nodeid="43990">浏览器的历史记录，它的前进、后退功能就是一个栈操作；</p>
</li>
<li data-nodeid="43991">
<p data-nodeid="43992">V8 中的函数执行过程采用的栈结构；</p>
</li>
<li data-nodeid="43993">
<p data-nodeid="43994">JavaScript 在捕获代码异常时，详细信息会以调用栈的形式打印。</p>
</li>
</ul>
<p data-nodeid="43995">栈可以通过数组来实现，下面的代码实现了一个栈结构：</p>
<pre class="lang-javascript" data-nodeid="43996"><code data-language="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Stack</span>(<span class="hljs-params"></span>)</span>&#123;
&nbsp; <span class="hljs-keyword">var</span> _stack = [];
&nbsp; <span class="hljs-built_in">this</span>.push = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">element</span>) </span>&#123;
&nbsp; &nbsp; _stack.push(element);
&nbsp; &#125;
&nbsp; <span class="hljs-built_in">this</span>.pop = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
&nbsp; &nbsp; <span class="hljs-keyword">return</span> _stack.pop();
&nbsp; &#125;
&nbsp; <span class="hljs-built_in">this</span>.top = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
&nbsp; &nbsp; <span class="hljs-keyword">return</span> _stack[_stack.length<span class="hljs-number">-1</span>];
&nbsp; &#125;
&nbsp; <span class="hljs-built_in">this</span>.isEmpty = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
&nbsp; &nbsp; <span class="hljs-keyword">return</span> _stack.length === <span class="hljs-number">0</span>;
&nbsp; &#125;
&nbsp; <span class="hljs-built_in">this</span>.size = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
&nbsp; &nbsp; <span class="hljs-keyword">return</span> _stack.length;
&nbsp; &#125;
&nbsp; <span class="hljs-built_in">this</span>.clear = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
&nbsp; &nbsp; _stack = [];
&nbsp; &#125;
&#125;
</code></pre>
<h3 data-nodeid="43997">队列</h3>
<p data-nodeid="43998">队列和栈一样也是操作受限的线性结构，但和栈有所区别的是，队列可以在头部和尾部进行操作，但尾部只能插入，头部只能删除。这种受限的操作方式让队列元素的插入和删除遵循一种特殊的原则——<strong data-nodeid="44089">先进先出原则</strong>（First In First Out，FIFO）。</p>
<p data-nodeid="43999">JavaScript 在处理异步操作时经常会用到队列，比如宏任务队列、微任务队列、回调函数队列。</p>
<p data-nodeid="44000">队列的实现也可以通过数组来实现，下面的代码实现了一个队列结构：</p>
<pre class="lang-javascript" data-nodeid="44001"><code data-language="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Queue</span>(<span class="hljs-params"></span>)</span>&#123;
  <span class="hljs-keyword">var</span> _queue = [];
  <span class="hljs-built_in">this</span>.enqueue = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">element</span>)</span>&#123;
    _queue.push(element)
  &#125;
  <span class="hljs-built_in">this</span>.dequeue = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-keyword">return</span> _queue.shift()
  &#125;
  <span class="hljs-built_in">this</span>.front = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-keyword">return</span> _queue[<span class="hljs-number">0</span>]
  &#125;
  <span class="hljs-built_in">this</span>.back = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-keyword">return</span> _queue[_queue.length - <span class="hljs-number">1</span>]
  &#125;
  <span class="hljs-built_in">this</span>.clear = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
    _queue = []
  &#125;
  <span class="hljs-built_in">this</span>.isEmpty = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-keyword">return</span> _queue.length === <span class="hljs-number">0</span>
  &#125;
  <span class="hljs-built_in">this</span>.size = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-keyword">return</span> _queue.length
  &#125;
&#125;
</code></pre>
<h3 data-nodeid="44002">链表</h3>
<p data-nodeid="44003">链表是在存储空间上具有一定优势的线性结构。因为它的有序性是通过指针来实现的，即每个元素都有一个指向下一个元素的指针（链表末端元素可能指向 null），所以它不需要连续的内存空间，从而可以节省内存的占用。例如 React.js 的 Fiber 算法就是基于链表实现的。</p>
<p data-nodeid="44004">下面的代码实现了一个基础的链表，包括链表的查找、新增和删除功能。</p>
<pre class="lang-javascript" data-nodeid="44005"><code data-language="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">LinkedList</span>(<span class="hljs-params"></span>) </span>&#123;
&nbsp; <span class="hljs-keyword">var</span> head = &#123;
&nbsp; &nbsp; <span class="hljs-attr">value</span>: <span class="hljs-string">'head'</span>,
&nbsp; &nbsp; <span class="hljs-attr">next</span>: <span class="hljs-literal">null</span>
&nbsp; &#125;
&nbsp; <span class="hljs-built_in">this</span>.find = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>) </span>&#123;
&nbsp; &nbsp; <span class="hljs-keyword">var</span> currNode = head
&nbsp; &nbsp; <span class="hljs-keyword">while</span> (currNode.value !== item) &#123;
&nbsp; &nbsp; &nbsp; currNode = currNode.next
&nbsp; &nbsp; &#125;
&nbsp; &nbsp; <span class="hljs-keyword">return</span> currNode
&nbsp; &#125;
&nbsp; <span class="hljs-built_in">this</span>.insert = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value, pre</span>) </span>&#123;
&nbsp; &nbsp; <span class="hljs-keyword">var</span> newNode = &#123;
&nbsp; &nbsp; &nbsp; value,
&nbsp; &nbsp; &nbsp; <span class="hljs-attr">next</span>: <span class="hljs-literal">null</span>
&nbsp; &nbsp; &#125;
&nbsp; &nbsp; <span class="hljs-keyword">var</span> currNode = <span class="hljs-built_in">this</span>.find(pre)
&nbsp; &nbsp; newNode.next = currNode.next
&nbsp; &nbsp; currNode.next = newNode
&nbsp; &#125;
&nbsp; <span class="hljs-built_in">this</span>.remove = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) </span>&#123;
&nbsp; &nbsp; <span class="hljs-keyword">var</span> prevNode = <span class="hljs-built_in">this</span>.findPrev(item)
&nbsp; &nbsp; <span class="hljs-keyword">var</span> currNode = <span class="hljs-built_in">this</span>.find(item)
&nbsp; &nbsp; <span class="hljs-keyword">if</span> (prevNode.next !== <span class="hljs-literal">null</span>) &#123;
&nbsp; &nbsp; &nbsp; prevNode.next = prevNode.next.next
&nbsp; &nbsp; &nbsp; currNode.next = <span class="hljs-literal">null</span>
&nbsp; &nbsp; &#125;
&nbsp; &#125;
&nbsp; <span class="hljs-built_in">this</span>.findPrev = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) </span>&#123;
&nbsp; &nbsp; <span class="hljs-keyword">var</span> currNode = head
&nbsp; &nbsp; <span class="hljs-keyword">while</span> (currNode.next !== <span class="hljs-literal">null</span> &amp;&amp; currNode.next.value !== item) &#123;
&nbsp; &nbsp; &nbsp; currNode = currNode.next
&nbsp; &nbsp; &#125;
&nbsp; &nbsp; <span class="hljs-keyword">return</span> currNode
&nbsp; &#125;
&#125;
</code></pre>
<p data-nodeid="44006">栈、队列由于操作受限，无法像数组一样通过下标来访问，查找某个元素时只能逐个进行操作，操作效率并不算高。链表由于指针的存在，使得在操作效率方面有很大的提升空间。</p>
<p data-nodeid="44007">从指针的方向上考虑，既可以单向也可以双向，那么就可以形成具有两个指针的双向链表，还可以让指针的头尾相连，形成双向循环链表。在一个双向循环链表中查找元素，就可以同时往两个方向查找，这使得在查找速度方面会略优于单向循环链表。libuv 中就使用到了双向循环链表来管理任务。</p>
<p data-nodeid="44008">从指针的数量上考虑，还可以通过增加指针的方式来提升操作效率，跳跃表就是这样一种基于链表的数据结构。</p>
<p data-nodeid="44009">下面是一个跳跃表实现原理的例子，在一个链表中建立了 3 层指针。最下一层指针，跨 1 个元素链接；中间一层指针，跨 2 个元素链接；上层指针，跨 4 个元素链接。</p>
<pre class="lang-plain" data-nodeid="44010"><code data-language="plain">1----------&gt;5----------&gt;9-&gt;null
1----&gt;3----&gt;5----&gt;7----&gt;9-&gt;null
1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7-&gt;8-&gt;9-&gt;null
</code></pre>
<p data-nodeid="44011">假设现在要在链表中找到数字 8，对于简单链表而言，需要查找 8 次。而在上述跳跃表中，只需要 5 步：</p>
<ol data-nodeid="44012">
<li data-nodeid="44013">
<p data-nodeid="44014">使用上层指针，找到 5，8 比 5 大，继续；</p>
</li>
<li data-nodeid="44015">
<p data-nodeid="44016">继续使用上层指针，找到 9，8  比 9 小，回退到 5，并且指针层数下移；</p>
</li>
<li data-nodeid="44017">
<p data-nodeid="44018">使用中层指针，找到 7，8 比 7 大，继续；</p>
</li>
<li data-nodeid="44019">
<p data-nodeid="44020">使用中层指针，找到 9，8 比 9 小，回退到 7，并且指针层数下移；</p>
</li>
<li data-nodeid="44021">
<p data-nodeid="44022">使用下层指针，找到 8。</p>
</li>
</ol>
<p data-nodeid="44023">总的来说，跳跃表通过增加链表元素的冗余指针，使用了空间换时间的方式来提升操作效率。在著名的缓存数据库 Redis 中就使用了跳跃表这种数据结构。</p>
<h3 data-nodeid="44024">树</h3>
<p data-nodeid="44025">树型数据结构在前面的课程中已多次提到，比如（虚拟）DOM 树、抽象语法分析树，大家对于它应该都不陌生。总结起来，树就是有限节点组成一个具有层次关系的集合，因为它看起来非常像一棵倒着生长的树，根朝上叶朝下，所以命名为“树”。</p>
<p data-nodeid="44026">树根据结构不同，可以分为很多类，比如有序树（树中任意节点，比如，点的子节点之间有顺序关系）、二叉树（每个节点最多有 2 个子树）、满二叉树（除最后一层所有节点都有两个子节点）等。</p>
<p data-nodeid="44027">其中，二叉树是最简单且最基础的树。说它简单，是因为每个节点至多包含两个子节点；说它基础，是因为二叉树可以延伸出一些子类，比如二叉搜索树（BST）、平衡二叉搜索树（AVL）、红黑树（R/B Tree）等。</p>
<p data-nodeid="44028">所以我们重点分析二叉树的查询操作——遍历。</p>
<p data-nodeid="44029">树的遍历操作分为两类：<strong data-nodeid="44120">深度遍历</strong>和<strong data-nodeid="44121">广度遍历</strong>，其中深度遍历按照遍历根节点的顺序不同又可以分为 3 类：先序遍历、中序遍历和后序遍历。它们的遍历顺序如下：</p>
<ul data-nodeid="44030">
<li data-nodeid="44031">
<p data-nodeid="44032">先序遍历，根节点→左子树→右子树</p>
</li>
<li data-nodeid="44033">
<p data-nodeid="44034">中序遍历，左子树→根节点→右子树</p>
</li>
<li data-nodeid="44035">
<p data-nodeid="44036">后序遍历，左子树→右子树→根节点</p>
</li>
<li data-nodeid="44037">
<p data-nodeid="44038">广度遍历，逐层从左至右访问</p>
</li>
</ul>
<p data-nodeid="44039">实现深度遍历最简单的方式就是通过递归，下面是具体代码：</p>
<pre class="lang-plain" data-nodeid="44040"><code data-language="plain">// 先序遍历，根-&gt;左-&gt;右
function preOrder(node, result=[]) &#123;
  if (!node) return
  result.push(node.value);
  preOrder(node.left, result);
  preOrder(node.right, result);
  return result;
&#125;
// 中序遍历，左-&gt;根-&gt;右
function inOrder(node, result=[]) &#123;
  if (!node) return
  inOrder(node.left, result);
  result.push(node.value);
  inOrder(node.right, result);
  return result;
&#125;
// 后序遍历，左-&gt;右-&gt;根
function postOrder(node, result=[]) &#123;
  if (!node) return
  postOrder(node.left, result);
  postOrder(node.right, result);
  result.push(node.value);
  return result;
&#125;
</code></pre>
<p data-nodeid="44041">广度优先遍历的实现会稍稍复杂一些，因为每次访问节点时都要回溯到上一层的父节点，通过其指针进行访问。但每一层都是从左至右的遍历顺序，这种操作方式很符合队列的先进先出原则，所以可以通过队列来缓存遍历的节点，具体代码如下所示：</p>
<pre class="lang-javascript" data-nodeid="44042"><code data-language="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">breadthOrder</span>(<span class="hljs-params">node</span>) </span>&#123;
&nbsp; <span class="hljs-keyword">if</span>(!node) <span class="hljs-keyword">return</span>
&nbsp; <span class="hljs-keyword">var</span> result = []
&nbsp; <span class="hljs-keyword">var</span> queue = []
&nbsp; queue.push(node)
&nbsp; <span class="hljs-keyword">while</span>(queue.length !== <span class="hljs-number">0</span>) &#123;
&nbsp; &nbsp; node = queue.shift()
&nbsp; &nbsp; result.push(node.value)
&nbsp; &nbsp; <span class="hljs-keyword">if</span>(node.left) queue.push(node.left)
&nbsp; &nbsp; <span class="hljs-keyword">if</span> (node.right) queue.push(node.right)
&nbsp; &#125;
&nbsp; <span class="hljs-keyword">return</span> result
&#125;
</code></pre>
<h3 data-nodeid="44043">总结</h3>
<p data-nodeid="44044">这一课时我们介绍了和前端最为贴合的 5 种数据结构，包括数组、栈、队列、链表、树。讲解数组时，JavaScript 引擎通过两种数据结构实现数组，包括 FixedArray 和 HashTable，FixedArray 在时间上有优势，而 HashTable 在空间上更有优势。</p>
<p data-nodeid="44045">栈和队列都是操作受限的数据结构，底层实现都可以借助数组，分别遵循 FILO 和 FIFO 原则。链表由于采用指针连接元素节点，所以可以使用不连续的内存地址，在空间上更有优势。链表有一些变种，包括循环链表、双向链表、双向循环链表及跳跃表，其中跳跃表通过增加指针，达到了空间换时间的效果，能增加查找效率。</p>
<p data-nodeid="44046">树是应用最广泛的非线性结构，子类很多，其中二叉树最为重要，对于其遍历方式需要重点掌握。</p>
<p data-nodeid="44047">对于前端工程师而言，数据结构的实用性是明显高于算法的，而且也是算法的基石。所以为了帮助大家巩固和理解，对于每种数据结构都精选了一道算法题：</p>
<ul data-nodeid="44048">
<li data-nodeid="44049">
<p data-nodeid="44050">数组，<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/3sum/" data-nodeid="44136">三数之和</a></p>
</li>
<li data-nodeid="44051">
<p data-nodeid="44052">栈，<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/valid-parentheses/" data-nodeid="44140">有效的括号</a></p>
</li>
<li data-nodeid="44053">
<p data-nodeid="44054">队列，<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/" data-nodeid="44144">滑动窗口最大值</a></p>
</li>
<li data-nodeid="44055">
<p data-nodeid="44056">链表，<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/linked-list-cycle/" data-nodeid="44148">环形链表</a></p>
</li>
<li data-nodeid="44057">
<p data-nodeid="44058">树，<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/same-tree/" data-nodeid="44152">相同的树</a></p>
</li>
</ul>
<p data-nodeid="44059"><a target="_blank" rel="noopener" href="https://github.com/yalishizhude/course/tree/master/02" data-nodeid="44155">可点击这里查看答案</a>。</p>
<p data-nodeid="44742" class="">OK，这一课时就讲到这里啦，如果你觉得这个内容对你有所启发，欢迎分享给你的朋友或者同事探讨学习。下一课时我将分享算法相关的内容，记得按时来听课哈。</p>

<hr>
<h3 id="精选评论"><a href="#精选评论" class="headerlink" title="精选评论"></a>精选评论</h3><h5 id="贵："><a href="#贵：" class="headerlink" title="**贵："></a>**贵：</h5><blockquote>
<p>数据结构和算法理解起来虽然有一定难度，但是当理解并能付诸实践解决问题时，那种感觉真的是太美妙了，也许这就是编程的魅力。</p>
</blockquote>
<h5 id="杰："><a href="#杰：" class="headerlink" title="*杰："></a>*杰：</h5><blockquote>
<p>单链表删除用一次遍历可以的，prev拿到之后，prev.next就是待删除的元素，再find一次有点浪费🤔</p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-讲师回复："><a href="#amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; 嗯，通过 prevNode 来获取 currentNode 也是可以的，但从算法时间复杂度的角度来考虑，优化提升并不明显~</p>
</blockquote>
<h5 id="忠："><a href="#忠：" class="headerlink" title="*忠："></a>*忠：</h5><blockquote>
<p>栈、队列由于操作受限，无法像数组一样通过下标来访问这里是不是写错了，应该是链biao操作受限</p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-1"><a href="#amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-1" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; 感觉你很可能把队列和数组混淆了，虽然说队列大多数情况下可以用数组来实现，但并不等同于数组，比如可以用数据库表、用链表来实现一个队列，这时候是不能通过下标来访问的。</p>
</blockquote>
<h5 id="民："><a href="#民：" class="headerlink" title="**民："></a>**民：</h5><blockquote>
<p>学无止境啊</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/11/02/%E5%B8%B8%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%86%E8%A7%A3%E5%A4%9A%E5%B0%91/" data-id="claxeera30018v8w16h0q8gh9" data-title="常用的数据结构了解多少" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-谈性能优化到底在谈什么" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/11/02/%E8%B0%88%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%88%B0%E5%BA%95%E5%9C%A8%E8%B0%88%E4%BB%80%E4%B9%88/" class="article-date">
  <time class="dt-published" datetime="2022-11-02T02:47:48.000Z" itemprop="datePublished">2022-11-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/11/02/%E8%B0%88%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%88%B0%E5%BA%95%E5%9C%A8%E8%B0%88%E4%BB%80%E4%B9%88/">谈性能优化到底在谈什么</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p data-nodeid="1245" class="">性能是前端领域关注度非常高的话题，因为页面性能的好坏会直接影响用户体验。为了不断提升用户体验，前端工程师往往会对页面性能不断改进，而这个改进的过程就叫性能优化。这一讲我们就详细探究性能优化相关的内容。</p>
<h3 data-nodeid="998">性能指标</h3>
<p data-nodeid="1743">什么是性能？性能是指程序的运行速度，而前端性能是指页面的响应速度，提到速度必然离不开一个变量，那就是时间。所以我们会看到性能指标都是以时间为单位来测量的。</p>
<p data-nodeid="1744" class="">前端性能的指标有很多，本讲从是否可以通过浏览器采集上报，是否由权威组织或大型公司提出，以及是否严重影响用户体验这 3 个方面考虑，选取了下面一些重要的指标。</p>
<h4 data-nodeid="1000">首屏绘制（First Paint，FP）</h4>
<p data-nodeid="1001">首屏绘制由 W3C 标准 <a target="_blank" rel="noopener" href="https://www.w3.org/TR/paint-timing/#sec-paint-timing" data-nodeid="1086">Paint Timing</a> 中提出。</p>
<p data-nodeid="1002">首屏绘制时间是指从开始加载到浏览器首次绘制像素到屏幕上的时间，也就是页面在屏幕上首次发生视觉变化的时间。注意首屏绘制不包括默认的背景绘制，但包括非默认的背景绘制。由于首次绘制之前网页呈现默认背景白色，所以也俗称“<strong data-nodeid="1093">白屏时间</strong>”。</p>
<p data-nodeid="1003">获取到这个指标值也非常简单，在 HTML5 下可以通过 performance API 来获取，具体代码如下：</p>
<pre class="lang-java" data-nodeid="1004"><code data-language="java">performance.getEntriesByType(<span class="hljs-string">'paint'</span>)[<span class="hljs-number">0</span>] 
<span class="hljs-comment">/* 
&#123; 
  duration:&nbsp;0, 
  entryType:&nbsp;"paint", 
  name:&nbsp;"first-paint", 
  startTime:&nbsp;197.58499998715706, 
&#125; 
*/</span>
</code></pre>
<p data-nodeid="1005">这里通过 performance.getEntriesByType() 函数返回了一个 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceEntry" data-nodeid="1098">PerformanceEntry</a> 实例组成的数组，其中，duration 为该事件的耗时，entryType 为性能指标实例的类型，name 为指标名称，startTime 为指标采集时间。</p>
<h4 data-nodeid="1006">首屏内容绘制（First Contentful Paint，FCP）</h4>
<p data-nodeid="1007">首屏内容绘制由 W3C 标准 <a target="_blank" rel="noopener" href="https://www.w3.org/TR/paint-timing/#sec-paint-timing" data-nodeid="1104">Paint Timing</a> 中提出。浏览器首次绘制来自 DOM 的内容时间，这个内容可以是文字、图片（也包括背景图片）、非空白的 canvas 和 svg。</p>
<p data-nodeid="1008">由于是 W3C 标准提出的，所以 Performance API 也提供了这个指标值，具体代码如下：</p>
<pre class="lang-java" data-nodeid="1009"><code data-language="java">performance.getEntriesByType(<span class="hljs-string">'paint'</span>)[<span class="hljs-number">1</span>] 
<span class="hljs-comment">/*
&#123; 
  duration:&nbsp;0, 
  entryType:&nbsp;"paint", 
  name:&nbsp;"first-contentful-paint", 
  startTime:&nbsp;797.8649999859044 
&#125; 
*/</span>
</code></pre>
<p data-nodeid="1010">和获取 FP 值的唯一区别就在于通过 performance.getEntriesByType() 函数获取到 PerformanceEntry 实例数组的下标值不一样，FP 为第 1 个元素，FCP 为第 2 个元素。</p>
<p data-nodeid="1011">FCP 有时候会和 FP 时间相同，也可能晚于 FP。这也很好理解，FP 只需要满足“开始绘制”这一个条件就可以了，而 FCP 还要满足第二个条件，那就是“绘制的像素有内容”。</p>
<h4 data-nodeid="1012">可交互时间（Time to Interactive，TTI）</h4>
<p data-nodeid="1013">可交互时间由 <a target="_blank" rel="noopener" href="https://wicg.io/" data-nodeid="1113">Web 孵化器社区组（WICG）</a>提出，是指网页在视觉上都已渲染出了，浏览器可以响应用户的操作了。虽然理解起来比较简单，但实际测量起来要考虑两个条件：第一个条件是主线程的长任务（长任务是指耗时超过 50 ms）执行完成后，第二个条件是随后网络静默时间达到 5 秒，这里的静默时间是指请求数不超过 2 个，&nbsp;排除失败的资源请求和未使用 GET 方法进行的网络请求。</p>
<p data-nodeid="1014">具体参考下面这张图片。</p>
<p data-nodeid="1015"><img src="https://s0.lgstatic.com/i/image/M00/41/74/CgqCHl81EGeAdM7rAACIkBOl2EA380.png" alt="image (6).png" data-nodeid="1118"></p>
<div data-nodeid="1016"><p style="text-align:center">TTI 示意图</p></div>
<p data-nodeid="1017">从上图可以看出，主线程第二个橙色部分的长任务执行完成后，主线程执行了两个任务之后发起了一个新的网络请求，但此时仍处于静默状态。所以 TTI 就是第二个长任务结束后的时间。</p>
<p data-nodeid="1018">TTI 测量可以使用 Google 提供的模块 <a target="_blank" rel="noopener" href="https://www.npmjs.com/package/tti-polyfill" data-nodeid="1123">tti-polyfill</a>，示例代码如下：</p>
<pre class="lang-java" data-nodeid="1019"><code data-language="java"><span class="hljs-keyword">import</span>&nbsp;ttiPolyfill&nbsp;from&nbsp;<span class="hljs-string">'tti-polyfill'</span>; 


<p>ttiPolyfill.getFirstConsistentlyInteractive(opts).then((tti)&amp;nbsp;&#x3D;&gt;&amp;nbsp;&#123;<br>&amp;nbsp;&amp;nbsp;…<br>&#125;);<br></code></pre></p>
<p data-nodeid="1020">通过调用模块提供的 getFirstConsistentlyInteractive() 函数即可返回一个 Promise 对象，如果当前浏览器支持相关测量方法，则返回 TTI 值，否则返回 null。</p>
<h4 data-nodeid="1021">总阻塞时间（Total Blocking Time，TBT）</h4>
<p data-nodeid="1022">总阻塞时间由 W3C 标准 <a target="_blank" rel="noopener" href="https://www.w3.org/TR/2017/WD-longtasks-1-20170907/" data-nodeid="1130">Long Tasks API 1</a> 提出，是指阻塞用户响应（比如键盘输入、鼠标点击）的所有时间。指标值是将 FCP 之后一直到 TTI 这段时间内的阻塞部分时间总和，阻塞部分是指长任务执行时间减去 50 毫秒。下面是一张来自 web.dev 的示意图。</p>
<p data-nodeid="1023"><img src="https://s0.lgstatic.com/i/image/M00/41/69/Ciqc1F81EIaADZ4LAAAZKr_3VDY865.png" alt="image (7).png" data-nodeid="1134"></p>
<p data-nodeid="1024">上图是主线程执行的时间轴，有 5 个任务，其中 3 个是长任务，因为它们的持续时间超过 50 毫秒。将这 3 个长任务分别减去 50 毫秒之后求和，得到 TBT 值为 345 毫秒。获取长任务耗时的方式如下：</p>
<pre class="lang-javascript" data-nodeid="1025"><code data-language="javascript"><span class="hljs-keyword">var</span> observer = <span class="hljs-keyword">new</span> PerformanceObserver(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">list</span>) </span>&#123; 
&nbsp; <span class="hljs-keyword">var</span> perfEntries = list.getEntries(); 
&nbsp; <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; perfEntries.length; i++) &#123; 
&nbsp; &nbsp; <span class="hljs-built_in">console</span>.log(perfEntries[i].toJSON()) 
  <span class="hljs-comment">/* 
  &#123; 
    attribution:&nbsp;[TaskAttributionTiming]， 
    duration:&nbsp;6047.770000004675， 
    entryType:&nbsp;"longtask"， 
    name:&nbsp;"self"， 
    startTime:&nbsp;22.444999995059334 
  &#125; 
  */</span> 
&nbsp; &#125; 
&#125;); 
observer.observe(&#123; 
&nbsp; <span class="hljs-attr">entryTypes</span>: [<span class="hljs-string">"longtask"</span>] 
&#125;);
</code></pre>
<p data-nodeid="1026">首先通过 PerformanceObserver 函数构造一个性能监测实例，通过回调函数参数的 getEntries() 函数来获取 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceEntry" data-nodeid="1139">PerformanceEntry</a> 实例数组，每个实例对应一个长任务。同时要指定监测实例的实体类型为“longtask”。</p>
<h4 data-nodeid="1027">最大内容绘制（Largest Contentful Paint，LCP)</h4>
<p data-nodeid="1028">最大内容绘画指的是视口内可见的最大图像或文本块的绘制时间。测量这个指标的值和 TBT 相似，不同的是将实体类型改为“largest-contentful-paint”。</p>
<p data-nodeid="1029">下面是对应的监测代码：</p>
<pre class="lang-java" data-nodeid="1030"><code data-language="java"><span class="hljs-keyword">var</span> observer = <span class="hljs-keyword">new</span> PerformanceObserver(function (list) &#123; 
&nbsp; <span class="hljs-keyword">var</span> perfEntries = list.getEntries(); 
&nbsp; <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; perfEntries.length; i++) &#123; 
&nbsp; &nbsp; console.log(perfEntries[i].toJSON()) 
    <span class="hljs-comment">/* 
    &#123; 
      duration:&nbsp;0, 
      element:&nbsp;img, 
      entryType:&nbsp;"largest-contentful-paint", 
      id:&nbsp;"", 
      loadTime:&nbsp;274.864, 
      name:&nbsp;"", 
      renderTime:&nbsp;0, 
      size:&nbsp;2502, 
      startTime:&nbsp;274.864, 
           url:&nbsp;"https://www.google.com/images/branding/googlelogo/1x/googlelogo_color_272x92dp.png" 
      &#125; 
    */</span> 
&nbsp; &#125; 
&#125;); 
observer.observe(&#123;entryTypes: [<span class="hljs-string">'largest-contentful-paint'</span>]&#125;);
</code></pre>
<h3 data-nodeid="1031">统计方式</h3>
<p data-nodeid="1032">虽然我们可以通过一些方式来精确地采集性能指标，但不同的用户、不同的环境采集同一指标值会有所差异。所以通常需要对大量采集的性能指标数据进行统计才能用来量化。</p>
<h4 data-nodeid="1033">平均值统计</h4>
<p data-nodeid="1034">平均值统计应该是大家最容易想到的统计方法，将所有用户产生的性能指标值收集起来，然后对这些数据取平均值，最终得到平均耗时数据。这种统计方式最大的问题就是容易受极值影响，比如新闻里面说的腾讯员工月薪 8 万，这显然是不现实的，这就是被平均的结果。</p>
<h4 data-nodeid="1035">百分位数统计</h4>
<p data-nodeid="1036">百分位数统计可以解决极值问题。百分位数是对应于百分位的实际数值，比如第 70 百分位数：将数据从小到大排列，处于第 70% 的数据称为 70 分位数，表示 70% 的性能数据均小于等于该值，那剩下的 30% 的数据均大于等于该值了。</p>
<p data-nodeid="1037">百分位数的好处在于，对于性能需求不同的页面或应用，可以设置不同的百分位数。对性能要求越高，使用越大的百分位数。</p>
<p data-nodeid="1038">比如在追求极致性能的情况下，要求 99% 的用户都要小于 3 秒，我们看页面加载时长时候就应该看 99 分位数。而某些重要程度比较低的页面，可以只要求 50% 的用户页面加载时长小于 3 秒，那么对应的就是 50 分位数，也称<strong data-nodeid="1156">中位数</strong>。</p>
<h3 data-nodeid="1039">优化思路</h3>
<p data-nodeid="1040">有了性能指标和统计方式之后，就可以正式开始针对不同的指标值进行优化了。前端性能优化一般可以从两个方向入手：<strong data-nodeid="1167">加载性能优化</strong>和<strong data-nodeid="1168">渲染性能优化</strong>。</p>
<p data-nodeid="1041">虽然不同方向的优化手段不同，但大体上都遵循两个思路：<strong data-nodeid="1178">做减法</strong>和<strong data-nodeid="1179">做除法</strong>。做减法是直接减少耗时操作或资源体积，做除法是在耗时操作和资源体积无法减少的情况下，对其进行拆分处理或者对不可拆分的内容进行顺序调换。</p>
<p data-nodeid="1042">下面来进行举例分析。加载性能的优化手段中，做减法的有：</p>
<ul data-nodeid="5355">
<li data-nodeid="5356">
<p data-nodeid="5357" class=""><strong data-nodeid="5366">采用 gzip 压缩</strong>，典型的减少资源的传输体积；</p>
</li>
<li data-nodeid="5358">
<p data-nodeid="5359"><strong data-nodeid="5371">使用缓存</strong>，强制缓存可以减少浏览器请求次数，而协商缓存可以减少传输体积；</p>
</li>
<li data-nodeid="5360">
<p data-nodeid="5361">使用雪碧图，减少浏览器请求次数。</p>
</li>
</ul>







<p data-nodeid="1050">做除法的有：</p>
<ul data-nodeid="1051">
<li data-nodeid="1052">
<p data-nodeid="1053"><strong data-nodeid="1197">HTTP2 多路复用</strong>，把多个请求拆分成二进制帧，并发传输；</p>
</li>
<li data-nodeid="1054">
<p data-nodeid="1055"><strong data-nodeid="1202">懒加载</strong>，将 Web 应用拆分成不同的模块或文件，按需加载；</p>
</li>
<li data-nodeid="1056">
<p data-nodeid="1057"><strong data-nodeid="1207">把 script 标签放到 body 底部</strong>，通过调整顺序来控制渲染时间。</p>
</li>
</ul>
<p data-nodeid="1058">而在渲染性能优化的手段中，做减法的有：</p>
<ul data-nodeid="1059">
<li data-nodeid="1060">
<p data-nodeid="1061"><strong data-nodeid="1213">避免重排与重绘</strong>，减少渲染引擎的绘制；</p>
</li>
<li data-nodeid="1062">
<p data-nodeid="1063"><strong data-nodeid="1218">防抖操作</strong>，减少函数调用或请求次数；</p>
</li>
<li data-nodeid="1064">
<p data-nodeid="1065"><strong data-nodeid="1223">减少 DOM 操作</strong>，减少渲染引擎和脚本引擎的切换，同时也减少渲染引擎绘制。</p>
</li>
</ul>
<p data-nodeid="1066">做除法的有：</p>
<ul data-nodeid="1067">
<li data-nodeid="1068">
<p data-nodeid="1069"><strong data-nodeid="1229">骨架屏</strong>，将页面内容进行拆分，调整不同部分的显示顺序；</p>
</li>
<li data-nodeid="1070">
<p data-nodeid="1071"><strong data-nodeid="1234">使用 Web Worker</strong>，将一些长任务拆分出来，放到 Web Worker 中执行；</p>
</li>
<li data-nodeid="1072">
<p data-nodeid="1073"><strong data-nodeid="1239">React Fiber</strong>，将同步视图的任务进行拆分，可调换顺序，可暂停。</p>
</li>
</ul>
<p data-nodeid="1074">前端性能优化的方式还有很多，我们学习的重点不在于将这些优化方式一一记住，而是掌握优化的思路，在不同的方向上，对不同步骤优先考虑做减法，然后再考虑做除法。</p>
<h3 data-nodeid="1075">总结</h3>
<p data-nodeid="1076">前端性能优化实际上包括两个步骤，即量化和优化。在量化过程中，先采集特定的指标，本课时提到了 5 个比较重要的指标，包括首屏绘制、首屏内容绘制、可交互时间、总阻塞时间、最大内容绘制；然后对不同用户产生的指标值进行统计，这里推荐使用百分位数统计法，对于不同性能需求的页面设置不同的百分位数。</p>
<p data-nodeid="1077">在优化过程中，要根据性能指标统计结果进行优化，可通过做减法和做除法的思路分别对加载性能和渲染性能进行优化。</p>
<p data-nodeid="1078" class="">最后布置一道思考题：你还使用过哪些性能优化的指标？欢迎在留言区分享你的答案。</p>

<hr>
<h3 id="精选评论"><a href="#精选评论" class="headerlink" title="精选评论"></a>精选评论</h3><h5 id="Mr-W："><a href="#Mr-W：" class="headerlink" title="Mr.W："></a>Mr.W：</h5><blockquote>
<p>性能数据采集有没有好的工具或者平台？</p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-讲师回复："><a href="#amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; 如果是云上环境，云服务厂商应该有类似服务，比如阿里云的 ARMS、aws 的cloudwatch；收费的也有 听云、监控宝；开源的有 zanePerfor 和 web-monitor</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/11/02/%E8%B0%88%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%88%B0%E5%BA%95%E5%9C%A8%E8%B0%88%E4%BB%80%E4%B9%88/" data-id="claxeera8001mv8w13kww4kct" data-title="谈性能优化到底在谈什么" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-详解组件通信之状态管理" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/11/02/%E8%AF%A6%E8%A7%A3%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E4%B9%8B%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/" class="article-date">
  <time class="dt-published" datetime="2022-11-02T02:46:53.000Z" itemprop="datePublished">2022-11-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/11/02/%E8%AF%A6%E8%A7%A3%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E4%B9%8B%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/">详解组件通信之状态管理</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p data-nodeid="2155">在第 18 讲中我们详细分析了组件的 3 个要素：数据模型、渲染和视图。虽然通过组件化的方式能够有效地将 Web 页面进行解耦，但另一个问题也随之出现，组件之间如何进行通信。这一讲我们就来分析组件化 Web 应用中的组件通信问题。</p>


<h3 data-nodeid="1316">全局状态</h3>
<p data-nodeid="1317">对于父子组件通信，框架都已给出可行的解决方案：父组件通过 prop(s) 属性向子组件传参，子组件通过自定义事件来向父组件发送消息。而非父子组件之间，如果通过层层传递，这个过程就会变得相当麻烦。最简单的直接解决方式就是设置一个供多个组件共享的全局变量，但如果直接使用全局变量会存在一些问题，比如：</p>
<ul data-nodeid="1318">
<li data-nodeid="1319">
<p data-nodeid="1320">可能多个组件会同时修改变量值，这个过程无法追踪，调试问题也会变得很麻烦；</p>
</li>
<li data-nodeid="1321">
<p data-nodeid="1322">当全局变量值发生变化时，如何通知引用它的每一个组件？</p>
</li>
</ul>
<h4 data-nodeid="1323">1.状态管理库的特点</h4>
<p data-nodeid="1324">针对这些问题，一些状态管理库出现了，我们重点分析用于 Vue 的 Vuex 和用于 React 的 Redux，所谓的“状态”，就是不同组件之间传递和引用的数据模型。状态管理库具有 3 个特点：<strong data-nodeid="1386">可预测、中心化、可调式</strong>。</p>
<p data-nodeid="1325"><strong data-nodeid="1390">可预测</strong></p>
<p data-nodeid="1326">可预测性指的是，如果状态 A 经过操作 B 会生成状态 C，那么不论在任何时刻、任何平台（客户端、服务端、App 端），只要 A 和 B 不发生变化，就能得到同样的结果 C。比如下面代码中的函数就是不可预测的：</p>
<pre class="lang-javascript" data-nodeid="1327"><code data-language="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getTime</span>(<span class="hljs-params"></span>) </span>&#123; 
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getTime() 
&#125; 
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getDom</span>(<span class="hljs-params">id</span>) </span>&#123; 
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">document</span>.getElementById(id) 
&#125; 
</code></pre>
<p data-nodeid="1328">getTime() 函数在不同时刻会得到不同的值，getDom() 函数只能在网页上运行，所以结果都是不可预测的。而下面的函数都是可预测的：</p>
<pre class="lang-javascript" data-nodeid="1329"><code data-language="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">nextDay</span>(<span class="hljs-params">time</span>) </span>&#123; 
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(time + <span class="hljs-number">1000</span> * <span class="hljs-number">60</span> * <span class="hljs-number">60</span> * <span class="hljs-number">24</span>) 
&#125; 
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">filter</span>(<span class="hljs-params">a, b</span>) </span>&#123; 
  <span class="hljs-keyword">return</span> a + b 
&#125; 
</code></pre>
<p data-nodeid="1330">可预测性只是纯函数的优势之一，后面我们在讲函数式编程的时候再详细介绍纯函数相关的内容。</p>
<p data-nodeid="1331"><strong data-nodeid="1397">中心化</strong></p>
<p data-nodeid="1332">Vuex 和 Redux 都只会构建一棵中心化的状态树，所有的状态数据都会作为子属性挂载到这棵树上，非常有默契。</p>
<p data-nodeid="1333"><strong data-nodeid="1402">可调式</strong></p>
<p data-nodeid="1334">可调式指的是可以利用浏览器插件，对状态的变化和使用情况进行追踪和调试。Vuex 提供了 <a target="_blank" rel="noopener" href="https://chrome.google.com/webstore/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpd" data-nodeid="1406">Vue.js devtools</a>插件，Redux 也提供了 <a target="_blank" rel="noopener" href="https://chrome.google.com/webstore/detail/redux-devtools/lmhkpmbekcpmknklioeibfkpmmfibljd" data-nodeid="1410">Redux DevTools</a>。</p>
<h4 data-nodeid="1335">2.状态管理库实现原理</h4>
<p data-nodeid="1336">了解状态管理库特性之后，我们再对<strong data-nodeid="1422">写</strong>和<strong data-nodeid="1423">读</strong>这两个核心操作的源码进行分析。</p>
<p data-nodeid="1337"><strong data-nodeid="1427">Vuex（3.5.1）中修改状态</strong></p>
<p data-nodeid="1338">下面是一段简单的示例代码，从代码中我们可以看到，通过执行 store.commit('increment') 来调用 mutation 中的 increment() 函数，从而达到修改状态的操作。所以我们来分析 commit() 函数的实现原理。</p>
<pre class="lang-javascript" data-nodeid="1339"><code data-language="javascript"><span class="hljs-keyword">const</span> store = <span class="hljs-keyword">new</span> Vuex.Store(&#123; 
  <span class="hljs-attr">state</span>: &#123; 
    <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> 
  &#125;, 
  <span class="hljs-attr">mutations</span>: &#123; 
    increment(state,&nbsp;payload)&nbsp;&#123; 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;state.count&nbsp;+=&nbsp;payload 
&nbsp;&nbsp;&nbsp;&nbsp;&#125; 
  &#125; 
&#125;) 
store.commit(<span class="hljs-string">'increment'</span>, <span class="hljs-number">1</span>) 
<span class="hljs-built_in">console</span>.log(store.state.count) <span class="hljs-comment">// -&gt; 1 </span>
</code></pre>
<p data-nodeid="1340">commit 部分源码如下所示，从代码中可以看出，首先通过 mutations[type] 获取 store 初始化时 mutations 对象下的属性（以下简称为“mutations”），在示例代码中，type 的值为 increment。因为 Vuex 提供了模块机制，不同模块下可能出现相同名称的 mutations，所以保存为数组的形式。</p>
<p data-nodeid="1341">然后调用 _withCommit() 函数，将当前变量 _committing 赋值为 true，执行完回调函数后再还原为之前的值。这个回调函数则会遍历执行 mutations。其中 payload 为调用 commit 时传入的参数，对应示例代码中的数值 1。</p>
<pre class="lang-javascript" data-nodeid="1342"><code data-language="javascript">Store.prototype.commit = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">commit</span> (<span class="hljs-params">_type, _payload, _options</span>) </span>&#123; 
&nbsp; <span class="hljs-keyword">var</span> this$<span class="hljs-number">1</span> = <span class="hljs-built_in">this</span>; 
  ... 
&nbsp; var mutation = &#123; <span class="hljs-attr">type</span>: type, <span class="hljs-attr">payload</span>: payload &#125;; 
&nbsp; <span class="hljs-keyword">var</span> entry = <span class="hljs-built_in">this</span>._mutations[type]; 
  ... 
&nbsp; this._withCommit(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123; 
&nbsp; &nbsp; entry.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">commitIterator</span> (<span class="hljs-params">handler</span>) </span>&#123; 
&nbsp; &nbsp; &nbsp; handler(payload); 
&nbsp; &nbsp; &#125;); 
&nbsp; &#125;); 
&nbsp; ... 
&#125;; 
Store.prototype._withCommit = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_withCommit</span> (<span class="hljs-params">fn</span>) </span>&#123; 
&nbsp; <span class="hljs-keyword">var</span> committing = <span class="hljs-built_in">this</span>._committing; 
&nbsp; <span class="hljs-built_in">this</span>._committing = <span class="hljs-literal">true</span>; 
&nbsp; fn(); 
&nbsp; <span class="hljs-built_in">this</span>._committing = committing; 
&#125;; 
</code></pre>
<p data-nodeid="1343"><strong data-nodeid="1446">Vuex（3.5.1）中读取状态</strong></p>
<p data-nodeid="1344">Vuex 在进行初始化的时候会在内部创建一个 Vue 实例，并且赋值给 store._vm 属性，在这个实例中创建了数据模型 $$state，$$state 的初始值即为我们在初始化 store 时的 state 属性，对应示例代码中的对象 {count: 1}。这个 $$state 属性在 mutations 中以及通过 store.state 访问时都会用到。</p>
<pre class="lang-javascript" data-nodeid="1345"><code data-language="javascript">store._vm = <span class="hljs-keyword">new</span> Vue(&#123; 
&nbsp; <span class="hljs-attr">data</span>: &#123; 
&nbsp; &nbsp; <span class="hljs-attr">$$state</span>: state 
&nbsp; &#125;, 
&nbsp; <span class="hljs-attr">computed</span>: computed 
&#125;); 
</code></pre>
<p data-nodeid="1346">然后对原型对象 Store.prototype 的属性 state 进行劫持，当读取 store.state 时将返回 _vm._data.$$state。这样当通过 mutations 修改它的时候，就能即时返回最新的值了。</p>
<pre class="lang-javascript" data-nodeid="1347"><code data-language="javascript"><span class="hljs-built_in">Object</span>.defineProperties( Store.prototype, prototypeAccessors$<span class="hljs-number">1</span> ); 
prototypeAccessors$<span class="hljs-number">1.</span>state.get = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123; 
&nbsp; <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>._vm._data.$$state 
&#125;; 
</code></pre>
<p data-nodeid="1348"><strong data-nodeid="1458">Redux（4.0.5）中修改状态</strong></p>
<p data-nodeid="1349">下面是官方给出的一段简单的 Redux 示例代码，从中可以看到，通过 store.dispatch() 函数来触发状态更新，通过 store.getState() 函数来获取当前状态信息。</p>
<pre class="lang-javascript" data-nodeid="1350"><code data-language="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">counter</span>(<span class="hljs-params">state = <span class="hljs-number">0</span>, action</span>) </span>&#123; 
  <span class="hljs-keyword">switch</span> (action.type) &#123; 
    <span class="hljs-keyword">case</span> <span class="hljs-string">'INCREMENT'</span>: 
      <span class="hljs-keyword">return</span> state + <span class="hljs-number">1</span> 
    <span class="hljs-keyword">case</span> <span class="hljs-string">'DECREMENT'</span>: 
      <span class="hljs-keyword">return</span> state - <span class="hljs-number">1</span> 
    <span class="hljs-attr">default</span>: 
      <span class="hljs-keyword">return</span> state 
  &#125; 
&#125; 
<span class="hljs-keyword">let</span> store = createStore(counter) 
store.subscribe(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(store.getState())) 
store.dispatch(&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">'INCREMENT'</span> &#125;)<span class="hljs-comment">// 1 </span>
store.dispatch(&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">'INCREMENT'</span> &#125;)<span class="hljs-comment">// 2 </span>
store.dispatch(&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">'DECREMENT'</span> &#125;)<span class="hljs-comment">// 1 </span>
</code></pre>
<p data-nodeid="1351">dispatch() 函数是用来分发 action 的，可以把它理解成用于触发数据更新的方法。它的实现非常简单，部分源码如下：</p>
<pre class="lang-javascript" data-nodeid="1352"><code data-language="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dispatch</span>(<span class="hljs-params">action</span>) </span>&#123; 
&nbsp; &nbsp; ... 
    try &#123; 
&nbsp; &nbsp; &nbsp; isDispatching = <span class="hljs-literal">true</span>; 
&nbsp; &nbsp; &nbsp; currentState = currentReducer(currentState, action); 
&nbsp; &nbsp; &#125; <span class="hljs-keyword">finally</span> &#123; 
&nbsp; &nbsp; &nbsp; isDispatching = <span class="hljs-literal">false</span>; 
&nbsp; &nbsp; &#125; 
&nbsp; &nbsp; ... 
&nbsp; &nbsp; return action; 
&#125; 
</code></pre>
<p data-nodeid="1353">dispatch() 函数会以当前的状态 currentState 以及我们定义的动作 action 作为参数来调用 currentReducer() 函数，该函数对应示例代码中的 counter() 函数。</p>
<p data-nodeid="1354"><strong data-nodeid="1465">Redux（4.0.5）中读取状态</strong></p>
<p data-nodeid="1355">getState() 函数的代码实现比较简单，首先判断是否为分发状态，如果是则抛出错误，否则直接返回 currentState，而 currentState 的值在 dispatch() 函数执行时就已经被更新了。</p>
<pre class="lang-javascript" data-nodeid="1356"><code data-language="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getState</span>(<span class="hljs-params"></span>) </span>&#123; 
&nbsp; &nbsp; <span class="hljs-keyword">if</span> (isDispatching) &#123; 
&nbsp; &nbsp; &nbsp; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'You may not call store.getState() while the reducer is executing. '</span> + <span class="hljs-string">'The reducer has already received the state as an argument. '</span> + <span class="hljs-string">'Pass it down from the top reducer instead of reading it from the store.'</span>); 
&nbsp; &nbsp; &#125; 
&nbsp; &nbsp; <span class="hljs-keyword">return</span> currentState; 
&nbsp; &#125; 
</code></pre>
<h3 data-nodeid="1357">其他组件通信方式</h3>
<p data-nodeid="1358">选用状态管理库并不是解决跨组件传递数据的唯一方式，下面再介绍 2 种方式也能提供跨组件通信，以 Vue 为例进行讲解。</p>
<h4 data-nodeid="1359">1.全局上下文</h4>
<p data-nodeid="1360">在 Vue 中，提供了一组 API 用来解决祖先组件与子孙组件的通信问题，那就是 provide 和 inject。provide 可以在祖先组件中指定我们想要提供给子孙组件的数据或方法，而在任何子孙组件中，我们都可以使用 inject 来接收 provide 提供的数据或方法。</p>
<p data-nodeid="1361">下面的示例代码中，根组件通过 provide() 函数将数据模型的属性 o 暴露给子孙组件，子孙组件则通过 inject 属性来声明对属性 o 的引用。这样相当于组件之间共享了属性 o，因为只要任何一处修改了 o.count 属性，其他各处也会随之发生变化。</p>
<pre class="lang-javascript" data-nodeid="1362"><code data-language="javascript">&lt;div&nbsp;id=<span class="hljs-string">"app"</span>&gt; 
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span>&nbsp;<span class="hljs-attr">v-on:click</span>=<span class="hljs-string">"o.count++"</span>&gt;</span>&#123;&#123;o.count&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span> 
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button-counter</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">button-counter</span>&gt;</span></span> 
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button-counter</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">button-counter</span>&gt;</span></span> 
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button-counter</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">button-counter</span>&gt;</span></span> 
&lt;/div&gt; 
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"> 
Vue.component(<span class="hljs-string">'button-counter'</span>,&nbsp;&#123; 
&nbsp;&nbsp;<span class="hljs-attr">inject</span>:&nbsp;[<span class="hljs-string">'o'</span>], 
&nbsp;&nbsp;<span class="hljs-attr">methods</span>:&nbsp;&#123; 
&nbsp;&nbsp;&nbsp;&nbsp;click()&nbsp;&#123; 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-built_in">this</span>.o.count++ 
&nbsp;&nbsp;&nbsp;&nbsp;&#125; 
&nbsp;&nbsp;&#125;, 
&nbsp;&nbsp;<span class="hljs-attr">template</span>:&nbsp;<span class="hljs-string">'&lt;button&nbsp;v-on:click="click"&gt;You&nbsp;clicked&nbsp;me&nbsp;&#123;&#123;&nbsp;o.count&nbsp;&#125;&#125;&nbsp;times.&lt;/button&gt;'</span> 
&#125;) 
<span class="hljs-keyword">const</span>&nbsp;app&nbsp;=&nbsp;<span class="hljs-keyword">new</span>&nbsp;Vue(&#123; 
&nbsp;&nbsp;<span class="hljs-attr">el</span>:&nbsp;<span class="hljs-string">'#app'</span>, 
&nbsp;&nbsp;<span class="hljs-attr">data</span>:&nbsp;&#123; 
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">o</span>:&nbsp;&#123; 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">count</span>:&nbsp;<span class="hljs-number">0</span> 
&nbsp;&nbsp;&nbsp;&nbsp;&#125; 
&nbsp;&nbsp;&#125;, 
&nbsp;&nbsp;provide()&nbsp;&#123; 
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span>&nbsp;&#123; 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">o</span>:&nbsp;<span class="hljs-built_in">this</span>.o 
&nbsp;&nbsp;&nbsp;&nbsp;&#125; 
&nbsp;&nbsp;&#125; 
&#125;) 
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span> 
</code></pre>
<h4 data-nodeid="1363">2.事件监听</h4>
<p data-nodeid="1364">事件监听则是利用组件库本身的事件机制，设置一个全局事件代理，用来负责向各个组件传递数据。</p>
<p data-nodeid="1365">下面是一个简单的示例。创建一个 Vue 实例 eventBus，然后通过 Object.defineProperty 将其注入 Vue 组件中，这样在组件中就可以通过 this.$bus 来访问这个 Vue 实例了。当任何一个组件按钮被点击时，通过事件冒泡 this.$bus.$emit 来传入新的状态，其他组件则通过事件监听 this.$bus.$on 来获取最新的状态。</p>
<pre class="lang-javascript" data-nodeid="1366"><code data-language="javascript">&lt;div&nbsp;id=<span class="hljs-string">"app"</span>&gt; 
&nbsp;&nbsp;<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span>&nbsp;<span class="hljs-attr">v-on:click</span>=<span class="hljs-string">"click()"</span>&gt;</span>&#123;&#123;this.count&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span> 
&nbsp;&nbsp;<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button-counter</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">button-counter</span>&gt;</span></span> 
&nbsp;&nbsp;<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button-counter</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">button-counter</span>&gt;</span></span> 
&nbsp;&nbsp;<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button-counter</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">button-counter</span>&gt;</span></span> 
&lt;/div&gt; 
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"> 
&nbsp;&nbsp;<span class="hljs-keyword">var</span>&nbsp;EventBus&nbsp;=&nbsp;<span class="hljs-keyword">new</span>&nbsp;Vue(); 
&nbsp;&nbsp;<span class="hljs-built_in">Object</span>.defineProperties(Vue.prototype,&nbsp;&#123; 
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">$bus</span>:&nbsp;&#123; 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">get</span>:&nbsp;<span class="hljs-function"><span class="hljs-keyword">function</span>&nbsp;(<span class="hljs-params"></span>)&nbsp;</span>&#123; 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span>&nbsp;EventBus 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#125; 
&nbsp;&nbsp;&nbsp;&nbsp;&#125; 
&nbsp;&nbsp;&#125;) 
&nbsp;&nbsp;Vue.component(<span class="hljs-string">'button-counter'</span>,&nbsp;&#123; 
&nbsp;&nbsp;&nbsp;&nbsp;mounted()&nbsp;&#123; 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-built_in">this</span>.$bus.$on(<span class="hljs-string">'count'</span>,&nbsp;<span class="hljs-function"><span class="hljs-params">c</span>&nbsp;=&gt;</span>&nbsp;<span class="hljs-built_in">this</span>.count&nbsp;=&nbsp;c) 
&nbsp;&nbsp;&nbsp;&nbsp;&#125;, 
&nbsp;&nbsp;&nbsp;&nbsp;data()&nbsp;&#123; 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span>&nbsp;&#123; 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">count</span>:&nbsp;<span class="hljs-number">0</span> 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#125; 
&nbsp;&nbsp;&nbsp;&nbsp;&#125;, 
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">methods</span>:&nbsp;&#123; 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;click()&nbsp;&#123; 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-built_in">this</span>.$bus.$emit(<span class="hljs-string">'count'</span>,&nbsp;<span class="hljs-built_in">this</span>.count&nbsp;+&nbsp;<span class="hljs-number">1</span>) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#125; 
&nbsp;&nbsp;&nbsp;&nbsp;&#125;, 
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">template</span>:&nbsp;<span class="hljs-string">'&lt;button&nbsp;v-on:click="click"&gt;You&nbsp;clicked&nbsp;me&nbsp;&#123;&#123;&nbsp;this.count&nbsp;&#125;&#125;&nbsp;times.&lt;/button&gt;'</span> 
&nbsp;&nbsp;&#125;) 
&nbsp;&nbsp;<span class="hljs-keyword">const</span>&nbsp;app&nbsp;=&nbsp;<span class="hljs-keyword">new</span>&nbsp;Vue(&#123; 
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">el</span>:&nbsp;<span class="hljs-string">'#app'</span>, 
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">data</span>:&nbsp;&#123; 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">count</span>:&nbsp;<span class="hljs-number">0</span> 
&nbsp;&nbsp;&nbsp;&nbsp;&#125;, 
&nbsp;&nbsp;&nbsp;&nbsp;mounted()&nbsp;&#123; 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-built_in">this</span>.$bus.$on(<span class="hljs-string">'count'</span>,&nbsp;<span class="hljs-function"><span class="hljs-params">c</span>&nbsp;=&gt;</span>&nbsp;<span class="hljs-built_in">this</span>.count&nbsp;=&nbsp;c) 
&nbsp;&nbsp;&nbsp;&nbsp;&#125;, 
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">methods</span>:&nbsp;&#123; 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;click()&nbsp;&#123; 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-built_in">this</span>.$bus.$emit(<span class="hljs-string">'count'</span>,&nbsp;<span class="hljs-built_in">this</span>.count&nbsp;+&nbsp;<span class="hljs-number">1</span>) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#125; 
&nbsp;&nbsp;&nbsp;&nbsp;&#125; 
&nbsp;&nbsp;&#125;) 
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span> 
</code></pre>
<h3 data-nodeid="1367">总结</h3>
<p data-nodeid="1368">本讲介绍了 3 种不同的跨组件通信方式。由于通信双方不属于父子组件，也就是没有直接的依赖/引用关系，所以需要借助“第三方”来进行传递数据，这些“第三方”既包括视图库（Vue 和 React）本身提供的事件机制或全局上下文，也包括面向其进行开发的状态管理库。</p>
<p data-nodeid="1369">对于最常用的全局状态管理库 Vuex 和 Redux，通过深入分析其源码，理解了其实现原理。Vuex 内部会创建一个 Vue 实例，并使用这个实例的数据模型来做状态更新；而 Redux 则采用了无副作用的纯函数来生成不可变数据。</p>
<p data-nodeid="1370">组件库默认提供了全局上下文的方式来解决跨组件通信问题，非常轻量，适合在小型 Web 应用中使用，缺点是追踪调试状态变化比较困难。事件监听的方式也可以不依赖额外的第三方库来实现，但在监听到事件改变时需要在组件内部手动触发视图更新。</p>
<p data-nodeid="2485">最后布置一道思考题：你还知道哪些跨组件通信的方式？</p>

<hr>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h5 id="-1"><a href="#-1" class="headerlink" title=""></a></h5><blockquote>
<p>vm.$emit( eventName, […args] )</p>
</blockquote>
<h5 id="-2"><a href="#-2" class="headerlink" title=""></a></h5>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/11/02/%E8%AF%A6%E8%A7%A3%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E4%B9%8B%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/" data-id="claxeerab001pv8w10yjgco5s" data-title="详解组件通信之状态管理" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-浏览器同源策略与跨域方案" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/11/02/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%E4%B8%8E%E8%B7%A8%E5%9F%9F%E6%96%B9%E6%A1%88/" class="article-date">
  <time class="dt-published" datetime="2022-11-02T02:33:32.000Z" itemprop="datePublished">2022-11-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/11/02/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%E4%B8%8E%E8%B7%A8%E5%9F%9F%E6%96%B9%E6%A1%88/">浏览器同源策略与跨域方案</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p data-nodeid="8577" class="">开发出高性能的 Web 应用固然重要，但安全问题也不容小觑。这一课时我们继续以 HTTP 为线索，展开来讲一讲浏览器安全相关的同源策略。</p>
<h3 data-nodeid="8578">浏览器的同源策略（Same Origin Policy）</h3>
<p data-nodeid="9369">源（Origin）是由 URL 中协议、主机名（域名 domain）以及端口共同组成的部分。在下面的网址中，源由协议 https、主机名 kaiwu.lagou.com 和默认端口 443 共同组成。</p>
<p data-nodeid="10440" class=""><img src="https://s0.lgstatic.com/i/image6/M00/25/12/CioPOWBZVeWATe0uAAAhcRPjM7k018.png" alt="3.png" data-nodeid="10444"></p>
<div data-nodeid="10441" class="te-preview-highlight"><p style="text-align:center">URL 中的源</p></div>



<p data-nodeid="8582">如果两个 URL 的源相同，我们就称之为<strong data-nodeid="8692">同源</strong>。下面的 3 个 URL 和示例 URL 都是不同的源。</p>
<ul data-nodeid="8583">
<li data-nodeid="8584">
<p data-nodeid="8585"><a target="_blank" rel="noopener" href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=180#/content" data-nodeid="8695">http://kaiwu.lagou.com/course/courseInfo.htm?courseId=180#/content</a>：协议不同。</p>
</li>
<li data-nodeid="8586">
<p data-nodeid="8587"><a target="_blank" rel="noopener" href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=180#/content" data-nodeid="8699">https://kaiwu.lagou.com:80/course/courseInfo.htm?courseId=180#/content</a>：端口不同。</p>
</li>
<li data-nodeid="8588">
<p data-nodeid="8589"><a target="_blank" rel="noopener" href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=180#/content" data-nodeid="8703">https://lagou.com/course/courseInfo.htm?courseId=180#/content</a>：主机名不同。</p>
</li>
</ul>
<p data-nodeid="8590">而下面 2 个网址和示例 URL 都是同源。</p>
<ul data-nodeid="8591">
<li data-nodeid="8592">
<p data-nodeid="8593"><a target="_blank" rel="noopener" href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=288#/sale" data-nodeid="8708">https://kaiwu.lagou.com/course/courseInfo.htm?courseId=288#/sale</a>：请求参数不同。</p>
</li>
<li data-nodeid="8594">
<p data-nodeid="8595"><a target="_blank" rel="noopener" href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=288#/sale" data-nodeid="8712">https://kaiwu.lagou.com</a>：URL 路径不同。</p>
</li>
</ul>
<p data-nodeid="8596">当一个源访问另一个源的资源时就会产生<strong data-nodeid="8723">跨源</strong>。同源策略就是用来限制其中一些跨源访问的，包括访问 iframe 中的页面、其他页面的 cookie 访问以及发送 AJAX 请求。最常见的跨源场景是域名不同，即常说的“跨域”。<strong data-nodeid="8724">本课时也按照约定俗成的说法，用“跨域”来指代“跨源”</strong>。</p>
<p data-nodeid="8597">同源策略在保障安全的同时也带来了不少问题，比如 iframe 中的子页面与父页面无法通信，浏览器与其他服务端无法交互数据。所以我们需要一些跨域方案来解决这些问题。</p>
<h3 data-nodeid="8598">请求跨域解决方案</h3>
<p data-nodeid="8599">对于浏览器请求跨域，常用的有下面 4 种方法。</p>
<h4 data-nodeid="8600">跨域资源共享</h4>
<p data-nodeid="8601">跨域资源共享（CORS，Cross-Origin Resource Sharing）是浏览器为 AJAX 请求设置的一种跨域机制，让其可以在服务端允许的情况下进行跨域访问。主要通过 HTTP 响应头来告诉浏览器服务端是否允许当前域的脚本进行跨域访问。</p>
<p data-nodeid="8602">跨域资源共享将 AJAX 请求分成了两类：简单请求和非简单请求。其中<strong data-nodeid="8735">简单请求</strong>符合下面 2 个特征。</p>
<ul data-nodeid="8603">
<li data-nodeid="8604">
<p data-nodeid="8605">请求方法为 GET、POST、HEAD。</p>
</li>
<li data-nodeid="8606">
<p data-nodeid="8607">请求头只能使用下面的字段：Accept（浏览器能够接受的响应内容类型）、Accept-Language（浏览器能够接受的自然语言列表）、Content-Type （请求对应的类型，只限于 text/plain、multipart/form-data、application/x-www-form-urlencoded）、Content-Language（浏览器希望采用的自然语言）、Save-Data（浏览器是否希望减少数据传输量）。</p>
</li>
</ul>
<p data-nodeid="8608"><strong data-nodeid="8741">任意一条要求不符合的即为非简单请求。</strong></p>
<p data-nodeid="8609">对于简单请求，处理流程如下：</p>
<ul data-nodeid="8610">
<li data-nodeid="8611">
<p data-nodeid="8612">浏览器发出简单请求的时候，会在请求头部增加一个 Origin 字段，对应的值为当前请求的源信息；</p>
</li>
<li data-nodeid="8613">
<p data-nodeid="8614">当服务端收到请求后，会根据请求头字段 Origin 做出判断后返回相应的内容。</p>
</li>
<li data-nodeid="8615">
<p data-nodeid="8616">浏览器收到响应报文后会根据响应头部字段 Access-Control-Allow-Origin&nbsp;进行判断，这个字段值为服务端允许跨域请求的源，其中通配符“*”表示允许所有跨域请求。如果头部信息没有包含 Access-Control-Allow-Origin 字段或者响应的头部字段 Access-Control-Allow-Origin 不允许当前源的请求，则会抛出错误。</p>
</li>
</ul>
<p data-nodeid="8617">当处理非简单的请求时，浏览器会先发出一个预检请求（Preflight）。这个预检请求为 OPTIONS 方法，并会添加了 1 个请求头部字段 Access-Control-Request-Method，值为跨域请求所使用的请求方法。</p>
<p data-nodeid="8618">下图是一个预检请求的请求报文和响应报文。因为添加了不属于上述简单请求的头部字段，所以浏览器在请求头部添加了 Access-Control-Request-Headers 字段，值为跨域请求添加的请求头部字段 authorization。</p>
<p data-nodeid="8619"><img src="https://s0.lgstatic.com/i/image/M00/33/5D/Ciqc1F8QAGWAXq7jAABT5RmcAOI346.png" alt="image (13).png" data-nodeid="8752"></p>
<div data-nodeid="8620"><p style="text-align:center">预检请求头部信息</p></div>
<p data-nodeid="8621">在服务端收到预检请求后，除了在响应头部添加 Access-Control-Allow-Origin 字段之外，至少还会添加 Access-Control-Allow-Methods 字段来告诉浏览器服务端允许的请求方法，并返回 204 状态码。</p>
<p data-nodeid="8622">在上面的例子中，服务端还根据浏览器的 Access-Control-Request-Headers 字段回应了一个 Access-Control-Allow-Headers 字段，来告诉浏览器服务端允许的请求头部字段。</p>
<p data-nodeid="8623">浏览器得到预检请求响应的头部字段之后，会判断当前请求服务端是否在服务端许可范围之内，如果在则继续发送跨域请求，反之则直接报错。</p>
<h4 data-nodeid="8624">JSONP</h4>
<p data-nodeid="8625">JSONP（JSON with Padding）的大概意思就是用 JSON 数据来填充，怎么填充呢？结合它的实现方式可以知道，就是把 JSON 数填充到一个回调函数中。这种比较 hack 的方式，依赖的是 script 标签跨域引用 js 文件不会受到浏览器同源策略的限制。</p>
<p data-nodeid="8626">下面以一个具体例子来讲解它的具体实现方式。</p>
<p data-nodeid="8627">假设我们要在 http://ww.a.com 中向 http://www.b.com 请求数据。</p>
<p data-nodeid="8628">1.全局声明一个用来处理返回值的函数 fn，该函数参数为请求的返回结果。</p>
<pre class="lang-javascript" data-nodeid="8629"><code data-language="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params">result</span>) </span>&#123;
  <span class="hljs-built_in">console</span>.log(result)
&#125;
</code></pre>
<p data-nodeid="8630">2.将函数名与其他参数一并写入 URL 中。</p>
<pre class="lang-javascript" data-nodeid="8631"><code data-language="javascript"><span class="hljs-keyword">var</span> url = <span class="hljs-string">'http://www.b.com?callback=fn&amp;params=...'</span>;
</code></pre>
<p data-nodeid="8632">3.创建一个 script 标签，把 URL 赋值给 script 的 src。</p>
<pre class="lang-javascript" data-nodeid="8633"><code data-language="javascript"><span class="hljs-keyword">var</span> script = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'script'</span>);
script.setAttribute(<span class="hljs-string">"type"</span>,<span class="hljs-string">"text/javascript"</span>);
script.src = url;
<span class="hljs-built_in">document</span>.body.appendChild(script);
</code></pre>
<p data-nodeid="8634">4.当服务器接收到请求后，解析 URL 参数并进行对应的逻辑处理，得到结果后将其写成回调函数的形式并返回给浏览器。</p>
<pre class="lang-javascript" data-nodeid="8635"><code data-language="javascript">fn(&#123;
  <span class="hljs-attr">list</span>: [],
  ...
&#125;)
</code></pre>
<p data-nodeid="8636">5.在浏览器收到请求返回的 js 脚本之后会立即执行文件内容，即在控制台打印传入的数据内容。</p>
<p data-nodeid="8637">JSONP 虽然实现了跨域请求，但也存在 3 个问题：</p>
<ul data-nodeid="8638">
<li data-nodeid="8639">
<p data-nodeid="8640">只能发送 GET 请求，限制了参数大小和类型；</p>
</li>
<li data-nodeid="8641">
<p data-nodeid="8642">请求过程无法终止，导致弱网络下处理超时请求比较麻烦；</p>
</li>
<li data-nodeid="8643">
<p data-nodeid="8644">无法捕获服务端返回的异常信息。</p>
</li>
</ul>
<h4 data-nodeid="8645">Websocket</h4>
<p data-nodeid="8646">Websocket 是 HTML5 规范提出的一个应用层的全双工协议，适用于浏览器与服务器进行实时通信场景。</p>
<p data-nodeid="8647">什么叫全双工呢？</p>
<p data-nodeid="8648">这是通信传输的一个术语，这里的“工”指的是通信方向，“双工”是指从客户端到服务端，以及从服务端到客户端两个方向都可以通信，“全”指的是通信双方可以同时向对方发送数据。与之相对应的还有半双工和单工，半双工指的是双方可以互相向对方发送数据，但双方不能同时发送，单工则指的是数据只能从一方发送到另一方。</p>
<p data-nodeid="8649">下面是一段简单的示例代码。在 a 网站直接创建一个 WebSocket 连接，连接到 b 网站即可，然后调用 WebScoket 实例 ws 的 send() 函数向服务端发送消息，监听实例 ws 的 onmessage 事件得到响应内容。</p>
<pre class="lang-javascript" data-nodeid="8650"><code data-language="javascript"><span class="hljs-keyword">var</span> ws = <span class="hljs-keyword">new</span> WebSocket(<span class="hljs-string">"ws://b.com"</span>);
ws.onopen = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;
&nbsp; <span class="hljs-comment">// ws.send(...);</span>
&#125;
ws.onmessage = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>)</span>&#123;
&nbsp; <span class="hljs-comment">// console.log(e.data);</span>
&#125;
</code></pre>
<h4 data-nodeid="8651">代理转发</h4>
<p data-nodeid="8652">跨域是为了突破浏览器的同源策略限制，既然同源策略只存在于浏览器，那可以换个思路，在服务端进行跨域，比如设置代理转发。这种在服务端设置的代理称为“<strong data-nodeid="8780">反向代理</strong>”，对于用户而言是无感知的。</p>
<p data-nodeid="8653">另一种在客户端使用的代理称为“<strong data-nodeid="8786">正向代理</strong>”，主要用来代理客户端发送请求，用户使用时必须配置代理服务器的网址，比如常用的 VPN 工具就属于正向代理。</p>
<p data-nodeid="8654">代理转发实现起来非常简单，在当前被访问的服务器配置一个请求转发规则就行了。</p>
<p data-nodeid="8655">下面的代码是 webpack-dev-server 配置代理的示例代码。当浏览器发起前缀为 /api 的请求时都会被转发到 http://localhost:3000 这个网址，然后将响应结果返回给浏览器。对于浏览器而言还是请求当前网站，但实际上已经被服务端转发。</p>
<pre class="lang-javascript" data-nodeid="8656"><code data-language="javascript"><span class="hljs-comment">// webpack.config.js</span>
<span class="hljs-built_in">module</span>.exports = &#123;
  <span class="hljs-comment">//...</span>
  <span class="hljs-attr">devServer</span>: &#123;
    <span class="hljs-attr">proxy</span>: &#123;
      <span class="hljs-string">'/api'</span>: <span class="hljs-string">'http://localhost:3000'</span>
    &#125;
  &#125;
&#125;;
</code></pre>
<p data-nodeid="8657">在 Nginx 服务器上配置同样的转发规则也非常简单，下面是示例配置。</p>
<pre class="lang-java" data-nodeid="8658"><code data-language="java">location /api &#123;
&nbsp; &nbsp; proxy_pass&nbsp; &nbsp;http:<span class="hljs-comment">//localhost:3000;</span>
&#125;
</code></pre>
<p data-nodeid="8659">通过 location 指令匹配路径，然后通过 proxy_pass 指令指向代理地址即可。</p>
<h3 data-nodeid="8660">页面跨域解决方案</h3>
<p data-nodeid="8661">除了浏览器请求跨域之外，页面之间也会有跨域需求，例如使用 iframe 时父子页面之间进行通信。</p>
<h4 data-nodeid="8662">postMessage</h4>
<p data-nodeid="8663">HTML5 推出了一个新的函数 postMessage() 用来实现父子页面之间通信，而且不论这两个页面是否同源。</p>
<p data-nodeid="8664">举例来说，如果父页面 <a target="_blank" rel="noopener" href="https://lagou.com" data-nodeid="8800">https://lagou.com</a> 要向子页面 <a target="_blank" rel="noopener" href="https://kaiwu.lagou.com" data-nodeid="8804">https://kaiwu.lagou.com</a> 发消息，可以通过下面的代码实现。</p>
<pre class="lang-javascript" data-nodeid="8665"><code data-language="javascript"><span class="hljs-comment">// https://lagou.com</span>
<span class="hljs-keyword">var</span> child = <span class="hljs-built_in">window</span>.open(<span class="hljs-string">'https://kaiwu.lagou.com'</span>);
child.postMessage(<span class="hljs-string">'hi'</span>, <span class="hljs-string">'https://kaiwu.lagou.com'</span>);
</code></pre>
<p data-nodeid="8666">上面的代码通过 window.open() 函数打开了子页面，然后调用 child.postMessage() 函数发送了字符串数据“hi”给子页面。</p>
<p data-nodeid="8667">在子页面中，只需要监听“message”事件即可得到父页面的数据。代码如下：</p>
<pre class="lang-javascript" data-nodeid="8668"><code data-language="javascript"><span class="hljs-comment">// https://kaiwu.lagou.com</span>
<span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">'message'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;
&nbsp; <span class="hljs-built_in">console</span>.log(e.data);
&#125;,<span class="hljs-literal">false</span>);
</code></pre>
<p data-nodeid="8669">同样的，父页面也可以监听“message”事件来接收子页面发送的数据。子页面发送数据时则要通过 window.opener 对象来调用 postMessage() 函数。</p>
<pre class="lang-javascript" data-nodeid="8670"><code data-language="javascript"><span class="hljs-comment">// https://kaiwu.lagou.com</span>
<span class="hljs-built_in">window</span>.opener.postMessage(<span class="hljs-string">'hello'</span>, <span class="hljs-string">'https://lagou.com'</span>);
</code></pre>
<h4 data-nodeid="8671">改域</h4>
<p data-nodeid="8672">对于主域名相同，子域名不同的情况，可以通过修改 document.domain 的值来进行跨域。如果将其设置为其当前域的父域，则这个较短的父域将用于后续源检查。</p>
<p data-nodeid="8673">比如，有一个页面，它的地址是 <a target="_blank" rel="noopener" href="https://www.lagou.com/parent.html" data-nodeid="8814">https://www.lagou.com/parent.html</a>，在这个页面里面有一个 iframe，其 src 是 <a target="_blank" rel="noopener" href="http://kaiwu.lagou.com/child.html" data-nodeid="8818">http://kaiwu.lagou.com/child.html</a>。</p>
<p data-nodeid="8674">这时只要把 <a target="_blank" rel="noopener" href="http://www.lagou.com/parent.html" data-nodeid="8823">http://www.lagou.com/parent.html</a> 和 <a target="_blank" rel="noopener" href="http://kaiwu.lagou.com/child.html" data-nodeid="8827">http://kaiwu.lagou.com/child.html</a> 这两个页面的 document.domain 都设成相同的域名，那么父子页面之间就可以进行跨域通信了，同时还可以共享 cookie。</p>
<p data-nodeid="8675">但要注意的是，只能把 document.domain 设置成更高级的父域才有效果，例如在&nbsp; <a target="_blank" rel="noopener" href="http://kaiwu.lagou.com/child.html" data-nodeid="8832">http://kaiwu.lagou.com/child.html</a> 中可以将 document.domain 设置成&nbsp;lagou.com。</p>
<h3 data-nodeid="8676">总结</h3>
<p data-nodeid="8677">本课时介绍了浏览器的同源策略，并分别从请求跨域与页面跨域两个方向介绍了几种常用的跨域方案。</p>
<p data-nodeid="8678">对于请求跨域，包括跨域资源共享、JSONP、Websocket、代理转发 4 种方式，推荐优先使用代理转发和跨域资源共享。对于页面跨域，包括 postMessage 和改域 2 种方式，使用频率没有请求跨域那么高，记住 2 种方式实现原理就好。</p>
<p data-nodeid="8679">最后布置一道思考题：说一说你还知道浏览器的哪些安全策略？</p>
<p data-nodeid="8680" class="">OK，这一课时就讲到这里啦，如果你觉得这个内容对你有所启发，欢迎分享给你的朋友或者同事探讨学习。</p>



<blockquote>
<p>嗯 学到了。查了一下 还有 cookie 安全策略和内容安全策略</p>
</blockquote>
<blockquote>
<p>CSP</p>
</blockquote>
<blockquote>
<p>使用window.name也可以跨域</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/11/02/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%E4%B8%8E%E8%B7%A8%E5%9F%9F%E6%96%B9%E6%A1%88/" data-id="claxeera7001hv8w1bh4f8r7h" data-title="浏览器同源策略与跨域方案" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-React" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/11/01/React/" class="article-date">
  <time class="dt-published" datetime="2022-11-01T01:17:31.000Z" itemprop="datePublished">2022-11-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/11/01/React/">React</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="React的使用"><a href="#React的使用" class="headerlink" title="React的使用"></a>React的使用</h1><p>##特点：</p>
<p>​	1.声明式编程：只需要维护状态，当状态发生改变时，React可以根据最新的状态去渲染我们的ui界面</p>
<p>​	2.组件化开发：将复杂的界面拆成一个个小的组件</p>
<p>​	3.多平台适配</p>
<p>##React开发依赖：</p>
<p>​	1.react：包含react所必须的核心代码</p>
<p>​	2.react-dom：react渲染在不同平台所需要的核心代码</p>
<p>​	3.babel：将jsx转换成React代码的工具</p>
<h3 id="JSX的本质："><a href="#JSX的本质：" class="headerlink" title="JSX的本质："></a>JSX的本质：</h3><ul>
<li>实际上，jsx仅仅是<code>React.createElement(component,prop,...children)</code>函数的语法糖<ul>
<li>所有的jsx最终都会被转换成<code>React.createElement</code>的函数调用</li>
</ul>
<p>	</p>
</li>
<li>createElement需要传递三个参数<ul>
<li>参数一：type<ul>
<li>当前ReactElement的类型</li>
<li>如果是标签元素，那么就使用字符串表示”div”</li>
<li>如果是组件元素，那么就直接使用组件的名称</li>
</ul>
</li>
<li>参数二：config<ul>
<li>所有jsx中的属性都在config中以对象的属性和值的形式存储</li>
</ul>
</li>
<li>参数三：children<ul>
<li>存放在标签中的内容，以children数组的方式存储</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>###React中虚拟DOM的创建过程</p>
<p>通过<code>React.createElement</code> 最终创建出来一个ReactElement对象</p>
<p>####虚拟DOM其实就是一个js对象   为什么要将真实DOM转为虚拟DOM?</p>
<ol>
<li>​	因为去操作真实DOM时，效率低，而操作虚拟    DOM，实际上是在内存中操作对象，效率高</li>
<li>很难追踪状态的改变：原有的开发模式，我们很难追踪到状态发生的改变，不方便针对性调试</li>
<li>DOM操作性能非常低<ol>
<li>首先<code>document.createElement</code>本身创建出来的就是一个非常复杂的对象</li>
<li>其次DOM操作会引起浏览器的回流和重绘，所以在开发中应该避免频繁的DOM操作</li>
</ol>
</li>
</ol>
<h3 id="声明式编程"><a href="#声明式编程" class="headerlink" title="声明式编程"></a>声明式编程</h3><p><img src="C:\Users\c\AppData\Roaming\Typora\typora-user-images\image-20220805203533168.png" alt="image-20220805203533168"></p>
<h3 id="React脚手架生成目录结构"><a href="#React脚手架生成目录结构" class="headerlink" title="React脚手架生成目录结构"></a>React脚手架生成目录结构</h3><p><img src="C:\Users\c\AppData\Roaming\Typora\typora-user-images\image-20220806215401917.png" alt="image-20220806215401917"></p>
<h3 id="PWA"><a href="#PWA" class="headerlink" title="PWA"></a>PWA</h3><ul>
<li>​	脚手架生成的目录结构整体比较好理解，但有一个PWA相关的概念：<ul>
<li>PWA全称Progressive Web App，即渐进式WEB应用。</li>
<li>一个PWA应用首先是一个网页，可以通过Web技术编写出一个网页应用</li>
<li>随后添加上App Manifest和Service Worker 来实现PWA的安装和离线等功能</li>
<li>这种Web存在的形式，我们也称之为Web App</li>
</ul>
</li>
<li>PWA解决了那些问题？<ul>
<li>可以添加至主屏幕，点击主屏幕图标可以实现启动动画以及隐藏地址栏</li>
<li>实现离线缓存功能，即使用户手机没有网络，依然可以使用一些离线功能</li>
<li>实现消息推送</li>
<li>等等一系列类似于Native App相关的功能</li>
</ul>
</li>
</ul>
<h3 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h3><p>React的组件化相对于vue更加灵活和多样，按照不同的方式可以分为很多类组件</p>
<ul>
<li>根据组件的定义方式：可以分为函数式组件和类组件</li>
<li>根据组件内部是否有状态需要维护，可以分为：无状态组件和有状态组件</li>
<li>根据组件的不同职责，可以分为：展示型组件和容器型组件</li>
</ul>
<h4 id="类组件"><a href="#类组件" class="headerlink" title="类组件"></a>类组件</h4><ul>
<li>在jsx中组件的名称是以大写字母开头的（无论类组件还是函数组件）</li>
<li>类组件需要继承自React.Component</li>
<li>类组件必须实现render函数</li>
</ul>
<p>使用class定义一个组件：</p>
<ul>
<li>constructor是可选的，我们通常在constructor中初始化一些数据；</li>
<li>this.state中维护的就是我们组件内部的数据；</li>
<li>render()方法是class组件中唯一必须实现的方法</li>
</ul>
<h4 id="函数式组件"><a href="#函数式组件" class="headerlink" title="函数式组件"></a>函数式组件</h4><p>函数式组件的特点：</p>
<ul>
<li>没有this对象（组件实例）</li>
<li>没有生命周期，也会被更行并挂载，但是没有生命周期函数</li>
<li>没有内部的状态（state）</li>
</ul>
<h4 id="render函数的返回值"><a href="#render函数的返回值" class="headerlink" title="render函数的返回值"></a>render函数的返回值</h4><p>当render被调用时，他会检查this.props和this.state的变化并返回以下类型之一</p>
<ul>
<li><strong>React元素</strong>：<ul>
<li>通常通过JSX创建</li>
<li>例如：<div/>会被react渲染为DOM节点，<MyComponent/>会被react渲染为自定义组件</li>
<li>无论是<div/>还是<MyComponent/>均为React元素</li>
</ul>
</li>
<li><strong>数组或fragments</strong>:使得render方法可以返回多个元素</li>
<li><strong>Portals</strong>：可以渲染子节点到不同的DOM子树中。</li>
<li><strong>字符串或数值类型</strong>：他们在DOM中会被渲染为文本节点</li>
</ul>
<h4 id="React生命周期"><a href="#React生命周期" class="headerlink" title="React生命周期"></a>React生命周期</h4><p>生命周期是一个抽象的概念，在生命周期的整个过程，分成了很多阶段：</p>
<ul>
<li>装载阶段（Mount），组件第一次在DOM树中被渲染的过程</li>
<li>更新过程（Update），组件状态发生变化，重新更新渲染的过程</li>
<li>卸载过程（Unmount），组件从DOM树中被移除的过程</li>
</ul>
<p>React内部为了告诉我们当前处于那些阶段，会对我们组件内部实现的某些函数进行回调，这些函数就是生命周期函数：</p>
<ul>
<li><code>componentDidMount</code>函数：组件已经挂载到DOM上时，就会回调。</li>
<li><code>componentDidUpdate</code>函数：组件已经发生更新时，就会回调。</li>
<li><code>componentWillUnmount</code>函数：组件即将被移除时，就会回调</li>
</ul>
<p><img src="C:\Users\c\AppData\Roaming\Typora\typora-user-images\image-20220808223021319.png" alt="image-20220808223021319"></p>
<h5 id="Constructor"><a href="#Constructor" class="headerlink" title="Constructor"></a>Constructor</h5><ul>
<li>如果不初始化state或不进行方法绑定，则不需要为React组件实现构造函数</li>
<li>constructor中通常只做两件事：<ul>
<li>通过给this.state赋值对象来初始化内部的state</li>
<li>为事件绑定实例（this）</li>
</ul>
</li>
<li><code>componentDidMount</code><ul>
<li><code>componentDidMount()</code>会在组件挂载后（插在DOM树中）立即调用</li>
<li><code>componentDidMount</code>中通常进行<ul>
<li>依赖于DOM的操作可以在这里进行</li>
<li>在此处发送网络请求就是最好的地方</li>
<li>可以在此处添加一些订阅（会在<code>componentWillUnmount</code>取消订阅）</li>
</ul>
</li>
</ul>
</li>
<li><code>componentDidUpdate</code><ul>
<li><code>componentDidUpdate()</code>会在更新后立即被调用，首次渲染不会执行<ul>
<li>当组件更新后，可以在此处对DOM进行操作</li>
<li>如果你对更新后的props进行了比较，也可以在此处进行网络请求；（例如，当props未发生变化时，则不会执行网络请求）</li>
</ul>
</li>
</ul>
</li>
<li><code>componentWillUnmount</code><ul>
<li><code>componentWillUnmount()</code>会在组件卸载及销毁之前直接调用<ul>
<li>在此方法中执行必要的清理操作</li>
<li>例如清除timer，取消网络请求或清除在<code>componentDidMount()</code>中创建的订阅等；</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="C:\Users\c\AppData\Roaming\Typora\typora-user-images\image-20220809213804027.png" alt="image-20220809213804027"></p>
<h4 id="context组件通信"><a href="#context组件通信" class="headerlink" title="context组件通信"></a>context组件通信</h4><p><img src="C:\Users\c\AppData\Roaming\Typora\typora-user-images\image-20220822150317996.png" alt="image-20220822150317996"></p>
<p><img src="C:\Users\c\AppData\Roaming\Typora\typora-user-images\image-20220822152954214.png" alt="image-20220822152954214"></p>
<p>当为函数式组件时，此时红色的value就是<code>UserContext</code>中的value值</p>
<p><img src="C:\Users\c\AppData\Roaming\Typora\typora-user-images\image-20220822153022366.png" alt="image-20220822153022366"></p>
<h4 id="setState-异步更新"><a href="#setState-异步更新" class="headerlink" title="setState   异步更新"></a>setState   异步更新</h4><p>为什么组件中并没有<code>setState</code>但我们可以调用它？</p>
<p>因为<code>setState</code>是我们从继承的&#x3D;&#x3D;Component&#x3D;&#x3D;中拿到的</p>
<p><img src="C:\Users\c\AppData\Roaming\Typora\typora-user-images\image-20220822160455672.png" alt="image-20220822160455672"></p>
<p><img src="C:\Users\c\AppData\Roaming\Typora\typora-user-images\image-20220822171432674.png" alt="image-20220822171432674"></p>
<h4 id="setState为什么要是不可变数据"><a href="#setState为什么要是不可变数据" class="headerlink" title="setState为什么要是不可变数据"></a>setState为什么要是不可变数据</h4><p>####React更新机制以及diff算法</p>
<p><img src="C:\Users\c\AppData\Roaming\Typora\typora-user-images\image-20220822193411264.png" alt="image-20220822193411264"></p>
<p><img src="C:\Users\c\AppData\Roaming\Typora\typora-user-images\image-20220822194130264.png" alt="image-20220822194130264"></p>
<p><img src="C:\Users\c\AppData\Roaming\Typora\typora-user-images\image-20220822194256166.png" alt="image-20220822194256166"></p>
<p><img src="C:\Users\c\AppData\Roaming\Typora\typora-user-images\image-20220822194446293.png" alt="image-20220822194446293"></p>
<p><img src="C:\Users\c\AppData\Roaming\Typora\typora-user-images\image-20220822194811600.png" alt="image-20220822194811600"></p>
<p><img src="C:\Users\c\AppData\Roaming\Typora\typora-user-images\image-20220822203113532.png" alt="image-20220822203113532"></p>
<h4 id="React中ref的使用"><a href="#React中ref的使用" class="headerlink" title="React中ref的使用"></a>React中ref的使用</h4><p><img src="C:\Users\c\AppData\Roaming\Typora\typora-user-images\image-20220823105752859.png" alt="image-20220823105752859"></p>
<h4 id="受控组件和非受控组件"><a href="#受控组件和非受控组件" class="headerlink" title="受控组件和非受控组件"></a>受控组件和非受控组件</h4><p><img src="C:\Users\c\AppData\Roaming\Typora\typora-user-images\image-20220823110120160.png" alt="image-20220823110120160"></p>
<p><img src="C:\Users\c\AppData\Roaming\Typora\typora-user-images\image-20220823111612850.png" alt="image-20220823111612850"></p>
<p><img src="C:\Users\c\AppData\Roaming\Typora\typora-user-images\image-20220823151633117.png" alt="image-20220823151633117"></p>
<p><img src="C:\Users\c\AppData\Roaming\Typora\typora-user-images\image-20220823153753112.png" alt="image-20220823153753112"></p>
<p> <img src="C:\Users\c\AppData\Roaming\Typora\typora-user-images\image-20220823192248613.png" alt="image-20220823192248613"></p>
<p>####严格模式检查什么？</p>
<p><img src="C:\Users\c\AppData\Roaming\Typora\typora-user-images\image-20220823220609378.png" alt="image-20220823220609378"></p>
<h4 id="React中的样式（css）"><a href="#React中的样式（css）" class="headerlink" title="React中的样式（css）"></a>React中的样式（css）</h4><p><img src="C:\Users\c\AppData\Roaming\Typora\typora-user-images\image-20220824093009127.png" alt="image-20220824093009127"></p>
<p><img src="C:\Users\c\AppData\Roaming\Typora\typora-user-images\image-20220824094937985.png" alt="image-20220824094937985"></p>
<p><img src="C:\Users\c\AppData\Roaming\Typora\typora-user-images\image-20220824095817088.png" alt="image-20220824095817088"></p>
<p><img src="C:\Users\c\AppData\Roaming\Typora\typora-user-images\image-20220824145817263.png" alt="image-20220824145817263"></p>
<h4 id="React中的动画与过度"><a href="#React中的动画与过度" class="headerlink" title="React中的动画与过度"></a>React中的动画与过度</h4><p><img src="C:\Users\c\AppData\Roaming\Typora\typora-user-images\image-20220825090736404.png" alt="image-20220825090736404"></p>
<p><img src="C:\Users\c\AppData\Roaming\Typora\typora-user-images\image-20220825090751431.png" alt="image-20220825090751431"></p>
<h4 id="纯函数"><a href="#纯函数" class="headerlink" title="纯函数"></a>纯函数</h4><ul>
<li>1.确定的输入，一定要有确定的输出</li>
<li>2.函数在执行过程中，没有产生副作用</li>
</ul>
<h4 id="redux"><a href="#redux" class="headerlink" title="redux"></a>redux</h4><p><img src="C:\Users\c\AppData\Roaming\Typora\typora-user-images\image-20220827094304510.png" alt="image-20220827094304510"></p>
<p><img src="C:\Users\c\AppData\Roaming\Typora\typora-user-images\image-20220825112738763.png" alt="image-20220825112738763"></p>
<h5 id="redux的三大核心理念"><a href="#redux的三大核心理念" class="headerlink" title="redux的三大核心理念"></a>redux的三大核心理念</h5><ul>
<li>1.store</li>
<li>2.action</li>
<li>3.reducer</li>
</ul>
<p><img src="C:\Users\c\AppData\Roaming\Typora\typora-user-images\image-20220825114110840.png" alt="image-20220825114110840"></p>
<p><img src="C:\Users\c\AppData\Roaming\Typora\typora-user-images\image-20220825183857978.png" alt="image-20220825183857978"></p>
<p><img src="C:\Users\c\AppData\Roaming\Typora\typora-user-images\image-20220825184324845.png" alt="image-20220825184324845"></p>
<p><img src="C:\Users\c\AppData\Roaming\Typora\typora-user-images\image-20220826162744584.png" alt="image-20220826162744584"></p>
<p><img src="C:\Users\c\AppData\Roaming\Typora\typora-user-images\image-20220826164036256.png" alt="image-20220826164036256"></p>
<h4 id="React-router"><a href="#React-router" class="headerlink" title="React-router"></a>React-router</h4><p><img src="C:\Users\c\AppData\Roaming\Typora\typora-user-images\image-20220827100310787.png" alt="image-20220827100310787"></p>
<p>router4&#x2F;5</p>
<p><img src="C:\Users\c\AppData\Roaming\Typora\typora-user-images\image-20220827143133873.png" alt="image-20220827143133873"></p>
<p><img src="C:\Users\c\AppData\Roaming\Typora\typora-user-images\image-20220827143051277.png" alt="image-20220827143051277"></p>
<p>如果此时路由既满足了前三个，第四个第五个依然会显示  那是因为第四个是动态路由，第五个匹配所有路由  只要满足就显示 ，所以如果要只显示匹配到的哪一个  就需要使用switch组件在外面包裹</p>
<p> <img src="C:\Users\c\AppData\Roaming\Typora\typora-user-images\image-20220827144511249.png" alt="image-20220827144511249"></p>
<p><img src="C:\Users\c\AppData\Roaming\Typora\typora-user-images\image-20220827144721190.png" alt="image-20220827144721190"></p>
<p>编程式路由导航</p>
<p>通过路由渲染出来的组件，v5的时候  路由对props进行了增强吗，可以通过props去做编程式导航</p>
<p><img src="C:\Users\c\AppData\Roaming\Typora\typora-user-images\image-20220827162453163.png" alt="image-20220827162453163"></p>
<p>如果想要所有组件的props都被增强  就要使用withRouter，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">withRouter(App)</span><br><span class="line"></span><br><span class="line">再去使用app时  需要在App最外层用路由包裹</span><br><span class="line">这样才会对props进行增强</span><br><span class="line">&lt;BrowserRouter&gt;</span><br><span class="line">	&lt;App&gt;&lt;/App&gt;</span><br><span class="line">&lt;/BrowserRouter&gt;</span><br></pre></td></tr></table></figure>

<p> <img src="C:\Users\c\AppData\Roaming\Typora\typora-user-images\image-20220828105017835.png" alt="image-20220828105017835"></p>
<p>如果想要想vue中一样去写路由配置表 需要使用一个库  react-router-config  react18中不需要再使用这个库 router6中可以使用</p>
<p><img src="C:\Users\c\AppData\Roaming\Typora\typora-user-images\image-20220828105140702.png" alt="image-20220828105140702"></p>
<p>子路由配置后还需要在组件中使用</p>
<p><img src="C:\Users\c\AppData\Roaming\Typora\typora-user-images\image-20220828112937224.png" alt="image-20220828112937224"></p>
<p><img src="C:\Users\c\AppData\Roaming\Typora\typora-user-images\image-20220828112945968.png" alt="image-20220828112945968"></p>
<h4 id="Hooks"><a href="#Hooks" class="headerlink" title="Hooks"></a>Hooks</h4><p><img src="C:\Users\c\AppData\Roaming\Typora\typora-user-images\image-20220828125713493.png" alt="image-20220828125713493">	<img src="C:\Users\c\AppData\Roaming\Typora\typora-user-images\image-20220828134258374.png" alt="image-20220828134258374"></p>
<p> <img src="C:\Users\c\AppData\Roaming\Typora\typora-user-images\image-20220828160712753.png" alt="image-20220828160712753"></p>
<h4 id="useCallback和useMemo区别"><a href="#useCallback和useMemo区别" class="headerlink" title="useCallback和useMemo区别"></a>useCallback和useMemo区别</h4><p>useCallback其实是对其传入的回调函数做优化，哪里用到了这个回调函数，他所没有依赖的变量发生变化时，该回调函数，不会做多余的执行</p>
<p>useMemo时对其传入的回调函数的返回值做优化，哪里用到了该返回值，他所没有依赖的变量发生变化时，该返回值所用到的组件不会重新渲染</p>
<p><img src="C:\Users\c\AppData\Roaming\Typora\typora-user-images\image-20220829103441976.png" alt="image-20220829103441976"></p>
<h4 id="Fiber原理"><a href="#Fiber原理" class="headerlink" title="Fiber原理"></a>Fiber原理</h4><p>GUI的渲染和JavaScript的代码执行是在一个线程：互斥</p>
<p>JavaScript代码执行时，不会执行GUI的渲染，因为JavaScript是单线程的</p>
<p>（用户事件的响应，键盘事件响应，js代码执行，raf（requestAnimationFrameCallback中的回调），layout布局，paint绘制）都是在一个线程的</p>
<p><img src="C:\Users\c\AppData\Roaming\Typora\typora-user-images\image-20220829144800545.png" alt="image-20220829144800545"></p>
<p>因为GUI的渲染与JavaScript的代码执行是在一个线程中，当去执行JavaScript代码时，GUI的渲染就会被中断，一旦某段代码耗时过长就会造成页面卡顿，所以react为了解决这个问题，就提出了fiber碎片化，当浏览器去执行一些用户事件的响应，键盘事件响应，把该执行的代码以及必须执行的代码执行完，就会去执行浏览器所提供的一个函数requestIdleCallback函数中的回调函数，浏览器一有空闲时间就会去执行回调函数中的fiber碎片：比如说，浏览器一帧16.666ms，其中一帧中的10ms去执行用户事件的响应，剩下的6.66ms就会去赶紧执行requestIdleCallback中的fiber碎片。这样就避免了一些比较耗时的操作，引起的页面卡顿，因为耗时的操作都被变成Fiber碎片，并在浏览器闲余时间执行。</p>
<p>但requestIdleCallback这个函数有兼容问题，所以有的浏览器没有这个函数，所有react自己实现了一个叫做Channel函数来替代requesIdleCallback函数</p>
<h4 id="路由中相关的hook"><a href="#路由中相关的hook" class="headerlink" title="路由中相关的hook"></a>路由中相关的hook</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const element = useRoutes(router)   element就是所需要渲染的元素</span><br><span class="line">const location= useLocation() 可以获取当前路由的一些配置信息</span><br><span class="line"></span><br><span class="line">const params = useParams() 可以获取当前路由所传的参数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">v5版本  const to = useHistory()</span><br><span class="line"></span><br><span class="line">v6版本  const to = useNavigate() //返回一个方法  ，可以做编程式路由导航 </span><br><span class="line">	//to(path,config)</span><br></pre></td></tr></table></figure>

<p>​	这里面的path&#x3D;’&#x2F;user&#x2F;<em>‘表示 可以匹配User组件中的二级路由  一定要写</em><img src="C:\Users\c\AppData\Roaming\Typora\typora-user-images\image-20220829171149761.png" alt="image-20220829171149761"></p>
<p>路由匹配404页面</p>
<p><img src="C:\Users\c\AppData\Roaming\Typora\typora-user-images\image-20220829171419859.png" alt="image-20220829171419859"></p>
<p>二级路由匹配404</p>
<p><img src="C:\Users\c\AppData\Roaming\Typora\typora-user-images\image-20220829171535790.png" alt="image-20220829171535790"></p>
<p>路由懒加载</p>
<p><img src="C:\Users\c\AppData\Roaming\Typora\typora-user-images\image-20220829175503243.png" alt="image-20220829175503243"></p>
<p><img src="C:\Users\c\AppData\Roaming\Typora\typora-user-images\image-20220829175602113.png" alt="image-20220829175602113"></p>
<p>避免闪屏，可以将首页不进行懒加载 ，只对其内容进行懒加载</p>
<p><img src="C:\Users\c\AppData\Roaming\Typora\typora-user-images\image-20220829180321206.png" alt="image-20220829180321206"></p>
<p><img src="C:\Users\c\AppData\Roaming\Typora\typora-user-images\image-20220829191240082.png" alt="image-20220829191240082"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/11/01/React/" data-id="claxeer9p000cv8w14u1ageaz" data-title="React" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-VUE3笔记" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/11/01/VUE3%E7%AC%94%E8%AE%B0/" class="article-date">
  <time class="dt-published" datetime="2022-11-01T01:16:51.000Z" itemprop="datePublished">2022-11-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/11/01/VUE3%E7%AC%94%E8%AE%B0/">VUE3笔记</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h1><h2 id="脚手架文件结构"><a href="#脚手架文件结构" class="headerlink" title="脚手架文件结构"></a>脚手架文件结构</h2><pre><code>├── node_modules 
├── public
│   ├── favicon.ico: 页签图标
│   └── index.html: 主页面
├── src
│   ├── assets: 存放静态资源
│   │   └── logo.png
│   │── component: 存放组件
│   │   └── HelloWorld.vue
│   │── App.vue: 汇总所有组件
│   │── main.js: 入口文件
├── .gitignore: git版本管制忽略的配置
├── babel.config.js: babel的配置文件
├── package.json: 应用包配置文件 
├── README.md: 应用描述文件
├── package-lock.json：包版本控制文件
</code></pre>
<h2 id="关于不同版本的Vue"><a href="#关于不同版本的Vue" class="headerlink" title="关于不同版本的Vue"></a>关于不同版本的Vue</h2><ol>
<li>vue.js与vue.runtime.xxx.js的区别：<ol>
<li>vue.js是完整版的Vue，包含：核心功能 + 模板解析器。</li>
<li>vue.runtime.xxx.js是运行版的Vue，只包含：核心功能；没有模板解析器。</li>
</ol>
</li>
<li>因为vue.runtime.xxx.js没有模板解析器，所以不能使用template这个配置项，需要使用render函数接收到的createElement函数去指定具体内容。</li>
</ol>
<h2 id="vue-config-js配置文件"><a href="#vue-config-js配置文件" class="headerlink" title="vue.config.js配置文件"></a>vue.config.js配置文件</h2><ol>
<li>使用vue inspect &gt; output.js可以查看到Vue脚手架的默认配置。</li>
<li>使用vue.config.js可以对脚手架进行个性化定制，详情见：<a target="_blank" rel="noopener" href="https://cli.vuejs.org/zh">https://cli.vuejs.org/zh</a></li>
</ol>
<h2 id="ref属性"><a href="#ref属性" class="headerlink" title="ref属性"></a>ref属性</h2><ol>
<li>被用来给元素或子组件注册引用信息（id的替代者）</li>
<li>应用在html标签上获取的是真实DOM元素，应用在组件标签上是组件实例对象（vc）</li>
<li>使用方式：<ol>
<li>打标识：<code>&lt;h1 ref=&quot;xxx&quot;&gt;.....&lt;/h1&gt;</code> 或 <code>&lt;School ref=&quot;xxx&quot;&gt;&lt;/School&gt;</code></li>
<li>获取：<code>this.$refs.xxx</code></li>
</ol>
</li>
</ol>
<h2 id="props配置项"><a href="#props配置项" class="headerlink" title="props配置项"></a>props配置项</h2><ol>
<li><p>功能：让组件接收外部传过来的数据</p>
</li>
<li><p>传递数据：<code>&lt;Demo name=&quot;xxx&quot;/&gt;</code></p>
</li>
<li><p>接收数据：</p>
<ol>
<li><p>第一种方式（只接收）：<code>props:[&#39;name&#39;] </code></p>
</li>
<li><p>第二种方式（限制类型）：<code>props:&#123;name:String&#125;</code></p>
</li>
<li><p>第三种方式（限制类型、限制必要性、指定默认值）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">props</span>:&#123;</span><br><span class="line">	<span class="attr">name</span>:&#123;</span><br><span class="line">	<span class="attr">type</span>:<span class="title class_">String</span>, <span class="comment">//类型</span></span><br><span class="line">	<span class="attr">required</span>:<span class="literal">true</span>, <span class="comment">//必要性</span></span><br><span class="line">	<span class="attr">default</span>:<span class="string">&#x27;老王&#x27;</span> <span class="comment">//默认值</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p>备注：props是只读的，Vue底层会监测你对props的修改，如果进行了修改，就会发出警告，若业务需求确实需要修改，那么请复制props的内容到data中一份，然后去修改data中的数据。</p>
</blockquote>
</li>
</ol>
<h2 id="mixin-混入"><a href="#mixin-混入" class="headerlink" title="mixin(混入)"></a>mixin(混入)</h2><ol>
<li><p>功能：可以把多个组件共用的配置提取成一个混入对象</p>
</li>
<li><p>使用方式：</p>
<p>第一步定义混合：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    data()&#123;....&#125;,</span><br><span class="line">    methods:&#123;....&#125;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二步使用混入：</p>
<p>​	全局混入：<code>Vue.mixin(xxx)</code><br>​	局部混入：<code>mixins:[&#39;xxx&#39;]	</code></p>
</li>
</ol>
<h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><ol>
<li><p>功能：用于增强Vue</p>
</li>
<li><p>本质：包含install方法的一个对象，install的第一个参数是Vue，第二个以后的参数是插件使用者传递的数据。</p>
</li>
<li><p>定义插件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">对象.<span class="property">install</span> = <span class="keyword">function</span> (<span class="params">Vue, options</span>) &#123;</span><br><span class="line">    <span class="comment">// 1. 添加全局过滤器</span></span><br><span class="line">    <span class="title class_">Vue</span>.<span class="title function_">filter</span>(....)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 添加全局指令</span></span><br><span class="line">    <span class="title class_">Vue</span>.<span class="title function_">directive</span>(....)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 配置全局混入(合)</span></span><br><span class="line">    <span class="title class_">Vue</span>.<span class="title function_">mixin</span>(....)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 添加实例方法</span></span><br><span class="line">    <span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$myMethod</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;...&#125;</span><br><span class="line">    <span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$myProperty</span> = xxxx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用插件：<code>Vue.use()</code></p>
</li>
</ol>
<h2 id="scoped样式"><a href="#scoped样式" class="headerlink" title="scoped样式"></a>scoped样式</h2><ol>
<li>作用：让样式在局部生效，防止冲突。</li>
<li>写法：<code>&lt;style scoped&gt;</code></li>
</ol>
<h2 id="总结TodoList案例"><a href="#总结TodoList案例" class="headerlink" title="总结TodoList案例"></a>总结TodoList案例</h2><ol>
<li><p>组件化编码流程：</p>
<p>​	(1).拆分静态组件：组件要按照功能点拆分，命名不要与html元素冲突。</p>
<p>​	(2).实现动态组件：考虑好数据的存放位置，数据是一个组件在用，还是一些组件在用：</p>
<p>​			1).一个组件在用：放在组件自身即可。</p>
<p>​			2). 一些组件在用：放在他们共同的父组件上（<span style="color:red">状态提升</span>）。</p>
<p>​	(3).实现交互：从绑定事件开始。</p>
</li>
<li><p>props适用于：</p>
<p>​	(1).父组件 &#x3D;&#x3D;&gt; 子组件 通信</p>
<p>​	(2).子组件 &#x3D;&#x3D;&gt; 父组件 通信（要求父先给子一个函数）</p>
</li>
<li><p>使用v-model时要切记：v-model绑定的值不能是props传过来的值，因为props是不可以修改的！</p>
</li>
<li><p>props传过来的若是对象类型的值，修改对象中的属性时Vue不会报错，但不推荐这样做。</p>
</li>
</ol>
<h2 id="webStorage"><a href="#webStorage" class="headerlink" title="webStorage"></a>webStorage</h2><ol>
<li><p>存储内容大小一般支持5MB左右（不同浏览器可能还不一样）</p>
</li>
<li><p>浏览器端通过 Window.sessionStorage 和 Window.localStorage 属性来实现本地存储机制。</p>
</li>
<li><p>相关API：</p>
<ol>
<li><p><code>xxxxxStorage.setItem(&#39;key&#39;, &#39;value&#39;);</code><br>             该方法接受一个键和值作为参数，会把键值对添加到存储中，如果键名存在，则更新其对应的值。</p>
</li>
<li><p><code>xxxxxStorage.getItem(&#39;person&#39;);</code></p>
<p>​		该方法接受一个键名作为参数，返回键名对应的值。</p>
</li>
<li><p><code>xxxxxStorage.removeItem(&#39;key&#39;);</code></p>
<p>​		该方法接受一个键名作为参数，并把该键名从存储中删除。</p>
</li>
<li><p><code> xxxxxStorage.clear()</code></p>
<p>​		该方法会清空存储中的所有数据。</p>
</li>
</ol>
</li>
<li><p>备注：</p>
<ol>
<li>SessionStorage存储的内容会随着浏览器窗口关闭而消失。</li>
<li>LocalStorage存储的内容，需要手动清除才会消失。</li>
<li><code>xxxxxStorage.getItem(xxx)</code>如果xxx对应的value获取不到，那么getItem的返回值是null。</li>
<li><code>JSON.parse(null)</code>的结果依然是null。</li>
</ol>
</li>
</ol>
<h2 id="组件的自定义事件"><a href="#组件的自定义事件" class="headerlink" title="组件的自定义事件"></a>组件的自定义事件</h2><ol>
<li><p>一种组件间通信的方式，适用于：<strong style="color:red">子组件 &#x3D;&#x3D;&#x3D;&gt; 父组件</strong></p>
</li>
<li><p>使用场景：A是父组件，B是子组件，B想给A传数据，那么就要在A中给B绑定自定义事件（<span style="color:red">事件的回调在A中</span>）。</p>
</li>
<li><p>绑定自定义事件：</p>
<ol>
<li><p>第一种方式，在父组件中：<code>&lt;Demo @atguigu=&quot;test&quot;/&gt;</code>  或 <code>&lt;Demo v-on:atguigu=&quot;test&quot;/&gt;</code></p>
</li>
<li><p>第二种方式，在父组件中：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Demo</span> ref=<span class="string">&quot;demo&quot;</span>/&gt;</span><br><span class="line">......</span><br><span class="line"><span class="title function_">mounted</span>(<span class="params"></span>)&#123;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">xxx</span>.$on(<span class="string">&#x27;atguigu&#x27;</span>,<span class="variable language_">this</span>.<span class="property">test</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>若想让自定义事件只能触发一次，可以使用<code>once</code>修饰符，或<code>$once</code>方法。</p>
</li>
</ol>
</li>
<li><p>触发自定义事件：<code>this.$emit(&#39;atguigu&#39;,数据)</code>		</p>
</li>
<li><p>解绑自定义事件<code>this.$off(&#39;atguigu&#39;)</code></p>
</li>
<li><p>组件上也可以绑定原生DOM事件，需要使用<code>native</code>修饰符。</p>
</li>
<li><p>注意：通过<code>this.$refs.xxx.$on(&#39;atguigu&#39;,回调)</code>绑定自定义事件时，回调<span style="color:red">要么配置在methods中</span>，<span style="color:red">要么用箭头函数</span>，否则this指向会出问题！</p>
</li>
</ol>
<h2 id="全局事件总线（GlobalEventBus）"><a href="#全局事件总线（GlobalEventBus）" class="headerlink" title="全局事件总线（GlobalEventBus）"></a>全局事件总线（GlobalEventBus）</h2><ol>
<li><p>一种组件间通信的方式，适用于<span style="color:red">任意组件间通信</span>。</p>
</li>
<li><p>安装全局事件总线：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">	......</span><br><span class="line">	<span class="title function_">beforeCreate</span>(<span class="params"></span>) &#123;</span><br><span class="line">		<span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$bus</span> = <span class="variable language_">this</span> <span class="comment">//安装全局事件总线，$bus就是当前应用的vm</span></span><br><span class="line">	&#125;,</span><br><span class="line">    ......</span><br><span class="line">&#125;) </span><br></pre></td></tr></table></figure>
</li>
<li><p>使用事件总线：</p>
<ol>
<li><p>接收数据：A组件想接收数据，则在A组件中给$bus绑定自定义事件，事件的<span style="color:red">回调留在A组件自身。</span></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">methods</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="title function_">demo</span>(<span class="params">data</span>)&#123;......&#125;</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"><span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">$bus</span>.$on(<span class="string">&#x27;xxxx&#x27;</span>,<span class="variable language_">this</span>.<span class="property">demo</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>提供数据：<code>this.$bus.$emit(&#39;xxxx&#39;,数据)</code></p>
</li>
</ol>
</li>
<li><p>最好在beforeDestroy钩子中，用$off去解绑<span style="color:red">当前组件所用到的</span>事件。</p>
</li>
</ol>
<h2 id="消息订阅与发布（pubsub）"><a href="#消息订阅与发布（pubsub）" class="headerlink" title="消息订阅与发布（pubsub）"></a>消息订阅与发布（pubsub）</h2><ol>
<li><p>一种组件间通信的方式，适用于<span style="color:red">任意组件间通信</span>。</p>
</li>
<li><p>使用步骤：</p>
<ol>
<li><p>安装pubsub：<code>npm i pubsub-js</code></p>
</li>
<li><p>引入: <code>import pubsub from &#39;pubsub-js&#39;</code></p>
</li>
<li><p>接收数据：A组件想接收数据，则在A组件中订阅消息，订阅的<span style="color:red">回调留在A组件自身。</span></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">methods</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="title function_">demo</span>(<span class="params">data</span>)&#123;......&#125;</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"><span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">pid</span> = pubsub.<span class="title function_">subscribe</span>(<span class="string">&#x27;xxx&#x27;</span>,<span class="variable language_">this</span>.<span class="property">demo</span>) <span class="comment">//订阅消息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>提供数据：<code>pubsub.publish(&#39;xxx&#39;,数据)</code></p>
</li>
<li><p>最好在beforeDestroy钩子中，用<code>PubSub.unsubscribe(pid)</code>去<span style="color:red">取消订阅。</span></p>
</li>
</ol>
</li>
</ol>
<h2 id="nextTick"><a href="#nextTick" class="headerlink" title="nextTick"></a>nextTick</h2><ol>
<li>语法：<code>this.$nextTick(回调函数)</code></li>
<li>作用：在下一次 DOM 更新结束后执行其指定的回调。</li>
<li>什么时候用：当改变数据后，要基于更新后的新DOM进行某些操作时，要在nextTick所指定的回调函数中执行。</li>
</ol>
<h2 id="Vue封装的过度与动画"><a href="#Vue封装的过度与动画" class="headerlink" title="Vue封装的过度与动画"></a>Vue封装的过度与动画</h2><ol>
<li><p>作用：在插入、更新或移除 DOM元素时，在合适的时候给元素添加样式类名。</p>
</li>
<li><p>图示：<img src="https://img04.sogoucdn.com/app/a/100520146/5990c1dff7dc7a8fb3b34b4462bd0105" style="width:60%" /></p>
</li>
<li><p>写法：</p>
<ol>
<li><p>准备好样式：</p>
<ul>
<li>元素进入的样式：<ol>
<li>v-enter：进入的起点</li>
<li>v-enter-active：进入过程中</li>
<li>v-enter-to：进入的终点</li>
</ol>
</li>
<li>元素离开的样式：<ol>
<li>v-leave：离开的起点</li>
<li>v-leave-active：离开过程中</li>
<li>v-leave-to：离开的终点</li>
</ol>
</li>
</ul>
</li>
<li><p>使用<code>&lt;transition&gt;</code>包裹要过度的元素，并配置name属性：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;transition name=&quot;hello&quot;&gt;</span><br><span class="line">	&lt;h1 v-show=&quot;isShow&quot;&gt;你好啊！&lt;/h1&gt;</span><br><span class="line">&lt;/transition&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>备注：若有多个元素需要过度，则需要使用：<code>&lt;transition-group&gt;</code>，且每个元素都要指定<code>key</code>值。</p>
</li>
</ol>
</li>
</ol>
<h2 id="vue脚手架配置代理"><a href="#vue脚手架配置代理" class="headerlink" title="vue脚手架配置代理"></a>vue脚手架配置代理</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>​	在vue.config.js中添加如下配置：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">devServer</span>:&#123;</span><br><span class="line">  <span class="attr">proxy</span>:<span class="string">&quot;http://localhost:5000&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ol>
<li>优点：配置简单，请求资源时直接发给前端（8080）即可。</li>
<li>缺点：不能配置多个代理，不能灵活的控制请求是否走代理。</li>
<li>工作方式：若按照上述配置代理，当请求了前端不存在的资源时，那么该请求会转发给服务器 （优先匹配前端资源）</li>
</ol>
<h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>​	编写vue.config.js配置具体代理规则：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">	<span class="attr">devServer</span>: &#123;</span><br><span class="line">      <span class="attr">proxy</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;/api1&#x27;</span>: &#123;<span class="comment">// 匹配所有以 &#x27;/api1&#x27;开头的请求路径</span></span><br><span class="line">        <span class="attr">target</span>: <span class="string">&#x27;http://localhost:5000&#x27;</span>,<span class="comment">// 代理目标的基础路径</span></span><br><span class="line">        <span class="attr">changeOrigin</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">pathRewrite</span>: &#123;<span class="string">&#x27;^/api1&#x27;</span>: <span class="string">&#x27;&#x27;</span>&#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="string">&#x27;/api2&#x27;</span>: &#123;<span class="comment">// 匹配所有以 &#x27;/api2&#x27;开头的请求路径</span></span><br><span class="line">        <span class="attr">target</span>: <span class="string">&#x27;http://localhost:5001&#x27;</span>,<span class="comment">// 代理目标的基础路径</span></span><br><span class="line">        <span class="attr">changeOrigin</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">pathRewrite</span>: &#123;<span class="string">&#x27;^/api2&#x27;</span>: <span class="string">&#x27;&#x27;</span>&#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   changeOrigin设置为true时，服务器收到的请求头中的host为：localhost:5000</span></span><br><span class="line"><span class="comment">   changeOrigin设置为false时，服务器收到的请求头中的host为：localhost:8080</span></span><br><span class="line"><span class="comment">   changeOrigin默认值为true</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ol>
<li>优点：可以配置多个代理，且可以灵活的控制请求是否走代理。</li>
<li>缺点：配置略微繁琐，请求资源时必须加前缀。</li>
</ol>
<h2 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h2><ol>
<li><p>作用：让父组件可以向子组件指定位置插入html结构，也是一种组件间通信的方式，适用于 <strong style="color:red">父组件 &#x3D;&#x3D;&#x3D;&gt; 子组件</strong> 。</p>
</li>
<li><p>分类：默认插槽、具名插槽、作用域插槽</p>
</li>
<li><p>使用方式：</p>
<ol>
<li><p>默认插槽：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">父组件中：</span><br><span class="line">        &lt;Category&gt;</span><br><span class="line">           &lt;div&gt;html结构1&lt;/div&gt;</span><br><span class="line">        &lt;/Category&gt;</span><br><span class="line">子组件中：</span><br><span class="line">        &lt;template&gt;</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">               &lt;!-- 定义插槽 --&gt;</span><br><span class="line">               &lt;slot&gt;插槽默认内容...&lt;/slot&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/template&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>具名插槽：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">父组件中：</span><br><span class="line">        &lt;Category&gt;</span><br><span class="line">            &lt;template slot=&quot;center&quot;&gt;</span><br><span class="line">              &lt;div&gt;html结构1&lt;/div&gt;</span><br><span class="line">            &lt;/template&gt;</span><br><span class="line"></span><br><span class="line">            &lt;template v-slot:footer&gt;</span><br><span class="line">               &lt;div&gt;html结构2&lt;/div&gt;</span><br><span class="line">            &lt;/template&gt;</span><br><span class="line">        &lt;/Category&gt;</span><br><span class="line">子组件中：</span><br><span class="line">        &lt;template&gt;</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">               &lt;!-- 定义插槽 --&gt;</span><br><span class="line">               &lt;slot name=&quot;center&quot;&gt;插槽默认内容...&lt;/slot&gt;</span><br><span class="line">               &lt;slot name=&quot;footer&quot;&gt;插槽默认内容...&lt;/slot&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/template&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>作用域插槽：</p>
<ol>
<li><p>理解：<span style="color:red">数据在组件的自身，但根据数据生成的结构需要组件的使用者来决定。</span>（games数据在Category组件中，但使用数据所遍历出来的结构由App组件决定）</p>
</li>
<li><p>具体编码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">父组件中：</span><br><span class="line">		&lt;Category&gt;</span><br><span class="line">			&lt;template scope=&quot;scopeData&quot;&gt;</span><br><span class="line">				&lt;!-- 生成的是ul列表 --&gt;</span><br><span class="line">				&lt;ul&gt;</span><br><span class="line">					&lt;li v-for=&quot;g in scopeData.games&quot; :key=&quot;g&quot;&gt;&#123;&#123;g&#125;&#125;&lt;/li&gt;</span><br><span class="line">				&lt;/ul&gt;</span><br><span class="line">			&lt;/template&gt;</span><br><span class="line">		&lt;/Category&gt;</span><br><span class="line"></span><br><span class="line">		&lt;Category&gt;</span><br><span class="line">			&lt;template slot-scope=&quot;scopeData&quot;&gt;</span><br><span class="line">				&lt;!-- 生成的是h4标题 --&gt;</span><br><span class="line">				&lt;h4 v-for=&quot;g in scopeData.games&quot; :key=&quot;g&quot;&gt;&#123;&#123;g&#125;&#125;&lt;/h4&gt;</span><br><span class="line">			&lt;/template&gt;</span><br><span class="line">		&lt;/Category&gt;</span><br><span class="line">子组件中：</span><br><span class="line">        &lt;template&gt;</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;slot :games=&quot;games&quot;&gt;&lt;/slot&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/template&gt;</span><br><span class="line">		</span><br><span class="line">        &lt;script&gt;</span><br><span class="line">            export default &#123;</span><br><span class="line">                name:&#x27;Category&#x27;,</span><br><span class="line">                props:[&#x27;title&#x27;],</span><br><span class="line">                //数据在子组件自身</span><br><span class="line">                data() &#123;</span><br><span class="line">                    return &#123;</span><br><span class="line">                        games:[&#x27;红色警戒&#x27;,&#x27;穿越火线&#x27;,&#x27;劲舞团&#x27;,&#x27;超级玛丽&#x27;]</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">   </span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h2><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h3><p>​		在Vue中实现集中式状态（数据）管理的一个Vue插件，对vue应用中多个组件的共享状态进行集中式的管理（读&#x2F;写），也是一种组件间通信的方式，且适用于任意组件间通信。</p>
<h3 id="2-何时使用？"><a href="#2-何时使用？" class="headerlink" title="2.何时使用？"></a>2.何时使用？</h3><p>​		多个组件需要共享数据时</p>
<h3 id="3-搭建vuex环境"><a href="#3-搭建vuex环境" class="headerlink" title="3.搭建vuex环境"></a>3.搭建vuex环境</h3><ol>
<li><p>创建文件：<code>src/store/index.js</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//引入Vue核心库</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="comment">//引入Vuex</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vuex</span> <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="comment">//应用Vuex插件</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">Vuex</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//准备actions对象——响应组件中用户的动作</span></span><br><span class="line"><span class="keyword">const</span> actions = &#123;&#125;</span><br><span class="line"><span class="comment">//准备mutations对象——修改state中的数据</span></span><br><span class="line"><span class="keyword">const</span> mutations = &#123;&#125;</span><br><span class="line"><span class="comment">//准备state对象——保存具体的数据</span></span><br><span class="line"><span class="keyword">const</span> state = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建并暴露store</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">	actions,</span><br><span class="line">	mutations,</span><br><span class="line">	state</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>main.js</code>中创建vm时传入<code>store</code>配置项</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line"><span class="comment">//引入store</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;./store&#x27;</span></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建vm</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">	<span class="attr">el</span>:<span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">	<span class="attr">render</span>: <span class="function"><span class="params">h</span> =&gt;</span> <span class="title function_">h</span>(<span class="title class_">App</span>),</span><br><span class="line">	store</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="4-基本使用"><a href="#4-基本使用" class="headerlink" title="4.基本使用"></a>4.基本使用</h3><ol>
<li><p>初始化数据、配置<code>actions</code>、配置<code>mutations</code>，操作文件<code>store.js</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//引入Vue核心库</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="comment">//引入Vuex</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vuex</span> <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="comment">//引用Vuex</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">Vuex</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> actions = &#123;</span><br><span class="line">    <span class="comment">//响应组件中加的动作</span></span><br><span class="line">	<span class="title function_">jia</span>(<span class="params">context,value</span>)&#123;</span><br><span class="line">		<span class="comment">// console.log(&#x27;actions中的jia被调用了&#x27;,miniStore,value)</span></span><br><span class="line">		context.<span class="title function_">commit</span>(<span class="string">&#x27;JIA&#x27;</span>,value)</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mutations = &#123;</span><br><span class="line">    <span class="comment">//执行加</span></span><br><span class="line">	<span class="title function_">JIA</span>(<span class="params">state,value</span>)&#123;</span><br><span class="line">		<span class="comment">// console.log(&#x27;mutations中的JIA被调用了&#x27;,state,value)</span></span><br><span class="line">		state.<span class="property">sum</span> += value</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化数据</span></span><br><span class="line"><span class="keyword">const</span> state = &#123;</span><br><span class="line">   <span class="attr">sum</span>:<span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建并暴露store</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">	actions,</span><br><span class="line">	mutations,</span><br><span class="line">	state,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>组件中读取vuex中的数据：<code>$store.state.sum</code></p>
</li>
<li><p>组件中修改vuex中的数据：<code>$store.dispatch(&#39;action中的方法名&#39;,数据)</code> 或 <code>$store.commit(&#39;mutations中的方法名&#39;,数据)</code></p>
<blockquote>
<p> 备注：若没有网络请求或其他业务逻辑，组件中也可以越过actions，即不写<code>dispatch</code>，直接编写<code>commit</code></p>
</blockquote>
</li>
</ol>
<h3 id="5-getters的使用"><a href="#5-getters的使用" class="headerlink" title="5.getters的使用"></a>5.getters的使用</h3><ol>
<li><p>概念：当state中的数据需要经过加工后再使用时，可以使用getters加工。</p>
</li>
<li><p>在<code>store.js</code>中追加<code>getters</code>配置</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getters = &#123;</span><br><span class="line">	<span class="title function_">bigSum</span>(<span class="params">state</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> state.<span class="property">sum</span> * <span class="number">10</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建并暴露store</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">	......</span><br><span class="line">	getters</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>组件中读取数据：<code>$store.getters.bigSum</code></p>
</li>
</ol>
<h3 id="6-四个map方法的使用"><a href="#6-四个map方法的使用" class="headerlink" title="6.四个map方法的使用"></a>6.四个map方法的使用</h3><ol>
<li><p><strong>mapState方法：</strong>用于帮助我们映射<code>state</code>中的数据为计算属性</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line">    <span class="comment">//借助mapState生成计算属性：sum、school、subject（对象写法）</span></span><br><span class="line">     ...<span class="title function_">mapState</span>(&#123;<span class="attr">sum</span>:<span class="string">&#x27;sum&#x27;</span>,<span class="attr">school</span>:<span class="string">&#x27;school&#x27;</span>,<span class="attr">subject</span>:<span class="string">&#x27;subject&#x27;</span>&#125;),</span><br><span class="line">         </span><br><span class="line">    <span class="comment">//借助mapState生成计算属性：sum、school、subject（数组写法）</span></span><br><span class="line">    ...<span class="title function_">mapState</span>([<span class="string">&#x27;sum&#x27;</span>,<span class="string">&#x27;school&#x27;</span>,<span class="string">&#x27;subject&#x27;</span>]),</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>mapGetters方法：</strong>用于帮助我们映射<code>getters</code>中的数据为计算属性</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line">    <span class="comment">//借助mapGetters生成计算属性：bigSum（对象写法）</span></span><br><span class="line">    ...<span class="title function_">mapGetters</span>(&#123;<span class="attr">bigSum</span>:<span class="string">&#x27;bigSum&#x27;</span>&#125;),</span><br><span class="line"></span><br><span class="line">    <span class="comment">//借助mapGetters生成计算属性：bigSum（数组写法）</span></span><br><span class="line">    ...<span class="title function_">mapGetters</span>([<span class="string">&#x27;bigSum&#x27;</span>])</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>mapActions方法：</strong>用于帮助我们生成与<code>actions</code>对话的方法，即：包含<code>$store.dispatch(xxx)</code>的函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">methods</span>:&#123;</span><br><span class="line">    <span class="comment">//靠mapActions生成：incrementOdd、incrementWait（对象形式）</span></span><br><span class="line">    ...<span class="title function_">mapActions</span>(&#123;<span class="attr">incrementOdd</span>:<span class="string">&#x27;jiaOdd&#x27;</span>,<span class="attr">incrementWait</span>:<span class="string">&#x27;jiaWait&#x27;</span>&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//靠mapActions生成：incrementOdd、incrementWait（数组形式）</span></span><br><span class="line">    ...<span class="title function_">mapActions</span>([<span class="string">&#x27;jiaOdd&#x27;</span>,<span class="string">&#x27;jiaWait&#x27;</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>mapMutations方法：</strong>用于帮助我们生成与<code>mutations</code>对话的方法，即：包含<code>$store.commit(xxx)</code>的函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">methods</span>:&#123;</span><br><span class="line">    <span class="comment">//靠mapActions生成：increment、decrement（对象形式）</span></span><br><span class="line">    ...<span class="title function_">mapMutations</span>(&#123;<span class="attr">increment</span>:<span class="string">&#x27;JIA&#x27;</span>,<span class="attr">decrement</span>:<span class="string">&#x27;JIAN&#x27;</span>&#125;),</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//靠mapMutations生成：JIA、JIAN（对象形式）</span></span><br><span class="line">    ...<span class="title function_">mapMutations</span>([<span class="string">&#x27;JIA&#x27;</span>,<span class="string">&#x27;JIAN&#x27;</span>]),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p>备注：mapActions与mapMutations使用时，若需要传递参数需要：在模板中绑定事件时传递好参数，否则参数是事件对象。</p>
</blockquote>
<h3 id="7-模块化-命名空间"><a href="#7-模块化-命名空间" class="headerlink" title="7.模块化+命名空间"></a>7.模块化+命名空间</h3><ol>
<li><p>目的：让代码更好维护，让多种数据分类更加明确。</p>
</li>
<li><p>修改<code>store.js</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> countAbout = &#123;</span><br><span class="line">  <span class="attr">namespaced</span>:<span class="literal">true</span>,<span class="comment">//开启命名空间</span></span><br><span class="line">  <span class="attr">state</span>:&#123;<span class="attr">x</span>:<span class="number">1</span>&#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123; ... &#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123; ... &#125;,</span><br><span class="line">  <span class="attr">getters</span>: &#123;</span><br><span class="line">    <span class="title function_">bigSum</span>(<span class="params">state</span>)&#123;</span><br><span class="line">       <span class="keyword">return</span> state.<span class="property">sum</span> * <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> personAbout = &#123;</span><br><span class="line">  <span class="attr">namespaced</span>:<span class="literal">true</span>,<span class="comment">//开启命名空间</span></span><br><span class="line">  <span class="attr">state</span>:&#123; ... &#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123; ... &#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">  <span class="attr">modules</span>: &#123;</span><br><span class="line">    countAbout,</span><br><span class="line">    personAbout</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>开启命名空间后，组件中读取state数据：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式一：自己直接读取</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$store</span>.<span class="property">state</span>.<span class="property">personAbout</span>.<span class="property">list</span></span><br><span class="line"><span class="comment">//方式二：借助mapState读取：</span></span><br><span class="line">...<span class="title function_">mapState</span>(<span class="string">&#x27;countAbout&#x27;</span>,[<span class="string">&#x27;sum&#x27;</span>,<span class="string">&#x27;school&#x27;</span>,<span class="string">&#x27;subject&#x27;</span>]),</span><br></pre></td></tr></table></figure>
</li>
<li><p>开启命名空间后，组件中读取getters数据：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式一：自己直接读取</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$store</span>.<span class="property">getters</span>[<span class="string">&#x27;personAbout/firstPersonName&#x27;</span>]</span><br><span class="line"><span class="comment">//方式二：借助mapGetters读取：</span></span><br><span class="line">...<span class="title function_">mapGetters</span>(<span class="string">&#x27;countAbout&#x27;</span>,[<span class="string">&#x27;bigSum&#x27;</span>])</span><br></pre></td></tr></table></figure>
</li>
<li><p>开启命名空间后，组件中调用dispatch</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式一：自己直接dispatch</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">dispatch</span>(<span class="string">&#x27;personAbout/addPersonWang&#x27;</span>,person)</span><br><span class="line"><span class="comment">//方式二：借助mapActions：</span></span><br><span class="line">...<span class="title function_">mapActions</span>(<span class="string">&#x27;countAbout&#x27;</span>,&#123;<span class="attr">incrementOdd</span>:<span class="string">&#x27;jiaOdd&#x27;</span>,<span class="attr">incrementWait</span>:<span class="string">&#x27;jiaWait&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>开启命名空间后，组件中调用commit</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式一：自己直接commit</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">commit</span>(<span class="string">&#x27;personAbout/ADD_PERSON&#x27;</span>,person)</span><br><span class="line"><span class="comment">//方式二：借助mapMutations：</span></span><br><span class="line">...<span class="title function_">mapMutations</span>(<span class="string">&#x27;countAbout&#x27;</span>,&#123;<span class="attr">increment</span>:<span class="string">&#x27;JIA&#x27;</span>,<span class="attr">decrement</span>:<span class="string">&#x27;JIAN&#x27;</span>&#125;),</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><ol>
<li>理解： 一个路由（route）就是一组映射关系（key - value），多个路由需要路由器（router）进行管理。</li>
<li>前端路由：key是路径，value是组件。</li>
</ol>
<h3 id="1-基本使用"><a href="#1-基本使用" class="headerlink" title="1.基本使用"></a>1.基本使用</h3><ol>
<li><p>安装vue-router，命令：<code>npm i vue-router</code></p>
</li>
<li><p>应用插件：<code>Vue.use(VueRouter)</code></p>
</li>
<li><p>编写router配置项:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//引入VueRouter</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">VueRouter</span> <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"><span class="comment">//引入Luyou 组件</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">About</span> <span class="keyword">from</span> <span class="string">&#x27;../components/About&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Home</span> <span class="keyword">from</span> <span class="string">&#x27;../components/Home&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建router实例对象，去管理一组一组的路由规则</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123;</span><br><span class="line">	<span class="attr">routes</span>:[</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="attr">path</span>:<span class="string">&#x27;/about&#x27;</span>,</span><br><span class="line">			<span class="attr">component</span>:<span class="title class_">About</span></span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="attr">path</span>:<span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">			<span class="attr">component</span>:<span class="title class_">Home</span></span><br><span class="line">		&#125;</span><br><span class="line">	]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//暴露router</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现切换（active-class可配置高亮样式）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link active-class=&quot;active&quot; to=&quot;/about&quot;&gt;About&lt;/router-link&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>指定展示位置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-view&gt;&lt;/router-view&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="2-几个注意点"><a href="#2-几个注意点" class="headerlink" title="2.几个注意点"></a>2.几个注意点</h3><ol>
<li>路由组件通常存放在<code>pages</code>文件夹，一般组件通常存放在<code>components</code>文件夹。</li>
<li>通过切换，“隐藏”了的路由组件，默认是被销毁掉的，需要的时候再去挂载。</li>
<li>每个组件都有自己的<code>$route</code>属性，里面存储着自己的路由信息。</li>
<li>整个应用只有一个router，可以通过组件的<code>$router</code>属性获取到。</li>
</ol>
<h3 id="3-多级路由（多级路由）"><a href="#3-多级路由（多级路由）" class="headerlink" title="3.多级路由（多级路由）"></a>3.多级路由（多级路由）</h3><ol>
<li><p>配置路由规则，使用children配置项：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">routes</span>:[</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="attr">path</span>:<span class="string">&#x27;/about&#x27;</span>,</span><br><span class="line">		<span class="attr">component</span>:<span class="title class_">About</span>,</span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="attr">path</span>:<span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">		<span class="attr">component</span>:<span class="title class_">Home</span>,</span><br><span class="line">		<span class="attr">children</span>:[ <span class="comment">//通过children配置子级路由</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="attr">path</span>:<span class="string">&#x27;news&#x27;</span>, <span class="comment">//此处一定不要写：/news</span></span><br><span class="line">				<span class="attr">component</span>:<span class="title class_">News</span></span><br><span class="line">			&#125;,</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="attr">path</span>:<span class="string">&#x27;message&#x27;</span>,<span class="comment">//此处一定不要写：/message</span></span><br><span class="line">				<span class="attr">component</span>:<span class="title class_">Message</span></span><br><span class="line">			&#125;</span><br><span class="line">		]</span><br><span class="line">	&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
</li>
<li><p>跳转（要写完整路径）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link to=&quot;/home/news&quot;&gt;News&lt;/router-link&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="4-路由的query参数"><a href="#4-路由的query参数" class="headerlink" title="4.路由的query参数"></a>4.路由的query参数</h3><ol>
<li><p>传递参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 跳转并携带query参数，to的字符串写法 --&gt;</span><br><span class="line">&lt;router-link :to=&quot;/home/message/detail?id=666&amp;title=你好&quot;&gt;跳转&lt;/router-link&gt;</span><br><span class="line">				</span><br><span class="line">&lt;!-- 跳转并携带query参数，to的对象写法 --&gt;</span><br><span class="line">&lt;router-link </span><br><span class="line">	:to=&quot;&#123;</span><br><span class="line">		path:&#x27;/home/message/detail&#x27;,</span><br><span class="line">		query:&#123;</span><br><span class="line">		   id:666,</span><br><span class="line">            title:&#x27;你好&#x27;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;&quot;</span><br><span class="line">&gt;跳转&lt;/router-link&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>接收参数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$route.<span class="property">query</span>.<span class="property">id</span></span><br><span class="line">$route.<span class="property">query</span>.<span class="property">title</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="5-命名路由"><a href="#5-命名路由" class="headerlink" title="5.命名路由"></a>5.命名路由</h3><ol>
<li><p>作用：可以简化路由的跳转。</p>
</li>
<li><p>如何使用</p>
<ol>
<li><p>给路由命名：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">path</span>:<span class="string">&#x27;/demo&#x27;</span>,</span><br><span class="line">	<span class="attr">component</span>:<span class="title class_">Demo</span>,</span><br><span class="line">	<span class="attr">children</span>:[</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="attr">path</span>:<span class="string">&#x27;test&#x27;</span>,</span><br><span class="line">			<span class="attr">component</span>:<span class="title class_">Test</span>,</span><br><span class="line">			<span class="attr">children</span>:[</span><br><span class="line">				&#123;</span><br><span class="line">                      <span class="attr">name</span>:<span class="string">&#x27;hello&#x27;</span> <span class="comment">//给路由命名</span></span><br><span class="line">					<span class="attr">path</span>:<span class="string">&#x27;welcome&#x27;</span>,</span><br><span class="line">					<span class="attr">component</span>:<span class="title class_">Hello</span>,</span><br><span class="line">				&#125;</span><br><span class="line">			]</span><br><span class="line">		&#125;</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>简化跳转：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--简化前，需要写完整的路径 --&gt;</span><br><span class="line">&lt;router-link to=&quot;/demo/test/welcome&quot;&gt;跳转&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--简化后，直接通过名字跳转 --&gt;</span><br><span class="line">&lt;router-link :to=&quot;&#123;name:&#x27;hello&#x27;&#125;&quot;&gt;跳转&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--简化写法配合传递参数 --&gt;</span><br><span class="line">&lt;router-link </span><br><span class="line">	:to=&quot;&#123;</span><br><span class="line">		name:&#x27;hello&#x27;,</span><br><span class="line">		query:&#123;</span><br><span class="line">		   id:666,</span><br><span class="line">            title:&#x27;你好&#x27;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;&quot;</span><br><span class="line">&gt;跳转&lt;/router-link&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h3 id="6-路由的params参数"><a href="#6-路由的params参数" class="headerlink" title="6.路由的params参数"></a>6.路由的params参数</h3><ol>
<li><p>配置路由，声明接收params参数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">path</span>:<span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">	<span class="attr">component</span>:<span class="title class_">Home</span>,</span><br><span class="line">	<span class="attr">children</span>:[</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="attr">path</span>:<span class="string">&#x27;news&#x27;</span>,</span><br><span class="line">			<span class="attr">component</span>:<span class="title class_">News</span></span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="attr">component</span>:<span class="title class_">Message</span>,</span><br><span class="line">			<span class="attr">children</span>:[</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="attr">name</span>:<span class="string">&#x27;xiangqing&#x27;</span>,</span><br><span class="line">					<span class="attr">path</span>:<span class="string">&#x27;detail/:id/:title&#x27;</span>, <span class="comment">//使用占位符声明接收params参数</span></span><br><span class="line">					<span class="attr">component</span>:<span class="title class_">Detail</span></span><br><span class="line">				&#125;</span><br><span class="line">			]</span><br><span class="line">		&#125;</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>传递参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 跳转并携带params参数，to的字符串写法 --&gt;</span><br><span class="line">&lt;router-link :to=&quot;/home/message/detail/666/你好&quot;&gt;跳转&lt;/router-link&gt;</span><br><span class="line">				</span><br><span class="line">&lt;!-- 跳转并携带params参数，to的对象写法 --&gt;</span><br><span class="line">&lt;router-link </span><br><span class="line">	:to=&quot;&#123;</span><br><span class="line">		name:&#x27;xiangqing&#x27;,</span><br><span class="line">		params:&#123;</span><br><span class="line">		   id:666,</span><br><span class="line">            title:&#x27;你好&#x27;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;&quot;</span><br><span class="line">&gt;跳转&lt;/router-link&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>特别注意：路由携带params参数时，若使用to的对象写法，则不能使用path配置项，必须使用name配置！</p>
</blockquote>
</li>
<li><p>接收参数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$route.<span class="property">params</span>.<span class="property">id</span></span><br><span class="line">$route.<span class="property">params</span>.<span class="property">title</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="7-路由的props配置"><a href="#7-路由的props配置" class="headerlink" title="7.路由的props配置"></a>7.路由的props配置</h3><p>​	作用：让路由组件更方便的收到参数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">name</span>:<span class="string">&#x27;xiangqing&#x27;</span>,</span><br><span class="line">	<span class="attr">path</span>:<span class="string">&#x27;detail/:id&#x27;</span>,</span><br><span class="line">	<span class="attr">component</span>:<span class="title class_">Detail</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">//第一种写法：props值为对象，该对象中所有的key-value的组合最终都会通过props传给Detail组件</span></span><br><span class="line">	<span class="comment">// props:&#123;a:900&#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//第二种写法：props值为布尔值，布尔值为true，则把路由收到的所有params参数通过props传给Detail组件</span></span><br><span class="line">	<span class="comment">// props:true</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//第三种写法：props值为函数，该函数返回的对象中每一组key-value都会通过props传给Detail组件</span></span><br><span class="line">	<span class="title function_">props</span>(<span class="params">route</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> &#123;</span><br><span class="line">			<span class="attr">id</span>:route.<span class="property">query</span>.<span class="property">id</span>,</span><br><span class="line">			<span class="attr">title</span>:route.<span class="property">query</span>.<span class="property">title</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-lt-router-link-gt-的replace属性"><a href="#8-lt-router-link-gt-的replace属性" class="headerlink" title="8.&lt;router-link&gt;的replace属性"></a>8.<code>&lt;router-link&gt;</code>的replace属性</h3><ol>
<li>作用：控制路由跳转时操作浏览器历史记录的模式</li>
<li>浏览器的历史记录有两种写入方式：分别为<code>push</code>和<code>replace</code>，<code>push</code>是追加历史记录，<code>replace</code>是替换当前记录。路由跳转时候默认为<code>push</code></li>
<li>如何开启<code>replace</code>模式：<code>&lt;router-link replace .......&gt;News&lt;/router-link&gt;</code></li>
</ol>
<h3 id="9-编程式路由导航"><a href="#9-编程式路由导航" class="headerlink" title="9.编程式路由导航"></a>9.编程式路由导航</h3><ol>
<li><p>作用：不借助<code>&lt;router-link&gt; </code>实现路由跳转，让路由跳转更加灵活</p>
</li>
<li><p>具体编码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//$router的两个API</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line">	<span class="attr">name</span>:<span class="string">&#x27;xiangqing&#x27;</span>,</span><br><span class="line">		<span class="attr">params</span>:&#123;</span><br><span class="line">			<span class="attr">id</span>:xxx,</span><br><span class="line">			<span class="attr">title</span>:xxx</span><br><span class="line">		&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">replace</span>(&#123;</span><br><span class="line">	<span class="attr">name</span>:<span class="string">&#x27;xiangqing&#x27;</span>,</span><br><span class="line">		<span class="attr">params</span>:&#123;</span><br><span class="line">			<span class="attr">id</span>:xxx,</span><br><span class="line">			<span class="attr">title</span>:xxx</span><br><span class="line">		&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">forward</span>() <span class="comment">//前进</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">back</span>() <span class="comment">//后退</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">go</span>() <span class="comment">//可前进也可后退</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="10-缓存路由组件"><a href="#10-缓存路由组件" class="headerlink" title="10.缓存路由组件"></a>10.缓存路由组件</h3><ol>
<li><p>作用：让不展示的路由组件保持挂载，不被销毁。</p>
</li>
<li><p>具体编码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;keep-alive include=&quot;News&quot;&gt; </span><br><span class="line">    &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="11-两个新的生命周期钩子"><a href="#11-两个新的生命周期钩子" class="headerlink" title="11.两个新的生命周期钩子"></a>11.两个新的生命周期钩子</h3><ol>
<li>作用：路由组件所独有的两个钩子，用于捕获路由组件的激活状态。</li>
<li>具体名字：<ol>
<li><code>activated</code>路由组件被激活时触发。</li>
<li><code>deactivated</code>路由组件失活时触发。</li>
</ol>
</li>
</ol>
<h3 id="12-路由守卫"><a href="#12-路由守卫" class="headerlink" title="12.路由守卫"></a>12.路由守卫</h3><ol>
<li><p>作用：对路由进行权限控制</p>
</li>
<li><p>分类：全局守卫、独享守卫、组件内守卫</p>
</li>
<li><p>全局守卫:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局前置守卫：初始化时执行、每次路由切换前执行</span></span><br><span class="line">router.<span class="title function_">beforeEach</span>(<span class="function">(<span class="params">to,<span class="keyword">from</span>,next</span>)=&gt;</span>&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;beforeEach&#x27;</span>,to,<span class="keyword">from</span>)</span><br><span class="line">	<span class="keyword">if</span>(to.<span class="property">meta</span>.<span class="property">isAuth</span>)&#123; <span class="comment">//判断当前路由是否需要进行权限控制</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;school&#x27;</span>) === <span class="string">&#x27;atguigu&#x27;</span>)&#123; <span class="comment">//权限控制的具体规则</span></span><br><span class="line">			<span class="title function_">next</span>() <span class="comment">//放行</span></span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="title function_">alert</span>(<span class="string">&#x27;暂无权限查看&#x27;</span>)</span><br><span class="line">			<span class="comment">// next(&#123;name:&#x27;guanyu&#x27;&#125;)</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="title function_">next</span>() <span class="comment">//放行</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局后置守卫：初始化时执行、每次路由切换后执行</span></span><br><span class="line">router.<span class="title function_">afterEach</span>(<span class="function">(<span class="params">to,<span class="keyword">from</span></span>)=&gt;</span>&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;afterEach&#x27;</span>,to,<span class="keyword">from</span>)</span><br><span class="line">	<span class="keyword">if</span>(to.<span class="property">meta</span>.<span class="property">title</span>)&#123; </span><br><span class="line">		<span class="variable language_">document</span>.<span class="property">title</span> = to.<span class="property">meta</span>.<span class="property">title</span> <span class="comment">//修改网页的title</span></span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="variable language_">document</span>.<span class="property">title</span> = <span class="string">&#x27;vue_test&#x27;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>独享守卫:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">beforeEnter</span>(<span class="params">to,<span class="keyword">from</span>,next</span>)&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;beforeEnter&#x27;</span>,to,<span class="keyword">from</span>)</span><br><span class="line">	<span class="keyword">if</span>(to.<span class="property">meta</span>.<span class="property">isAuth</span>)&#123; <span class="comment">//判断当前路由是否需要进行权限控制</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;school&#x27;</span>) === <span class="string">&#x27;atguigu&#x27;</span>)&#123;</span><br><span class="line">			<span class="title function_">next</span>()</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="title function_">alert</span>(<span class="string">&#x27;暂无权限查看&#x27;</span>)</span><br><span class="line">			<span class="comment">// next(&#123;name:&#x27;guanyu&#x27;&#125;)</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="title function_">next</span>()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>组件内守卫：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//进入守卫：通过路由规则，进入该组件时被调用</span></span><br><span class="line">beforeRouteEnter (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">//离开守卫：通过路由规则，离开该组件时被调用</span></span><br><span class="line">beforeRouteLeave (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="13-路由器的两种工作模式"><a href="#13-路由器的两种工作模式" class="headerlink" title="13.路由器的两种工作模式"></a>13.路由器的两种工作模式</h3><ol>
<li><p>对于一个url来说，什么是hash值？—— #及其后面的内容就是hash值。</p>
</li>
<li><p>hash值不会包含在 HTTP 请求中，即：hash值不会带给服务器。</p>
</li>
<li><p>hash模式：</p>
<ol>
<li>地址中永远带着#号，不美观 。</li>
<li>若以后将地址通过第三方手机app分享，若app校验严格，则地址会被标记为不合法。</li>
<li>兼容性较好。</li>
</ol>
</li>
<li><p>history模式：</p>
<ol>
<li>地址干净，美观 。</li>
<li>兼容性和hash模式相比略差。</li>
<li>应用部署上线时需要后端人员支持，解决刷新页面服务端404的问题。</li>
</ol>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/11/01/VUE3%E7%AC%94%E8%AE%B0/" data-id="claxeer9q000fv8w1ct3pc3ov" data-title="VUE3笔记" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-9-26被面" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/11/01/9-26%E8%A2%AB%E9%9D%A2/" class="article-date">
  <time class="dt-published" datetime="2022-11-01T01:15:55.000Z" itemprop="datePublished">2022-11-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/11/01/9-26%E8%A2%AB%E9%9D%A2/">9.26被面</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>一、盒子模型<br>二、CSS之圣杯布局与双飞翼布局<br>    1、圣杯布局<br>        <div class="header">header</div><br>        <div class="content wrapper">  &#x2F;&#x2F;.wrapper {padding-left: 100px; padding-right: 100px;}<br>            <div class="middle">middle</div>  &#x2F;&#x2F; .middle {width: 100%; float:left;}<br>            <div class="left">left</div><br>            &#x2F;&#x2F;.left { width: 100px; float:left; position: relative; margin-left: -100%; right: 100px;}<br>            <div class="right">right</div>    &#x2F;&#x2F;.right {width: 100px; float:left;  margin-right: -100px;}<br>        </div><br>        <div class="footer">footer</div>      &#x2F;&#x2F;.footer {clear: both;}<br>        首先设置一下左右两栏的宽度，中间栏由于是自适应，所以宽度设置成100%。然后就到了重点，我们需要在每一栏加上浮动向左<br>        首先设置middle栏的padding,让中间这一栏左右留出区域方便我们放进去。<br>        然后只需要移动middle的宽度+右边留出来的100px。接下来就是右边这栏，同理，我们只需要挪动盒子的宽度100px即可。<br>        至此，我们可以说已经基本上完成了圣杯布局，我们可以通过拉伸或缩小窗口验证是否为我们想要的效果。<br>    总结一下，圣杯布局就是将基本布局之后使用向左浮动，middle栏留出两边位置，然后使用相对定位将左右两栏通过margin-left定位到相应位置。（是不是很简单！)<br>    2、双飞翼布局的实现过程<br>    <div class="header">header</div><br>    <div class="main middle"><br>        <div id="main-wrapper">middle</div>   &#x2F;&#x2F;.(1)<br>    </div><br>    <div class="left">left</div> .left {margin-left: -100%;}<br>    <div class="right">right</div> .right {margin-left: -100px;}<br>    <div class="footer">footer</div><br>    样式上也是需要向左浮动，前面的基本一致，现在的效果如下<br>    然后不一样的是， 我们不使用相对定位，而是直接通过margin-left，将left栏移动到middle栏上，right栏也一样。<br>    但是左右两栏覆盖了middle栏的内容。此时应该可以想到，只要将middle栏设置padding即可将内容挤到中间可视区域了。<br>    所以我们需要在middle栏里面再套一层div，(1)<br>    我们再里面这层div上加padding    .main #main-wrapper {padding-left: 100px; padding-right: 100px;}<br>    至此，我们就实现了双飞翼布局：<br>    3、最后总结一下，二者的异同：<br>    （1）实现方法的不同：<br>        圣杯布局是通过float搭建布局+margin使三列布局到一行上+relative相对定位调整位置。<br>        双飞翼布局是通过float+margin，没有使用相对定位。<br>    （2）怎么处理两列的位置：<br>        圣杯布局是给外部容器加padding，通过相对定位把两边定位出来。<br>        双飞翼布局是靠在中间这层外面套一层div加padding将内容挤出来中间。<br>三、css选择符有哪些，那些可以继承<br>    CSS 选择符<br>        id 选择器(#myid)、<br>        类选择器(.myclassname)、<br>        标签选择器(div, h1, p)、<br>        相邻选择器(h1 + p)、<br>        子选择器（ul &gt; li）、<br>        后代选择器（li a）、<br>        通配符选择器（*）、<br>        属性选择器（a[rel&#x3D;”external”]）、<br>        伪类选择器（a:hover, li:nth-child）<br>    可继承的属性<br>        font-size, font-family, color<br>    不可继承的样式<br>        border, padding, margin, width, height<br>    优先级（就近原则）<br>        !important &gt; [ id &gt; class &gt; tag ]<br>        !important 比内联优先级高<br>    CSS 优先级算法如何计算<br>        选择器的特殊性值表述为4个部分，用0,0,0,0表示。<br>            ID 选择器的特殊性值，加 0,1,0,0。<br>            类选择器、属性选择器或伪类，加 0,0,1,0。<br>            元素和伪元素，加 0,0,0,1。<br>            通配选择器*对特殊性没有贡献，即 0,0,0,0。<br>            最后比较特殊的一个标志!important（权重），它没有特殊性值，但它的优先级是最高的，为了方便记忆，可以认为它的特殊性值为 1,0,0,0,0。<br>四、数组常用的方法，那些数组改变原数组<br>    1.不会改变原来数组的有：（十二个）<br>        every()—检测数组元素的每个元素是否都符合条件。<br>        some()—检测数组元素中是否有元素符合指定条件。<br>        map()—通过指定函数处理数组的每个元素，并返回处理后的数组。<br>        slice()—选取数组的的一部分，并返回一个新数组。<br>        filter()—检测数组元素，并返回符合条件所有元素的数组。<br>        find()—返回数组中符合测试函数条件的第一个元素<br>        reduce()—可以作为累加器( reduceRight() )<br>        indexOf()—搜索数组中的元素，并返回它首次出现的位置。<br>        lastIndexOf()—返回一个指定的字符串值最后出现的位置，在一个字符串中的指定位置从后向前搜索。<br>        valueOf()—返回数组对象的原始值。<br>        toString()—把数组转换为字符串，并返回结果。<br>        join()—把数组的所有元素放入一个字符串。<br>        concat()—连接两个或更多的数组，并返回结果。</p>
<pre><code>2.会改变原来数组的有：（七个）
    pop()---删除数组的最后一个元素并返回删除的元素。
    push()---向数组的末尾添加一个或更多元素，并返回新的长度。
    shift()---删除并返回数组的第一个元素。
    unshift()---向数组的开头添加一个或更多元素，并返回新的长度。
    reverse()---反转数组的元素顺序。(瑞我司)
    sort()---对数组的元素进行排序。
    splice()---用于插入、删除或替换数组的元素。
</code></pre>
<p>五、什么是闭包<br>    一个普通的函数function，如果它可以访问外层作用域的自由变量，那么这个函数就是一个闭包<br>    从广义的角度来说：JavaScript中的函数都是闭包(因为都是可以访问的)<br>    从狭义的角度来说：JavaScript中一个函数，如果访问了外层作用域的变量才叫闭包<br>    总结<br>    JavaScript的内存管理<br>    垃圾回收机制 → 引用计数、标记清除<br>    JavaScript的闭包<br>    什么是闭包? → 闭包是两部分组成的：函数+可以访问的自由变量<br>    AO为何没有被销毁? → 没有被垃圾回收机制识别<br>六、防抖和节流的原理和使用场景<br>    函数防抖和函数节流：优化高频率执行js代码的一种手段，js中的一些事件如浏览器的resize、scroll，鼠标的mousemove、mouseover，input输入框的keypress等事件在触发时，会不断地调用绑定在事件上的回调函数，极大地浪费资源，降低前端性能。为了优化体验，需要对这类事件进行调用次数的限制。<br>    1、防抖：<br>        在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。<br>            var timer; &#x2F;&#x2F; 维护同一个timer<br>            function debounce(fn, delay) {<br>                clearTimeout(timer);<br>                timer &#x3D; setTimeout(function(){<br>                    fn();<br>                }, delay);<br>            }<br>        在上面的代码中，会出现一个问题，var timer只能在setTimeout的父级作用域中，这样才是同一个timer，并且为了方便防抖函数的调用和回调函数fn的传参问题，我们应该用闭包来解决这些问题。<br>        优化后的代码：<br>        function debounce(fn, delay) {<br>            var timer; &#x2F;&#x2F; 维护一个 timer<br>            return function () {<br>                var _this &#x3D; this; &#x2F;&#x2F; 取debounce执行作用域的this<br>                var args &#x3D; arguments;<br>                if (timer) {<br>                    clearTimeout(timer);*9-<br>                }<br>                timer &#x3D; setTimeout(function () {<br>                    fn.apply(_this, args); &#x2F;&#x2F; 用apply指向调用debounce的对象，相当于_this.fn(args);<br>                }, delay);<br>            };<br>        }<br>        使用闭包后，解决传参和封装防抖函数的问题，这样就可以在其他地方随便将需要防抖的函数传入debounce了。<br>    2、节流：<br>        每隔一段时间，只执行一次函数。<br>    3、异同比较<br>        相同点：<br>            都可以通过使用 setTimeout 实现。<br>            目的都是，降低回调执行频率。节省计算资源。<br>        不同点：<br>            函数防抖，在一段连续操作结束后，处理回调，利用clearTimeout 和 setTimeout实现。函数节流，在一段连续操作中，每一段时间只执行一次，频率较高的事件中使用来提高性能。<br>            函数防抖关注一定时间连续触发的事件只在最后执行一次，而函数节流侧重于一段时间内只执行一次。<br>    4、常见应用场景<br>        函数防抖的应用场景:<br>            连续的事件，只需触发一次回调的场景有：<br>            搜索框搜索输入。只需用户最后一次输入完，再发送请求<br>            手机号、邮箱验证输入检测<br>            窗口大小Resize。只需窗口调整完成后，计算窗口大小。防止重复渲染。</p>
<pre><code>    函数节流的应用场景:
        间隔一段时间执行一次回调的场景有：
        滚动加载，加载更多或滚到底部监听
        谷歌搜索框，搜索联想功能
        高频点击提交，表单重复提交
        轮播图的下一页（等这一页滚动完再进行下一页的滚动）
</code></pre>
<p>七、Vue 生命周期<br>    vue2生命周期（八个）<br>    beforeCreate: function () {<br>            console.group(‘——beforeCreate创建前状态——‘);<br>        },<br>        created: function () {<br>            console.group(‘——created创建完毕状态——‘);<br>        },<br>    <!-- 在Vue实例创建完毕状态，我们可以去访问data、computed、watch、methods上的方法和数据，但现在还没有将虚拟Dom挂载到真实Dom上，所以我们在此时访问不到我们的Dom元素（el属性，ref属性此时都为空）。 --><br>    <!-- 我们在此时可以进行一些简单的Ajax，并可以对页面进行初始化之类的操作 --><br>        beforeMount: function () {<br>            console.group(‘——beforeMount挂载前状态——‘);<br>        },<br>        mounted: function () {<br>            console.group(‘——mounted 挂载结束状态——‘);<br>        },<br>    <!-- 虚拟Dom已经被挂载到真实Dom上，此时我们可以获取Dom节点，$ref在此时也是可以访问的。 --><br>    <!-- 我们在此时可以去获取节点信息，做Ajax请求，对节点做一些操作 --><br>        beforeUpdate: function () {<br>            console.group(‘beforeUpdate 更新前状态&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;》’);<br>        },<br>    <!-- 响应式数据更新的时候会被调用，beforeupdate的阶段虚拟Dom还没更新，所以在此时依旧可以访问现有的Dom。 --><br>    <!-- 我们可以在此时访问现有的Dom，手动移除一些添加的监听事件 --><br>        updated: function () {<br>            console.group(‘updated 更新完成状态&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;》’);<br>        },<br>    <!-- 此时补丁已经打完了，Dom已经更新完毕，可以执行一些依赖新Dom的操作。 --><br>    <!-- 但还是不建议在此时进行数据操作，避免进入死循环（这个坑我曾经踩过） --><br>        beforeDestroy: function () {<br>            console.group(‘beforeDestroy 销毁前状态&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;》’);<br>        },<br>    <!-- 在Vue实例销毁之前被调用，在此时我们的实例还未被销毁 --><br>    <!-- 在此时可以做一些操作，比如销毁定时器，解绑全局事件，销毁插件对象等 --><br>        destroyed: function () {<br>            console.group(‘destroyed 销毁完成状态&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;》’);<br>        }<br>    vue3生命周期（八个）<br>        beforeCreate： 在实例初始化之后、进行数据侦听和事件&#x2F;侦听器的配置之前同步调用<br>        created：在实例创建完成后被立即同步调用<br>        beforeMount：在挂载开始之前被调用<br>        mounted：在实例挂载完成后被调用<br>        beforeUpdate：在数据发生改变后，DOM 被更新之前被调用<br>        updated：在数据更改导致的虚拟 DOM 重新渲染和更新完毕之后被调用<br>        beforeUnmount(在Vue2中是：beforeDestroy)：在卸载组件实例之前调用<br>        unmounted (在Vue2中是： destroyed)：卸载组件实例后调用<br>八、Vue中的$nextTick有什么作用<br>        Vue 在更新 DOM 时是异步执行的。当数据发生变化，Vue将开启一个异步更新队列，视图需要等队列中所有数据变化完成之后，再统一进行更新。如果没有 nextTick 更新机制，那么 num 每次更新值都会触发视图更新，有了nextTick机制，只需要更新一次，所以nextTick本质是一种优化策略<br>    使用场景<br>        如果想要在修改数据后立刻得到更新后的DOM结构，就可以使用Vue.nextTick()<br>        第一个参数：回调函数（可以获取最近的DOM结构）<br>        第二个参数：执行函数上下文<br>        $nextTick() 会返回一个 Promise 对象，可以是用async&#x2F;await完成相同作用的事情<br>    总结：<br>        把回调函数放入callbacks等待执行<br>        将执行函数放到微任务或者宏任务中<br>        事件循环到了微任务或者宏任务，执行函数依次执行callbacks中的回调<br>九、Vue2和Vue3你认为在那一方面做了改进和优化<br>十、项目中遇到哪些难题，怎样解决的</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/11/01/9-26%E8%A2%AB%E9%9D%A2/" data-id="claxeer9n0008v8w1dg6t7l6g" data-title="9.26被面" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/4/">&laquo; 上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/6/">下一页 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/11/">十一月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">十月 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/11/26/%E4%B8%BA%E4%BB%80%E4%B9%88React16%E8%A6%81%E6%9B%B4%E6%94%B9%E7%BB%84%E4%BB%B6%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-%EF%BC%88%E4%B8%8B%EF%BC%89/">为什么React16要更改组件的生命周期?（下）</a>
          </li>
        
          <li>
            <a href="/2022/11/26/%E8%A6%81%E6%9B%B4%E6%94%B9%E7%BB%84%E4%BB%B6%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%9F%EF%BC%88%E4%B8%8A%EF%BC%89/">(no title)</a>
          </li>
        
          <li>
            <a href="/2022/11/26/%E4%BB%A3%E7%A0%81%E8%BD%ACdom/">代码转dom</a>
          </li>
        
          <li>
            <a href="/2022/11/26/React%E7%9F%A5%E8%AF%86%E9%93%BE/">React知识链</a>
          </li>
        
          <li>
            <a href="/2022/11/02/%E6%8E%92%E5%BA%8F%E2%80%9C/">排序“</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 XuJiaDi<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>