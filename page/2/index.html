<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>徐嘉迪的个人网站</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="没有永远的失败者，只有努力的成功者">
<meta property="og:type" content="website">
<meta property="og:title" content="徐嘉迪的个人网站">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="徐嘉迪的个人网站">
<meta property="og:description" content="没有永远的失败者，只有努力的成功者">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="XuJiaDi">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="徐嘉迪的个人网站" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">徐嘉迪的个人网站</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">没有永远的失败者，只有努力的成功者</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS 订阅"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-如何选择打包工具：Rollup-和-Webpack-？" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/11/02/%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7%EF%BC%9ARollup-%E5%92%8C-Webpack-%EF%BC%9F/" class="article-date">
  <time class="dt-published" datetime="2022-11-02T11:42:28.000Z" itemprop="datePublished">2022-11-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/11/02/%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7%EF%BC%9ARollup-%E5%92%8C-Webpack-%EF%BC%9F/">如何选择打包工具：Rollup 和 Webpack ？</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>今天我要跟你介绍另外一款同样十分优秀的打包工具：Rollup。</p>
<p><img src="https://s0.lgstatic.com/i/image/M00/12/F6/Ciqc1F7OSZeAPB_DAAFyVhG38TI683.png" alt="image (10).png"></p>
<p>Rollup 是一款 ES Modules 打包器。它也可以将项目中散落的细小模块打包为整块代码，从而使得这些划分的模块可以更好地运行在浏览器环境或者 Node.js 环境。</p>
<p>从作用上来看，Rollup 与 Webpack 非常类似。不过相比于 Webpack，Rollup 要小巧的多。因为 Webpack 在配合一些插件的使用下，几乎可以完成开发过程中绝大多数前端工程化的工作。而 Rollup 可以说仅仅是一个 ES Modules 打包器，没有更多其他的功能了。</p>
<p>例如，在 Webpack 中支持 HMR 这种对开发过程十分友好的功能，而在 Rollup 中就没有办法完全支持。</p>
<p>Rollup 诞生的目的并不是要与 Webpack 这样的工具全面竞争。它的初衷只是希望能够<strong>提供一个高效的 ES Modules 打包器，充分利用 ES Modules 的各项特性，构建出结构扁平，性能出众的类库</strong>。</p>
<p>至于它的其他特点和优势，我们需要上手过后才能深入了解。</p>
<h3>快速上手</h3>
<p>这里我准备了一个简单的示例，具体结构如下：</p>
<pre><code data-language="java" class="lang-java">.
├── src
│   ├── index.js
│   ├── logger.js
│   └── messages.js
└── <span class="hljs-keyword">package</span>.json
</code></pre>
<p>在这个示例的源代码中我准备了三个文件，并且使用 ES Modules 组织的代码模块化。部分代码如下：</p>
<pre><code data-language="javascript" class="lang-javascript"><span class="hljs-comment">// ./src/messages.js</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;
  <span class="hljs-attr">hi</span>: <span class="hljs-string">'Hey Guys, I am zce~'</span>
&#125;
<span class="hljs-comment">// ./src/logger.js</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> log = <span class="hljs-function"><span class="hljs-params">msg</span> =&gt;</span> &#123;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'---------- INFO ----------'</span>)
  <span class="hljs-built_in">console</span>.log(msg)
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'--------------------------'</span>)
&#125;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> error = <span class="hljs-function"><span class="hljs-params">msg</span> =&gt;</span> &#123;
  <span class="hljs-built_in">console</span>.error(<span class="hljs-string">'---------- ERROR ----------'</span>)
  <span class="hljs-built_in">console</span>.error(msg)
  <span class="hljs-built_in">console</span>.error(<span class="hljs-string">'---------------------------'</span>)
&#125;
<span class="hljs-comment">// ./src/index.js</span>
<span class="hljs-keyword">import</span> &#123; log &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./logger'</span>
<span class="hljs-keyword">import</span> messages <span class="hljs-keyword">from</span> <span class="hljs-string">'./messages'</span>
log(messages.hi)
</code></pre>
<p>如上述代码所示，其中：</p>
<ul>
<li>messages.js 文件中以默认导出的方式导出了一个对象；</li>
<li>logger.js 文件中单个导出了两个函数成员；</li>
<li>最后在 index.js 文件中导入了这两个模块，并且使用了它们。</li>
</ul>
<p>接下来，我们尝试使用 Rollup 完成这个示例应用的打包。这里需要先通过 npm 安装 rollup 这个模块。具体命令如下：</p>
<pre><code data-language="shell" class="lang-shell"><span class="hljs-meta">$</span><span class="bash"> npm i rollup --save-dev</span>
</code></pre>
<p>安装完成过后，rollup 这个模块同样会在 node_modules/.bin 目录中为我们提供一个 CLI 程序，我们就可以通过这个 CLI 去使用 Rollup 打包。具体命令如下：</p>
<pre><code data-language="shell" class="lang-shell"><span class="hljs-meta">$</span><span class="bash"> npx rollup</span>
</code></pre>
<blockquote>
<p>P.S. 对于 node_modules/.bin 目录下的 CLI，我们可以使用 npx 命令或者 yarn 命令直接启动。</p>
</blockquote>
<p>执行 rollup 命令，在不传递任何参数的情况下，这个命令会自动打印出它的帮助信息。具体如下图：</p>
<p><img src="https://s0.lgstatic.com/i/image/M00/13/01/CgqCHl7OSaeAFukyAAE1QDF-mHI012.png" alt="image (11).png"></p>
<p>在这个帮助信息的一开始，就已经告诉我们 rollup 命令的正确用法了：我们应该通过参数指定一个打包入口文件。正确命令如下：</p>
<pre><code data-language="shell" class="lang-shell"><span class="hljs-meta">$</span><span class="bash"> npx rollup ./src/index.js</span>
</code></pre>
<p>这里指定的打包入口是 src/index.js 文件。再次执行 rollup 命令，具体执行结果如下：</p>
<p><img src="https://s0.lgstatic.com/i/image/M00/12/F6/Ciqc1F7OSa-AOq5aAAEb_vSj5jo673.png" alt="image (12).png"></p>
<p>根据控制台的输出结果，我们发现 Rollup 直接将打包结果打印到控制台中了。</p>
<p>当然，正常情况下我们还是需要将打包结果输出到一个文件中。具体就是通过 CLI 的 --file 参数指定输出文件路径，具体命令如下：</p>
<pre><code data-language="shell" class="lang-shell"><span class="hljs-meta">$</span><span class="bash"> npx rollup ./src/index.js --file ./dist/bundle.js</span>
</code></pre>
<p>这样打包的结果就会输出到文件中。</p>
<p>完成以后，我们找到 Rollup 打包输出的文件，具体结果如下：</p>
<p><img src="https://s0.lgstatic.com/i/image/M00/12/F6/Ciqc1F7OSbeAHIZBAADh3GsHnjA087.png" alt="image (13).png"></p>
<p>在这个文件中我们的第一印象就是，Rollup 打包结果惊人的简洁，基本上就跟我们手写的代码一样。相比于 Webpack 大量的引导代码和一堆的模块函数，这里的输出结果没有任何多余代码，就是把打包过程中的各个模块按照依赖顺序，先后拼接到了一起。</p>
<p>而且我们仔细观察打包结果，你会发现，在我们输出的结果中只会保留那些用到的部分，对于未引用部分都没有输出。这是因为 Rollup 默认会自动开启 Tree-shaking 优化输出结果，Tree-shaking 的概念最早也就是 Rollup 这个工具提出的。</p>
<h4>配置文件</h4>
<p>Rollup 同样支持以配置文件的方式去配置打包过程中的各项参数，我们可以在项目的根目录下新建一个 rollup.config.js 的配置文件。具体结构如下：</p>
<pre><code data-language="java" class="lang-java"> .
 ├── src
 │   ├── index.js
 │   ├── logger.js
 │   └── messages.js
 ├── <span class="hljs-keyword">package</span>.json
+└── rollup.config.js
</code></pre>
<p>这个文件虽然同样是运行在 Node.js 环境中，但是 Rollup 会额外处理配置文件，所以在 rollup.config.js 中我们可以直接使用 ES Modules 标准。具体代码如下：</p>
<pre><code data-language="javascript" class="lang-javascript"><span class="hljs-comment">// ./rollup.config.js</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;
  <span class="hljs-attr">input</span>: <span class="hljs-string">'src/index.js'</span>,
  <span class="hljs-attr">output</span>: &#123;
    <span class="hljs-attr">file</span>: <span class="hljs-string">'dist/bundle.js'</span>,
    <span class="hljs-attr">format</span>: <span class="hljs-string">'es'</span> <span class="hljs-comment">// 输出格式</span>
  &#125;
&#125;
</code></pre>
<p>这个文件中需要导出一个配置对象，在这个对象中我们可以通过 input 属性指定打包的入口文件路径，通过 output 指定输出相关配置，output 属性是一个对象，在 output 对象中可以使用 file 属性指定输出的文件名，format 属性指定输出代码的格式。</p>
<p>完成以后，我们回到命令行，再次执行 rollup 命令，不过需要注意的是，这里需要通过 --config 参数来表明使用项目中的配置文件。你也可以通过这个参数来指定不同的配置文件名称。具体命令如下：</p>
<pre><code data-language="shell" class="lang-shell"><span class="hljs-meta">$</span><span class="bash"> npx rollup --config <span class="hljs-comment"># 使用默认配置文件</span></span>
<span class="hljs-meta">$</span><span class="bash"> npx rollup --config rollup.prod.js <span class="hljs-comment"># 指定配置文件路径</span></span>
</code></pre>
<h4>输出格式</h4>
<p>Rollup 打包支持多种输出格式，这里我们回到配置文件中，配置同时输出所有格式下的文件，具体配置如下：</p>
<pre><code data-language="javascript" class="lang-javascript"><span class="hljs-comment">// ./rollup.config.js</span>
<span class="hljs-comment">// 所有 Rollup 支持的格式</span>
<span class="hljs-keyword">const</span> formats = [<span class="hljs-string">'es'</span>, <span class="hljs-string">'amd'</span>, <span class="hljs-string">'cjs'</span>, <span class="hljs-string">'iife'</span>, <span class="hljs-string">'umd'</span>, <span class="hljs-string">'system'</span>]
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> formats.map(<span class="hljs-function"><span class="hljs-params">format</span> =&gt;</span> (&#123;
  <span class="hljs-attr">input</span>: <span class="hljs-string">'src/index.js'</span>,
  <span class="hljs-attr">output</span>: &#123;
    <span class="hljs-attr">file</span>: <span class="hljs-string">`dist/bundle.<span class="hljs-subst">$&#123;format&#125;</span>.js`</span>,
    format
  &#125;
&#125;))
</code></pre>
<p>在这个配置当中我们导出了一个数组，数组中的每个成员都是一个单独的打包配置，这样 Rollup 就会分别按照每个配置单独打包。这一点与 Webpack 非常相似。</p>
<p>配置完成之后，我们回到命令行终端，再次运行 Rollup 打包。那这次打包过后，dist 目录下就会生成不同格式的输出结果，如下图所示：</p>
<p><img src="https://s0.lgstatic.com/i/image/M00/12/F6/Ciqc1F7OScSAL2axAABjmxxZoIs900.png" alt="image (14).png"></p>
<p>你可以自己依次去了解一下每种格式的输出结果，其实不同的输出格式大都是为了适配不同的运行环境，并没有什么需要额外理解的地方。</p>
<h4>使用插件</h4>
<p>Rollup 自身的功能就只是 ES Modules 模块的合并，如果有更高级的要求，例如加载其他类型的资源文件或者支持导入 CommonJS 模块，又或是编译 ES 新特性，这些额外的需求 Rollup 同样支持使用插件去扩展实现。</p>
<p>Webpack 中划分了 Loader、Plugin 和 Minimizer 三种扩展方式，而插件是 Rollup 的唯一的扩展方式。</p>
<p>这里我们先来尝试使用一个可以让我们在代码中导入 JSON 文件的插件：<a target="_blank" rel="noopener" href="https://github.com/rollup/plugins/tree/master/packages/json">@rollup/plugin-json</a>，通过这个过程来了解如何在 Rollup 中使用插件。</p>
<p>首先我们需要将 @rollup/plugin-json 作为项目的开发依赖安装进来。具体安装命令：</p>
<pre><code data-language="shell" class="lang-shell"><span class="hljs-meta">$</span><span class="bash"> npm i @rollup/plugin-json --save-dev</span>
</code></pre>
<p>安装完成过后，我们打开配置文件。由于 rollup 的配置文件中可以直接使用 ES Modules，所以我们这里使用 import 导入这个插件模块。具体代码如下：</p>
<pre><code data-language="javascript" class="lang-javascript"><span class="hljs-comment">// ./rollup.config.js</span>
<span class="hljs-keyword">import</span> json <span class="hljs-keyword">from</span> <span class="hljs-string">'@rollup/plugin-json'</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;
  <span class="hljs-attr">input</span>: <span class="hljs-string">'src/index.js'</span>,
  <span class="hljs-attr">output</span>: &#123;
    <span class="hljs-attr">file</span>: <span class="hljs-string">'dist/bundle.js'</span>,
    <span class="hljs-attr">format</span>: <span class="hljs-string">'es'</span>
  &#125;,
  <span class="hljs-attr">plugins</span>: [
    json()
  ]
&#125;
</code></pre>
<p>@rollup/plugin-json 模块的默认导出就是一个插件函数。我们可以将这个函数的调用结果添加到配置对象的 plugins 数组中，注意这里是将调用结果放到数组中，而不是将这个函数直接放进去。</p>
<p>配置好这个插件过后，我们就可以在代码中通过 import 导入 json 文件了。我们回到 index.js 文件中，这里我们尝试通过 import 导入 package.json，具体代码如下：</p>
<pre><code data-language="javascript" class="lang-javascript"><span class="hljs-comment">// ./src/index.js</span>
<span class="hljs-keyword">import</span> &#123; name, version &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'../package.json'</span>
<span class="hljs-built_in">console</span>.log(name, version)
</code></pre>
<p>那这个 JSON 文件中的每一个属性都会作为单独的导出成员。我们可以提取一下 JSON 中的 name 和 version，然后把它打印出来。</p>
<p>完成以后，我们打开命令行终端，再次运行 Rollup 打包。打包完成以后，我们找到输出的 bundle.js，具体结果如下：</p>
<p><img src="https://s0.lgstatic.com/i/image/M00/12/F6/Ciqc1F7OSc6AWooYAABuIh3cPUs738.png" alt="image (15).png"></p>
<p>此时你就能看到，package.json 中的 name 和 version 正常被打包进来了，而且其他没用到的属性也都被 Tree-shaking 移除掉了。</p>
<p>以上就是 Rollup 中插件的使用。</p>
<h4>加载 NPM 模块</h4>
<p>Rollup 默认只能够按照文件路径的方式加载本地的模块文件，对于 node_modules 目录中的第三方模块，并不能像 Webpack 一样，直接通过模块名称直接导入。</p>
<p>为了抹平这个差异，Rollup 给出了一个 <a target="_blank" rel="noopener" href="https://github.com/rollup/plugins/tree/master/packages/node-resolve">@rollup/plugin-node-resolve</a> 插件，通过使用这个插件，我们就可以在代码中直接使用模块名称导入模块了。</p>
<p>同样，我们需要先安装这个插件，具体命令如下：</p>
<pre><code data-language="shell" class="lang-shell"><span class="hljs-meta">$</span><span class="bash">&nbsp;npm i @rollup/plugin-node-resolve --save-dev</span>
</code></pre>
<p>安装完成过后，打开配置文件，这里同样导入插件函数，然后把它配置到 plugins 数组中。具体配置如下：</p>
<pre><code data-language="javascript" class="lang-javascript"><span class="hljs-comment">// ./rollup.config.js</span>
<span class="hljs-keyword">import</span> json <span class="hljs-keyword">from</span> <span class="hljs-string">'@rollup/plugin-json'</span>
<span class="hljs-keyword">import</span> resolve <span class="hljs-keyword">from</span> <span class="hljs-string">'@rollup/plugin-node-resolve'</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;
  <span class="hljs-attr">input</span>: <span class="hljs-string">'src/index.js'</span>,
  <span class="hljs-attr">output</span>: &#123;
    <span class="hljs-attr">file</span>: <span class="hljs-string">'dist/bundle.js'</span>,
    <span class="hljs-attr">format</span>: <span class="hljs-string">'es'</span>
  &#125;,
  <span class="hljs-attr">plugins</span>: [
    json(),
    resolve()
  ]
&#125;
</code></pre>
<p>完成以后我们就可以回到代码中直接导入 node_modules 中的第三方模块了。例如：</p>
<pre><code data-language="javascript" class="lang-javascript"><span class="hljs-comment">// ./src/index.js</span>
<span class="hljs-keyword">import</span> &#123; camelCase &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'lodash-es'</span>
<span class="hljs-built_in">console</span>.log(camelCase(<span class="hljs-string">'hello rollup'</span>))
</code></pre>
<p>这里我导入的是我提前安装好的一个 <a target="_blank" rel="noopener" href="https://www.npmjs.com/package/lodash-es">lodash-es</a> 模块，这个模块就是常用的 lodash 模块的 ESM 版本。导入过后我们就可以使用这个模块所提供的工具方法了。</p>
<blockquote>
<p>P.S. 相比于普通的 lodash，lodash-es 可以更好地支持 Tree-shaking。</p>
</blockquote>
<p>完成过后我们再次打开命令行终端，运行 Rollup 打包，此时 lodash 就能够打包到我们的 bundle.js 中了。</p>
<p>这里使用 Lodash 的 ESM 版本而不是 Lodash 普通版本的原因是 Rollup 默认只能处理 ESM 模块。如果要使用普通版本则需要额外处理。</p>
<h4>加载 CommonJS 模块</h4>
<p>由于 Rollup 设计的是只处理 ES Modules 模块的打包，所以如果在代码中导入 CommonJS 模块，默认是不被支持的。但是目前大量的 NPM 模块还是使用 CommonJS 方式导出成员，所以为了兼容这些模块。官方给出了一个插件，叫作 <a target="_blank" rel="noopener" href="https://github.com/rollup/plugins/tree/master/packages/commonjs">@rollup/plugin-commonjs</a>。</p>
<p>这个插件在用法上跟前面两个插件是一样的，我就不单独演示了。我们直接看一下这个插件的效果。这里我添加了一个 cjs-module.js 文件，具体代码如下：</p>
<pre><code data-language="javascript" class="lang-javascript"><span class="hljs-comment">// ./src/cjs-module.js</span>
<span class="hljs-built_in">module</span>.exports = &#123;
  <span class="hljs-attr">foo</span>: <span class="hljs-string">'bar'</span>
&#125;
</code></pre>
<p>这个文件中使用 CommonJS 的方式导出了一个对象。然后回到入口文件中通过 ES Modules 的方式导入，具体代码如下：</p>
<pre><code data-language="javascript" class="lang-javascript"><span class="hljs-comment">// ./src/index.js</span>
<span class="hljs-comment">// 导入 CommonJS 模块成员</span>
<span class="hljs-keyword">import</span> cjs <span class="hljs-keyword">from</span> <span class="hljs-string">'./cjs-module'</span>
<span class="hljs-comment">// 使用模块成员</span>
<span class="hljs-built_in">console</span>.log(cjs) <span class="hljs-comment">// cjs =&gt; &#123; foo: 'bar' &#125;</span>
</code></pre>
<p>入口文件导入的结果就是 cjs-module.js 中导出的对象了。</p>
<h3>Code Splitting</h3>
<p>Rollup 的最新版本中已经开始支持代码拆分了。我们同样可以使用符合 ES Modules 标准的动态导入方式实现模块的按需加载。例如：</p>
<pre><code data-language="javascript" class="lang-javascript"><span class="hljs-comment">// ./src/index.js</span>
<span class="hljs-comment">// 动态导入的模块会自动分包</span>
<span class="hljs-keyword">import</span>(<span class="hljs-string">'./logger'</span>).then(<span class="hljs-function">(<span class="hljs-params">&#123; log &#125;</span>) =&gt;</span> &#123;
  log(<span class="hljs-string">'code splitting~'</span>)
&#125;)
</code></pre>
<p>Rollup 内部也会处理代码拆分。不过按照之前的配置方式，这里直接打包会报出一个错误：</p>
<p><img src="https://s0.lgstatic.com/i/image/M00/12/F6/Ciqc1F7OSduAVJ9yAAJP3ntcGOo011.png" alt="image (16).png"></p>
<p>出现这个错误的原因是：在 Rollup 在分包过后会输出多个 JS 文件，需要我们在配置中指定输出的目录，而不是一个具体的文件名，具体配置如下：</p>
<pre><code data-language="javascript" class="lang-javascript"><span class="hljs-comment">// ./rollup.config.js</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;
  <span class="hljs-attr">input</span>: <span class="hljs-string">'src/index.js'</span>,
  <span class="hljs-attr">output</span>: &#123;
    <span class="hljs-comment">// file: 'dist/bundle.js', // code splitting 输出的是多个文件</span>
    <span class="hljs-attr">dir</span>: <span class="hljs-string">'dist'</span>,
    <span class="hljs-attr">format</span>: <span class="hljs-string">'es'</span>
  &#125;
&#125;
</code></pre>
<p>这里我们将 output 配置中的 file 选项删掉，取而代之的是添加一个 dir 选项，把它设置为 dist，也就是输出到 dist 目录中。</p>
<p>这样的话，再次打包就可以正常输出了。具体输出结果如下：</p>
<p><img src="https://s0.lgstatic.com/i/image/M00/12/F6/Ciqc1F7OSeKAKBygAAA30G6xG-U506.png" alt="image (17).png"></p>
<p>这次打包过程中，Rollup 就会自动提取动态导入的模块到单独的 JS 文件中了。</p>
<h4>输出格式问题</h4>
<p>目前采用的输出格式是 es，所以自动分包过后，得到的代码还是使用 ES Modules 实现的动态模块加载，具体输出结果如下：</p>
<p><img src="https://s0.lgstatic.com/i/image/M00/13/02/CgqCHl7OSemATtitAAFsfyPbzKs108.png" alt="image (18).png"></p>
<p>很明显，这种方式的代码仍然会存在环境兼容性问题：如果在低版本浏览器，这种输出结果是无法正常执行的。</p>
<p>解决这个问题的办法就是修改 Rollup 打包输出的格式。目前所有支持动态导入的输出格式中，只有 amd 和 system 两种格式打包的结果适合于浏览器环境。</p>
<p>所以在这种情况下，我们可以选择以 amd 或者 system 格式输出。这里我们以 amd 为例，这里我们先将 Rollup 配置中的 format 设置为 amd。具体配置如下：</p>
<pre><code data-language="javascript" class="lang-javascript"><span class="hljs-comment">// ./rollup.config.js</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;
  <span class="hljs-attr">input</span>: <span class="hljs-string">'src/index.js'</span>,
  <span class="hljs-attr">output</span>: &#123;
    <span class="hljs-attr">dir</span>: <span class="hljs-string">'dist'</span>,
    <span class="hljs-attr">format</span>: <span class="hljs-string">'amd'</span>
  &#125;
&#125;
</code></pre>
<p>这样的话，再次打包输出的结果就是采用 AMD 标准组织的代码了，具体如下：</p>
<p><img src="https://s0.lgstatic.com/i/image/M00/12/F6/Ciqc1F7OSfGAMQ5VAAIowWpAVAg558.png" alt="image (19).png"></p>
<p>需要注意一点，这种 AMD 标准在浏览器中也不是直接支持的，也就是说我们还是需要使用一个支持这个标准的库来加载这些输出的模块，例如 <a target="_blank" rel="noopener" href="https://requirejs.org">Require.js</a>，具体使用方式参考：</p>
<pre><code data-language="xml" class="lang-xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>AMD Format output<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://unpkg.com/requirejs@2.3.6/require.js"</span> <span class="hljs-attr">data-main</span>=<span class="hljs-string">"dist/index.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre>
<blockquote>
<p>P.S. 本课时中所有的案例源代码：<a target="_blank" rel="noopener" href="https://github.com/zce/rollup-demo">https://github.com/zce/rollup-demo</a></p>
</blockquote>
<h3>写在最后</h3>
<p>通过以上的探索，我们发现 Rollup 确实有它的优势：</p>
<ul>
<li>输出结果更加扁平，执行效率更高；</li>
<li>自动移除未引用代码；</li>
<li>打包结果依然完全可读。</li>
</ul>
<p>但是它的缺点也同样明显：</p>
<ul>
<li>加载非 ESM 的第三方模块比较复杂；</li>
<li>因为模块最终都被打包到全局中，所以无法实现 HMR；</li>
<li>浏览器环境中，代码拆分功能必须使用 Require.js 这样的 AMD 库。</li>
</ul>
<p>综合以上特点，我们发现如果我们开发的是一个应用程序，需要大量引用第三方模块，同时还需要 HMR 提升开发体验，而且应用过大就必须要分包。那这些需求 Rollup 都无法满足。</p>
<p>而如果我们是开发一个 JavaScript 框架或者库，那这些优点就特别有必要，而缺点呢几乎也都可以忽略，所以在很多像 React 或者 Vue 之类的框架中都是使用的 Rollup 作为模块打包器，而并非 Webpack。</p>
<p>但是到目前为止，开源社区中大多数人还是希望这两个工具共同存在，并且能够相互支持和借鉴，原因很简单：让更专业的工具完成更专业的事情。</p>
<p>总结一下：Webpack 大而全，Rollup 小而美。</p>
<p>在对它们的选择上，我的基本原则是：应用开发使用 Webpack，类库或者框架开发使用 Rollup。</p>
<p>不过这并不是绝对的标准，只是经验法则。因为 Rollup 也可用于构建绝大多数应用程序，而 Webpack 同样也可以构建类库或者框架。</p>
<p>另外随着近几年 Webpack 的发展，Rollup 中的很多优势几乎已经抹平了，所以这种对比慢慢地也就没有太大意义了。</p>

<hr>
<h3 id="精选评论"><a href="#精选评论" class="headerlink" title="精选评论"></a>精选评论</h3><h5 id="甲："><a href="#甲：" class="headerlink" title="**甲："></a>**甲：</h5><blockquote>
<p>老师有考虑更新下文章，把vue3跟随发布的vite说说吗？😊</p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-讲师回复："><a href="#amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; 之前公开课做了个示例教程，<a target="_blank" rel="noopener" href="https://github.com/zce/vite-essentials">https://github.com/zce/vite-essentials</a></p>
</blockquote>
<h5 id="浩："><a href="#浩：" class="headerlink" title="*浩："></a>*浩：</h5><blockquote>
<p>rollup 和 webpack的对比写的很不错</p>
</blockquote>
<h5 id="恒："><a href="#恒：" class="headerlink" title="**恒："></a>**恒：</h5><blockquote>
<p>支持浏览器环境还有umd 格式</p>
</blockquote>
<h5 id="波："><a href="#波：" class="headerlink" title="*波："></a>*波：</h5><blockquote>
<p>vue-cli-serve 单独打包出了css,我好像没有做其他配置，不知道是哪个配置导致的</p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-1"><a href="#amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-1" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; vue-cli-service 内部集成了 mini-css-extract 插件</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/11/02/%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7%EF%BC%9ARollup-%E5%92%8C-Webpack-%EF%BC%9F/" data-id="claxeera10014v8w138t84l3w" data-title="如何选择打包工具：Rollup 和 Webpack ？" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-如何优化-Webpack-的构建速度和打包结果？" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/11/02/%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96-Webpack-%E7%9A%84%E6%9E%84%E5%BB%BA%E9%80%9F%E5%BA%A6%E5%92%8C%E6%89%93%E5%8C%85%E7%BB%93%E6%9E%9C%EF%BC%9F/" class="article-date">
  <time class="dt-published" datetime="2022-11-02T11:41:07.000Z" itemprop="datePublished">2022-11-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/11/02/%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96-Webpack-%E7%9A%84%E6%9E%84%E5%BB%BA%E9%80%9F%E5%BA%A6%E5%92%8C%E6%89%93%E5%8C%85%E7%BB%93%E6%9E%9C%EF%BC%9F/">如何优化 Webpack 的构建速度和打包结果？</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p data-nodeid="1181" class="">你好，我是汪磊，今天我们要一起探索的是 Webpack 在生产模式打包过程中的常用配置以及一些优化插件。</p>
<p data-nodeid="946">在前面的课时中，我们了解到的一些用法和特性都是为了在开发阶段能够拥有更好的开发体验。而随着这些体验的提升，一个新的问题出现在我们面前：我们的打包结果会变得越来越臃肿。</p>
<p data-nodeid="947">这是因为在这个过程中 Webpack 为了实现这些特性，会自动往打包结果中添加一些内容。例如我们之前用到的 Source Map 和 HMR，它们都会在输出结果中添加额外代码来实现各自的功能。</p>
<p data-nodeid="948">但是这些额外的代码对生产环境来说是冗余的。因为生产环境和开发环境有很大的差异，在生产环境中我们强调的是以更少量、更高效的代码完成业务功能，也就是注重运行效率。而开发环境中我们注重的只是开发效率。</p>
<p data-nodeid="949">那针对这个问题，Webpack 4 推出了 mode 的用法，为我们提供了不同模式下的一些预设配置，其中生产模式下就已经包括了很多优化配置。</p>
<p data-nodeid="950">同时 Webpack 也建议我们为不同的工作环境创建不同的配置，以便于让我们的打包结果可以适用于不同的环境。</p>
<p data-nodeid="951">接下来我们一起来探索一下生产环境中的一些优化方式和注意事项。</p>
<h3 data-nodeid="952">不同环境下的配置</h3>
<p data-nodeid="953">我们先为不同的工作环境创建不同的 Webpack 配置。创建不同环境配置的方式主要有两种：</p>
<ul data-nodeid="2134">
<li data-nodeid="2135">
<p data-nodeid="2136" class="">在配置文件中添加相应的判断条件，根据环境不同导出不同配置；</p>
</li>
<li data-nodeid="2137">
<p data-nodeid="2138">为不同环境单独添加一个配置文件，一个环境对应一个配置文件。</p>
</li>
</ul>


<p data-nodeid="959">我们分别尝试一下通过这两种方式，为开发环境和生产环境创建不同配置。</p>
<p data-nodeid="960">首先我们来看在配置文件中添加判断的方式。我们回到配置文件中，Webpack 配置文件还支持导出一个函数，然后在函数中返回所需要的配置对象。这个函数可以接收两个参数，第一个是 env，是我们通过 CLI 传递的环境名参数，第二个是 argv，是运行 CLI 过程中的所有参数。具体代码如下：</p>
<pre class="lang-javascript" data-nodeid="961"><code data-language="javascript"><span class="hljs-comment">// ./webpack.config.js</span>
<span class="hljs-built_in">module</span>.exports = <span class="hljs-function">(<span class="hljs-params">env, argv</span>) =&gt;</span> &#123;
  <span class="hljs-keyword">return</span> &#123;
    <span class="hljs-comment">// ... webpack 配置</span>
  &#125;
&#125;
</code></pre>
<p data-nodeid="962">那我们就可以借助这个特点，为开发环境和生产环境创建不同配置。我先将不同模式下公共的配置定义为一个 config 对象，具体代码如下：</p>
<pre class="lang-javascript" data-nodeid="963"><code data-language="javascript"><span class="hljs-comment">// ./webpack.config.js</span>
<span class="hljs-built_in">module</span>.exports = <span class="hljs-function">(<span class="hljs-params">env, argv</span>) =&gt;</span> &#123;
  <span class="hljs-keyword">const</span> config = &#123;
    <span class="hljs-comment">// ... 不同模式下的公共配置</span>
  &#125;
  <span class="hljs-keyword">return</span> config
&#125;
</code></pre>
<p data-nodeid="964">然后通过判断，再为 config 对象添加不同环境下的特殊配置。具体如下：</p>
<pre class="lang-javascript" data-nodeid="965"><code data-language="javascript"><span class="hljs-comment">// ./webpack.config.js</span>
<span class="hljs-built_in">module</span>.exports = <span class="hljs-function">(<span class="hljs-params">env, argv</span>) =&gt;</span> &#123;
  <span class="hljs-keyword">const</span> config = &#123;
    <span class="hljs-comment">// ... 不同模式下的公共配置</span>
  &#125;


<p>  <span class="hljs-keyword">if</span> (env &#x3D;&#x3D;&#x3D; <span class="hljs-string">‘development’</span>) &#123;<br>    <span class="hljs-comment">&#x2F;&#x2F; 为 config 添加开发模式下的特殊配置</span><br>    config.mode &#x3D; <span class="hljs-string">‘development’</span><br>    config.devtool &#x3D; <span class="hljs-string">‘cheap-eval-module-source-map’</span><br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (env &#x3D;&#x3D;&#x3D; <span class="hljs-string">‘production’</span>) &#123;<br>    <span class="hljs-comment">&#x2F;&#x2F; 为 config 添加生产模式下的特殊配置</span><br>    config.mode &#x3D; <span class="hljs-string">‘production’</span><br>    config.devtool &#x3D; <span class="hljs-string">‘nosources-source-map’</span><br>  &#125;</p>
<p>  <span class="hljs-keyword">return</span> config<br>&#125;<br></code></pre></p>
<p data-nodeid="966">例如这里，我们判断 env 等于 development（开发模式）的时候，我们将 mode 设置为 development，将 devtool 设置为 cheap-eval-module-source-map；而当 env 等于 production（生产模式）时，我们又将 mode 和 devtool 设置为生产模式下需要的值。</p>
<p data-nodeid="967">当然，你还可以分别为不同模式设置其他不同的属性、插件，这也都是类似的。</p>
<p data-nodeid="968">通过这种方式完成配置过后，我们打开命令行终端，这里我们再去执行 webpack 命令时就可以通过 --env 参数去指定具体的环境名称，从而实现在不同环境中使用不同的配置。</p>
<p data-nodeid="969">那这就是通过在 Webpack 配置文件导出的函数中对环境进行判断，从而实现不同环境对应不同配置。这种方式是 Webpack 建议的方式。</p>
<p data-nodeid="970">你也可以直接定义环境变量，然后在全局判断环境变量，根据环境变量的不同导出不同配置。这种方式也是类似的，这里我们就不做过多介绍了。</p>
<h4 data-nodeid="971">不同环境的配置文件</h4>
<p data-nodeid="972">通过判断环境名参数返回不同配置对象的方式只适用于中小型项目，因为一旦项目变得复杂，我们的配置也会一起变得复杂起来。所以对于大型的项目来说，还是建议使用不同环境对应不同配置文件的方式来实现。</p>
<p data-nodeid="973">一般在这种方式下，项目中最少会有三个 webpack 的配置文件。其中两个用来分别适配开发环境和生产环境，另外一个则是公共配置。因为开发环境和生产环境的配置并不是完全不同的，所以需要一个公共文件来抽象两者相同的配置。具体配置文件结构如下：</p>
<pre class="lang-java" data-nodeid="974"><code data-language="java">.
├── webpack.common.js ···························· 公共配置
├── webpack.dev.js ······························· 开发模式配置
└── webpack.prod.js ······························ 生产模式配置
</code></pre>
<p data-nodeid="975">首先我们在项目根目录下新建一个 webpack.common.js，在这个文件中导出不同模式下的公共配置；然后再来创建一个 webpack.dev.js 和一个 webpack.prod.js 分别定义开发和生产环境特殊的配置。</p>
<p data-nodeid="976">在不同环境的具体配置中我们先导入公共配置对象，然后这里可以使用 Object.assign 方法把公共配置对象复制到具体环境的配置对象中，并且同时去覆盖其中的一些配置。具体如下：</p>
<pre class="lang-javascript" data-nodeid="977"><code data-language="javascript"><span class="hljs-comment">// ./webpack.common.js</span>
<span class="hljs-built_in">module</span>.exports = &#123;
  <span class="hljs-comment">// ... 公共配置</span>
&#125;
<span class="hljs-comment">// ./webpack.prod.js</span>
<span class="hljs-keyword">const</span> common = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./webpack.common'</span>)
<span class="hljs-built_in">module</span>.exports = <span class="hljs-built_in">Object</span>.assign(common, &#123;
  <span class="hljs-comment">// 生产模式配置</span>
&#125;)
<span class="hljs-comment">// ./webpack.dev.js</span>
<span class="hljs-keyword">const</span> common = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./webpack.common'</span>)
<span class="hljs-built_in">module</span>.exports = <span class="hljs-built_in">Object</span>.assign(common, &#123;
  <span class="hljs-comment">// 开发模式配置</span>
&#125;)
</code></pre>
<p data-nodeid="978">如果你熟悉 Object.assign 方法，就应该知道，这个方法会完全覆盖掉前一个对象中的同名属性。这个特点对于普通值类型属性的覆盖都没有什么问题。但是像配置中的 plugins 这种数组，我们只是希望在原有公共配置的插件基础上添加一些插件，那 Object.assign 就做不到了。</p>
<p data-nodeid="979">所以我们需要更合适的方法来合并这里的配置与公共的配置。你可以使用 <a target="_blank" rel="noopener" href="http://lodash.com" data-nodeid="1081">Lodash</a> 提供的 merge 函数来实现，不过社区中提供了更为专业的模块 <a target="_blank" rel="noopener" href="https://github.com/survivejs/webpack-merge" data-nodeid="1085">webpack-merge</a>，它专门用来满足我们这里合并 Webpack 配置的需求。</p>
<p data-nodeid="980">我们可以先通过 npm 安装一下 webpack-merge 模块。具体命令如下：</p>
<pre class="lang-shell" data-nodeid="981"><code data-language="shell"><span class="hljs-meta">$</span><span class="bash"> npm i webpack-merge --save-dev </span>
<span class="hljs-meta">#</span><span class="bash"> or yarn add webpack-merge --dev</span>
</code></pre>
<p data-nodeid="5917" class="">安装完成过后我们回到配置文件中，这里先载入这个模块。那这个模块导出的就是一个 merge 函数，我们使用这个函数来合并这里的配置与公共的配置。具体代码如下：</p>


<pre class="lang-javascript" data-nodeid="983"><code data-language="javascript"><span class="hljs-comment">// ./webpack.common.js</span>
<span class="hljs-built_in">module</span>.exports = &#123;
  <span class="hljs-comment">// ... 公共配置</span>
&#125;
<span class="hljs-comment">// ./webpack.prod.js</span>
<span class="hljs-keyword">const</span> merge = <span class="hljs-built_in">require</span>(<span class="hljs-string">'webpack-merge'</span>)
<span class="hljs-keyword">const</span> common = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./webpack.common'</span>)
<span class="hljs-built_in">module</span>.exports = merge(common, &#123;
  <span class="hljs-comment">// 生产模式配置</span>
&#125;)
<span class="hljs-comment">// ./webpack.dev.jss</span>
<span class="hljs-keyword">const</span> merge = <span class="hljs-built_in">require</span>(<span class="hljs-string">'webpack-merge'</span>)
<span class="hljs-keyword">const</span> common = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./webpack.common'</span>)
<span class="hljs-built_in">module</span>.exports = merge(common, &#123;
  <span class="hljs-comment">// 开发模式配置</span>
&#125;)
</code></pre>
<p data-nodeid="984">使用 webpack-merge 过后，我们这里的配置对象就可以跟普通的 webpack 配置一样，需要什么就配置什么，merge 函数内部会自动处理合并的逻辑。</p>
<p data-nodeid="985">分别配置完成过后，我们再次回到命令行终端，然后尝试运行 webpack 打包。不过因为这里已经没有默认的配置文件了，所以我们需要通过 --config 参数来指定我们所使用的配置文件路径。例如：</p>
<pre class="lang-shell" data-nodeid="986"><code data-language="shell"><span class="hljs-meta">$</span><span class="bash"> webpack --config webpack.prod.js</span>
</code></pre>
<p data-nodeid="3087" class="">当然，如果你觉得这样操作让我们的命令变得更复杂了，那你可以把这个构建命令定义到 npm scripts 中，方便使用。</p>

<h3 data-nodeid="988">生产模式下的优化插件</h3>
<p data-nodeid="989">在 Webpack 4 中新增的 production 模式下，内部就自动开启了很多通用的优化功能。对于使用者而言，开箱即用是非常方便的，但是对于学习者而言，这种开箱即用会导致我们忽略掉很多需要了解的东西。以至于出现问题无从下手。</p>
<p data-nodeid="990"><br>
如果你想要深入了解 Webpack 的使用，我建议你去单独研究每一个配置背后的作用。这里我们先一起学习 production 模式下几个主要的优化功能，顺便了解一下 Webpack 如何优化打包结果。</p>
<h4 data-nodeid="991">Define Plugin</h4>
<p data-nodeid="992">首先是 DefinePlugin，DefinePlugin 是用来为我们代码中注入全局成员的。在 production 模式下，默认通过这个插件往代码中注入了一个 process.env.NODE_ENV。很多第三方模块都是通过这个成员去判断运行环境，从而决定是否执行例如打印日志之类的操作。</p>
<p data-nodeid="993">这里我们来单独使用一下这个插件。我们回到配置文件中，DefinePlugin 是一个内置的插件，所以我们先导入 webpack 模块，然后再到 plugins 中添加这个插件。这个插件的构造函数接收一个对象参数，对象中的成员都可以被注入到代码中。具体代码如下：</p>
<pre class="lang-javascript" data-nodeid="994"><code data-language="javascript">// ./webpack.config.js
const webpack = require('webpack')
module.exports = &#123;
/  // ... 其他配置
  plugins: [
    new webpack.DefinePlugin(&#123;
      API_BASE_URL: 'https://api.example.com'
    &#125;)
  ]
&#125;
</code></pre>
<p data-nodeid="995">例如我们这里通过 DefinePlugin 定义一个 API_BASE_URL，用来为我们的代码注入 API 服务地址，它的值是一个字符串。</p>
<p data-nodeid="996">然后我们回到代码中打印这个 API_BASE_URL。具体代码如下：</p>
<pre class="lang-javascript" data-nodeid="997"><code data-language="javascript"><span class="hljs-comment">// ./src/main.js</span>
<span class="hljs-built_in">console</span>.log(API_BASE_URL)
</code></pre>
<p data-nodeid="998">完成以后我们打开控制台，然后运行 webpack 打包。打包完成过后我们找到打包的结果，然后找到 main.js 对应的模块。具体结果如下：</p>
<p data-nodeid="999"><img src="https://s0.lgstatic.com/i/image/M00/10/E9/Ciqc1F7LaHWAV84JAADT7IV7CvE825.png" alt="image (3).png" data-nodeid="1115"></p>
<p data-nodeid="1000">这里我们发现 DefinePlugin 其实就是把我们配置的字符串内容直接替换到了代码中，而目前这个字符串的内容为 https://api.example.com，字符串中并没有包含引号，所以替换进来语法自然有问题。</p>
<p data-nodeid="1001">正确的做法是传入一个字符串字面量语句。具体实现如下：</p>
<pre class="lang-javascript" data-nodeid="1002"><code data-language="javascript"><span class="hljs-comment">// ./webpack.config.js</span>
<span class="hljs-keyword">const</span> webpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">'webpack'</span>)
<span class="hljs-built_in">module</span>.exports = &#123;
  <span class="hljs-comment">// ... 其他配置</span>
  <span class="hljs-attr">plugins</span>: [
    <span class="hljs-keyword">new</span> webpack.DefinePlugin(&#123;
      <span class="hljs-comment">// 值要求的是一个代码片段</span>
      <span class="hljs-attr">API_BASE_URL</span>: <span class="hljs-string">'"https://api.example.com"'</span>
    &#125;)
  ]
&#125;
</code></pre>
<p data-nodeid="1003">这样代码内的 API_BASE_URL 就会被替换为 "https://api.example.com"。具体结果如下：</p>
<p data-nodeid="1004"><img src="https://s0.lgstatic.com/i/image/M00/10/F5/CgqCHl7LaH-AMPKrAADQsK6wHzM717.png" alt="image (4).png" data-nodeid="1129"></p>
<p data-nodeid="1005">另外，这里有一个非常常用的小技巧，如果我们需要注入的是一个值，就可以通过 JSON.stringify 的方式来得到表示这个值的字面量。这样就不容易出错了。具体实现如下：</p>
<pre class="lang-javascript" data-nodeid="1006"><code data-language="javascript"><span class="hljs-comment">// ./webpack.config.js</span>
<span class="hljs-keyword">const</span> webpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">'webpack'</span>)
<span class="hljs-built_in">module</span>.exports = &#123;
  <span class="hljs-comment">// ... 其他配置</span>
  <span class="hljs-attr">plugins</span>: [
    <span class="hljs-keyword">new</span> webpack.DefinePlugin(&#123;
      <span class="hljs-comment">// 值要求的是一个代码片段</span>
      <span class="hljs-attr">API_BASE_URL</span>: <span class="hljs-built_in">JSON</span>.stringify(<span class="hljs-string">'https://api.example.com'</span>)
    &#125;)
  ]
&#125;
</code></pre>
<p data-nodeid="1007">DefinePlugin 的作用虽然简单，但是却非常有用，我们可以用它在代码中注入一些可能变化的值。</p>
<h3 data-nodeid="1008">Mini CSS Extract Plugin</h3>
<p data-nodeid="1009">对于 CSS 文件的打包，一般我们会使用 style-loader 进行处理，这种处理方式最终的打包结果就是 CSS 代码会内嵌到 JS 代码中。</p>
<p data-nodeid="4507" class="">mini-css-extract-plugin 是一个可以将 CSS 代码从打包结果中提取出来的插件，它的使用非常简单，同样也需要先通过 npm 安装一下这个插件。具体命令如下：</p>



<pre class="lang-shell" data-nodeid="1012"><code data-language="shell"><span class="hljs-meta">$</span><span class="bash"> npm i mini-css-extract-plugin --save-dev</span>
</code></pre>
<p data-nodeid="1013">安装完成过后，我们回到 Webpack 的配置文件。具体配置如下：</p>
<pre class="lang-javascript" data-nodeid="1014"><code data-language="javascript"><span class="hljs-comment">// ./webpack.config.js</span>
<span class="hljs-keyword">const</span> MiniCssExtractPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">'mini-css-extract-plugin'</span>)
<span class="hljs-built_in">module</span>.exports = &#123;
  <span class="hljs-attr">mode</span>: <span class="hljs-string">'none'</span>,
  <span class="hljs-attr">entry</span>: &#123;
    <span class="hljs-attr">main</span>: <span class="hljs-string">'./src/index.js'</span>
  &#125;,
  <span class="hljs-attr">output</span>: &#123;
    <span class="hljs-attr">filename</span>: <span class="hljs-string">'[name].bundle.js'</span>
  &#125;,
  <span class="hljs-attr">module</span>: &#123;
    <span class="hljs-attr">rules</span>: [
      &#123;
        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.css$/</span>,
        use: [
          <span class="hljs-comment">// 'style-loader', // 将样式通过 style 标签注入</span>
          MiniCssExtractPlugin.loader,
          <span class="hljs-string">'css-loader'</span>
        ]
      &#125;
    ]
  &#125;,
  <span class="hljs-attr">plugins</span>: [
    <span class="hljs-keyword">new</span> MiniCssExtractPlugin()
  ]
&#125;
</code></pre>
<p data-nodeid="1015">我们这里先导入这个插件模块，导入过后我们就可以将这个插件添加到配置对象的 plugins 数组中了。这样 Mini CSS Extract Plugin 在工作时就会自动提取代码中的 CSS 了。</p>
<p data-nodeid="1016">除此以外，Mini CSS Extract Plugin 还需要我们使用 MiniCssExtractPlugin 中提供的 loader 去替换掉 style-loader，以此来捕获到所有的样式。</p>
<p data-nodeid="1017">这样的话，打包过后，样式就会存放在独立的文件中，直接通过 link 标签引入页面。</p>
<p data-nodeid="1018" class="">不过这里需要注意的是，如果你的 CSS 体积不是很大的话，提取到单个文件中，效果可能适得其反，因为单独的文件就需要单独请求一次。个人经验是如果 CSS 超过 200KB 才需要考虑是否提取出来，作为单独的文件。</p>
<h4 data-nodeid="1019">Optimize CSS Assets Webpack Plugin</h4>
<p data-nodeid="1020">使用了 Mini CSS Extract Plugin 过后，样式就被提取到单独的 CSS 文件中了。但是这里同样有一个小问题。</p>
<p data-nodeid="1021">我们回到命令行，这里我们以生产模式运行打包。那按照之前的了解，生产模式下会自动压缩输出的结果，我们可以打开打包生成的 JS 文件。具体结果如下：</p>
<p data-nodeid="1022"><img src="https://s0.lgstatic.com/i/image/M00/10/E9/Ciqc1F7LaIqATAzSAAQyyz8qCXE919.png" alt="image (5).png" data-nodeid="1146"></p>
<p data-nodeid="1023">然后我们再打开输出的样式文件。具体结果如下：</p>
<p data-nodeid="1024"><img src="https://s0.lgstatic.com/i/image/M00/10/E9/Ciqc1F7LaJGAKXO2AAEBLBn8-rQ140.png" alt="image (6).png" data-nodeid="1150"></p>
<p data-nodeid="1025">这里我们发现 JavaScript 文件正常被压缩了，而样式文件并没有被压缩。</p>
<p data-nodeid="1026">这是因为，Webpack 内置的压缩插件仅仅是针对 JS 文件的压缩，其他资源文件的压缩都需要额外的插件。</p>
<p data-nodeid="1027">Webpack 官方推荐了一个 <a target="_blank" rel="noopener" href="https://www.npmjs.com/package/optimize-css-assets-webpack-plugin" data-nodeid="1156">Optimize CSS Assets Webpack Plugin</a> 插件。我们可以使用这个插件来压缩我们的样式文件。</p>
<p data-nodeid="1028">我们回到命令行，先来安装这个插件，具体命令如下：</p>
<pre class="lang-shell" data-nodeid="1029"><code data-language="shell"><span class="hljs-meta">$</span><span class="bash"> npm i optimize-css-assets-webpack-plugin --save-dev</span>
</code></pre>
<p data-nodeid="1030">安装完成过后，我们回到配置文件中，添加对应的配置。具体代码如下：</p>
<pre class="lang-javascript" data-nodeid="1031"><code data-language="javascript"><span class="hljs-comment">// ./webpack.config.js</span>
<span class="hljs-keyword">const</span> MiniCssExtractPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">'mini-css-extract-plugin'</span>)
<span class="hljs-keyword">const</span> OptimizeCssAssetsWebpackPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">'optimize-css-assets-webpack-plugin'</span>)
<span class="hljs-built_in">module</span>.exports = &#123;
  <span class="hljs-attr">mode</span>: <span class="hljs-string">'none'</span>,
  <span class="hljs-attr">entry</span>: &#123;
    <span class="hljs-attr">main</span>: <span class="hljs-string">'./src/index.js'</span>
  &#125;,
  <span class="hljs-attr">output</span>: &#123;
    <span class="hljs-attr">filename</span>: <span class="hljs-string">'[name].bundle.js'</span>
  &#125;,
  <span class="hljs-attr">module</span>: &#123;
    <span class="hljs-attr">rules</span>: [
      &#123;
        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.css$/</span>,
        use: [
          MiniCssExtractPlugin.loader,
          <span class="hljs-string">'css-loader'</span>
        ]
      &#125;
    ]
  &#125;,
  <span class="hljs-attr">plugins</span>: [
    <span class="hljs-keyword">new</span> MiniCssExtractPlugin(),
    <span class="hljs-keyword">new</span> OptimizeCssAssetsWebpackPlugin()
  ]
&#125;
</code></pre>
<p data-nodeid="1032">这里同样先导入这个插件，导入完成以后我们把这个插件添加到 plugins 数组中。</p>
<p data-nodeid="1033">那此时我们再次回到命令行运行打包。</p>
<p data-nodeid="1034">打包完成过后，我们的样式文件就会以压缩格式输出了。具体结果如下：</p>
<p data-nodeid="1035"><img src="https://s0.lgstatic.com/i/image/M00/10/E9/Ciqc1F7LaJqAAsfEAAJeBFjqfT8020.png" alt="image (7).png" data-nodeid="1165"></p>
<p data-nodeid="1036">不过这里还有个额外的小点，可能你会在这个插件的官方文档中发现，文档中的这个插件并不是配置在 plugins 数组中的，而是添加到了 optimization 对象中的 minimizer 属性中。具体如下：</p>
<pre class="lang-javascript" data-nodeid="1037"><code data-language="javascript"><span class="hljs-comment">// ./webpack.config.js</span>
<span class="hljs-keyword">const</span> MiniCssExtractPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">'mini-css-extract-plugin'</span>)
<span class="hljs-keyword">const</span> OptimizeCssAssetsWebpackPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">'optimize-css-assets-webpack-plugin'</span>)
<span class="hljs-built_in">module</span>.exports = &#123;
  <span class="hljs-attr">mode</span>: <span class="hljs-string">'none'</span>,
  <span class="hljs-attr">entry</span>: &#123;
    <span class="hljs-attr">main</span>: <span class="hljs-string">'./src/index.js'</span>
  &#125;,
  <span class="hljs-attr">output</span>: &#123;
    <span class="hljs-attr">filename</span>: <span class="hljs-string">'[name].bundle.js'</span>
  &#125;,
  <span class="hljs-attr">optimization</span>: &#123;
    <span class="hljs-attr">minimizer</span>: [
      <span class="hljs-keyword">new</span> OptimizeCssAssetsWebpackPlugin()
    ]
  &#125;,
  <span class="hljs-attr">module</span>: &#123;
    <span class="hljs-attr">rules</span>: [
      &#123;
        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.css$/</span>,
        use: [
          MiniCssExtractPlugin.loader,
          <span class="hljs-string">'css-loader'</span>
        ]
      &#125;
    ]
  &#125;,
  <span class="hljs-attr">plugins</span>: [
    <span class="hljs-keyword">new</span> MiniCssExtractPlugin()
  ]
&#125;
</code></pre>
<p data-nodeid="1038">那这是为什么呢？</p>
<p data-nodeid="1039">其实也很简单，如果我们配置到 plugins 属性中，那么这个插件在任何情况下都会工作。而配置到 minimizer 中，就只会在 minimize 特性开启时才工作。</p>
<p data-nodeid="1040">所以 Webpack 建议像这种压缩插件，应该我们配置到 minimizer 中，便于 minimize 选项的统一控制。</p>
<p data-nodeid="1041">但是这么配置也有个缺点，此时我们再次运行生产模式打包，打包完成后再来看一眼输出的 JS 文件，此时你会发现，原本可以自动压缩的 JS，现在却不能压缩了。具体 JS 的输出结果如下：</p>
<p data-nodeid="1042"><img src="https://s0.lgstatic.com/i/image/M00/10/F5/CgqCHl7LaKeAOdc4AAJbN7rhhA8880.png" alt="image (8).png" data-nodeid="1173"></p>
<p data-nodeid="1043">那这是因为我们设置了 minimizer，Webpack 认为我们需要使用自定义压缩器插件，那内部的 JS 压缩器就会被覆盖掉。我们必须手动再添加回来。</p>
<p data-nodeid="1044">内置的 JS 压缩插件叫作 terser-webpack-plugin，我们回到命令行手动安装一下这个模块。</p>
<pre class="lang-shell" data-nodeid="1045"><code data-language="shell"><span class="hljs-meta">$</span><span class="bash"> npm i terser-webpack-plugin --save-dev</span>
</code></pre>
<p data-nodeid="1046">安装完成过后，这里我们再手动添加这个模块到 minimizer 配置当中。具体代码如下：</p>
<pre class="lang-javascript" data-nodeid="1047"><code data-language="javascript"><span class="hljs-comment">// ./webpack.config.js</span>
<span class="hljs-keyword">const</span> MiniCssExtractPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">'mini-css-extract-plugin'</span>)
<span class="hljs-keyword">const</span> OptimizeCssAssetsWebpackPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">'optimize-css-assets-webpack-plugin'</span>)
<span class="hljs-keyword">const</span> TerserWebpackPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">'terser-webpack-plugin'</span>)
<span class="hljs-built_in">module</span>.exports = &#123;
  <span class="hljs-attr">mode</span>: <span class="hljs-string">'none'</span>,
  <span class="hljs-attr">entry</span>: &#123;
    <span class="hljs-attr">main</span>: <span class="hljs-string">'./src/index.js'</span>
  &#125;,
  <span class="hljs-attr">output</span>: &#123;
    <span class="hljs-attr">filename</span>: <span class="hljs-string">'[name].bundle.js'</span>
  &#125;,
  <span class="hljs-attr">optimization</span>: &#123;
    <span class="hljs-attr">minimizer</span>: [
      <span class="hljs-keyword">new</span> TerserWebpackPlugin(),
      <span class="hljs-keyword">new</span> OptimizeCssAssetsWebpackPlugin()
    ]
  &#125;,
  <span class="hljs-attr">module</span>: &#123;
    <span class="hljs-attr">rules</span>: [
      &#123;
        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.css$/</span>,
        use: [
          MiniCssExtractPlugin.loader,
          <span class="hljs-string">'css-loader'</span>
        ]
      &#125;
    ]
  &#125;,
  <span class="hljs-attr">plugins</span>: [
    <span class="hljs-keyword">new</span> MiniCssExtractPlugin()
  ]
&#125;
</code></pre>
<p data-nodeid="1048">那这样的话，我们再次以生产模式运行打包，JS 文件和 CSS 文件就都可以正常压缩了。</p>
<h3 data-nodeid="1049">写在最后</h3>
<p data-nodeid="1050">最后再来简单总结一下，本课时我们介绍了如何为 Webpack 添加不同环境下的不同配置，以及在生产模式打包时我们经常用到的几个插件。</p>
<p data-nodeid="1051" class="">这当中需要你理解的地方并没有太多，更多的是了解这些插件的具体作用和使用方法。除此之外，你也需要更多地了解社区当中其他的常用插件。</p>

<hr>
<h3 id="精选评论"><a href="#精选评论" class="headerlink" title="精选评论"></a>精选评论</h3><h5 id="相："><a href="#相：" class="headerlink" title="**相："></a>**相：</h5><blockquote>
<p>老师，您好。就像你最后说的，多去了解社区中其他常用的插件，我也是每次遇到别人写的不认识的配置才去查官网，后面也容易忘。而且，每次去直接翻阅官网上的配置时，太多了又看不下去，那您一般是如何发现优秀的插件或者配置方式的呢</p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-讲师回复："><a href="#amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; 一般我有一个明确的需求过后，我都会根据需求提炼出关键词，然后通过 Google &#x2F; GitHub 搜索，最后再根据找到模块的使用情况以及更新情况决定是否使用</p>
</blockquote>
<h5 id="春："><a href="#春：" class="headerlink" title="**春："></a>**春：</h5><blockquote>
<p>老师，你的git仓库地址是啥。想看看代码</p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-1"><a href="#amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-1" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; <a target="_blank" rel="noopener" href="https://github.com/zce/webpack-demo">https://github.com/zce/webpack-demo</a></p>
</blockquote>
<h5 id="5547："><a href="#5547：" class="headerlink" title="**5547："></a>**5547：</h5><blockquote>
<p>Css文件超过200kb才考虑是否提取出来是指整个项目的css文件还是单个css文件</p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-2"><a href="#amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-2" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; 单个 CSS 文件超过 200KB</p>
</blockquote>
<h5 id="程："><a href="#程：" class="headerlink" title="**程："></a>**程：</h5><blockquote>
<p>我想问下loader是倒序执行的，那optimization的minimizer也是倒序 执行 吗？</p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-3"><a href="#amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-3" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; 每种资源最终只需要使用一个 minimizer，不回涉及到多个压缩器同时压缩同一个资源的情况，也就不会有先后执行的问题</p>
</blockquote>
<h5 id="gjd："><a href="#gjd：" class="headerlink" title="gjd："></a>gjd：</h5><blockquote>
<p>程序是如何识别rc文件的？webpack如何让程序只设置rc文件就可以代替webpack.config.js</p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-4"><a href="#amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-4" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; Webpack 的配置只支持 js 文件的方式，至于其他常见工具的配置，很多会支持 rc 类型文件，这些工具内部都是使用的：<a target="_blank" rel="noopener" href="https://www.npmjs.com/package/cosmiconfig">https://www.npmjs.com/package/cosmiconfig</a> 这个模块解析的配置文件</p>
</blockquote>
<h5 id="德："><a href="#德：" class="headerlink" title="**德："></a>**德：</h5><blockquote>
<p>webpack5可以用 ‘…’ 把默认的minimizer展开，方便很多了</p>
</blockquote>
<h5 id="冰："><a href="#冰：" class="headerlink" title="**冰："></a>**冰：</h5><blockquote>
<p>打包过后，样式就会存放在独立的文件中，直接通过 link 标签引入页面老师，这样有什么好处，相比于内嵌在js中引入？</p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-5"><a href="#amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-5" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; 主要的原因是样式打包到 js 内部，如果样式代码太多，就会导致单个 JS 文件过大，请求时间过长</p>
</blockquote>
<h5 id="冰：-1"><a href="#冰：-1" class="headerlink" title="**冰："></a>**冰：</h5><blockquote>
<p>为什么要分离出css文件呢，有什么好处？</p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-6"><a href="#amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-6" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; 主要的原因是样式打包到 js 内部，如果样式代码太多，就会导致单个 JS 文件过大，请求时间过长</p>
</blockquote>
<h5 id="龙："><a href="#龙：" class="headerlink" title="**龙："></a>**龙：</h5><blockquote>
<p>老师, 通过 DefinePlugin 定义的变量 跟环境变量有什么区别吗？特别是在接口请求上，测试跟正式接口地址是不一样的，因而通过环境变量进行处理，但是都是使用 process.env.*** 来进行获取， 而通过 DefinePlugin 是直接使用变量来获取。这块应该如何处理较好？</p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-7"><a href="#amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-7" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; DefinePlugin 是往我们的代码中注入可能发生变化的成员，跟 process.env 没有关系，我们编写的业务代码并不是运行在 Node 下的</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/11/02/%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96-Webpack-%E7%9A%84%E6%9E%84%E5%BB%BA%E9%80%9F%E5%BA%A6%E5%92%8C%E6%89%93%E5%8C%85%E7%BB%93%E6%9E%9C%EF%BC%9F/" data-id="claxeer9w000vv8w1dw2gb90b" data-title="如何优化 Webpack 的构建速度和打包结果？" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-玩转-Webpack-高级特性应对项目优化需求（上）" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/11/02/%E7%8E%A9%E8%BD%AC-Webpack-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E5%BA%94%E5%AF%B9%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96%E9%9C%80%E6%B1%82%EF%BC%88%E4%B8%8A%EF%BC%89/" class="article-date">
  <time class="dt-published" datetime="2022-11-02T11:40:23.000Z" itemprop="datePublished">2022-11-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/11/02/%E7%8E%A9%E8%BD%AC-Webpack-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E5%BA%94%E5%AF%B9%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96%E9%9C%80%E6%B1%82%EF%BC%88%E4%B8%8A%EF%BC%89/">玩转 Webpack 高级特性应对项目优化需求（上）</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>今天我将和你分享 Webpack 的两个高级特性，分别是 Tree Shaking 和 sideEffects。</p>
<p>它们都属于 Webpack 打包结果优化的必备特性，而且现在应用的也十分广泛。</p>
<h3>Tree Shaking</h3>
<p>Tree Shaking 翻译过来的意思就是“摇树”。伴随着摇树的动作，树上的枯树枝和树叶就会掉落下来。</p>
<p>我们这里要介绍的 Tree-shaking 也是同样的道理，不过通过 Tree-shaking “摇掉”的是代码中那些没有用到的部分，这部分没有用的代码更专业的说法应该叫作未引用代码（dead-code）。</p>
<p>Tree-shaking 最早是 <a target="_blank" rel="noopener" href="https://rollupjs.org">Rollup</a> 中推出的一个特性，Webpack 从 2.0 过后开始支持这个特性。</p>
<p>我们使用 Webpack 生产模式打包的优化过程中，就使用自动开启这个功能，以此来检测我们代码中的未引用代码，然后自动移除它们。</p>
<p>我们可以先来体验一下这个功能的效果，这里我的源代码非常简单，只有两个文件。</p>
<pre><code data-language="js" class="lang-js">└─ <span class="hljs-number">09</span>-tree-shaking
   ├── src
   │   ├── components.js
   │   └── main.js
   ├── package.json
   └── webpack.config.js
</code></pre>
<p>其中 components.js 中导出了一些函数，这些函数各自模拟了一个组件，具体代码如下：</p>
<pre><code data-language="js" class="lang-js"><span class="hljs-comment">// ./src/components.js</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> Button = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'button'</span>)
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'dead-code'</span>)
&#125;


<p><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> Link &#x3D; <span class="hljs-function"><span class="hljs-params">()</span> &#x3D;&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">‘a’</span>)<br>&#125;</p>
<p><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> Heading &#x3D; <span class="hljs-function"><span class="hljs-params">level</span> &#x3D;&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">‘h’</span> + level)<br>&#125;<br></code></pre></p>
<p>其中 Button 组件函数中，在 return 过后还有一个 console.log() 语句，很明显这句代码永远都不会被执行，所以这个 console.log() 就属于未引用代码。</p>
<p>在 main.js 文件中只是导入了 compnents.js，具体代码如下：</p>
<pre><code data-language="js" class="lang-js"><span class="hljs-comment">// ./src/main.js</span>
<span class="hljs-keyword">import</span> &#123; Button &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./components'</span>
<span class="hljs-built_in">document</span>.body.appendChild(Button())
</code></pre>
<p>但是注意这里导入 components 模块时，我们只提取了模块中的 Button 成员，那这就导致components 模块中很多地方都不会被用到，那这些地方就是冗余的，具体冗余部分如下：</p>
<pre><code data-language="js" class="lang-js"><span class="hljs-comment">// ./src/components.js</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> Button = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'button'</span>)
  <span class="hljs-comment">// 未引用代码</span>
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'dead-code'</span>)
&#125;
<span class="hljs-comment">// 未引用代码</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> Link = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'a'</span>)
&#125;
<span class="hljs-comment">// 未引用代码</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> Heading = <span class="hljs-function"><span class="hljs-params">level</span> =&gt;</span> &#123;
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'h'</span> + level)
&#125;
</code></pre>
<p>去除冗余代码是生产环境优化中一个很重要的工作，Webpack 的 Tree-shaking 功能就很好地实现了这一点。</p>
<p>我们打开命令行终端，这里我们尝试以 production 模式运行打包，具体命令如下：</p>
<pre><code data-language="SQL" class="lang-SQL">$ npx webpack <span class="hljs-comment">--mode=production</span>
</code></pre>
<p>Webpack 的 Tree-shaking 特性在生产模式下会自动开启。打包完成以后我们打开输出的 bundle.js，具体结果如下：</p>
<p><img src="https://s0.lgstatic.com/i/image/M00/0C/24/CgqCHl7CJgCAODEAAAL-CbA2wi8995.png" alt="image.png"></p>
<p>通过搜索你会发现，components 模块中冗余的代码根本没有输出。这就是经过 Tree-shaking 处理过后的效果。</p>
<p>试想一下，如果我们在项目中引入 <a target="_blank" rel="noopener" href="https://lodash.com">Lodash</a> 这种工具库，大部分情况下我们只会使用其中的某几个工具函数，而其他没有用到的部分就是冗余代码。通过 Tree-shaking 就可以极大地减少最终打包后 bundle 的体积。</p>
<p>需要注意的是，Tree-shaking 并不是指 Webpack 中的某一个配置选项，而是一组功能搭配使用过后实现的效果，这组功能在生产模式下都会自动启用，所以使用生产模式打包就会有 Tree-shaking 的效果。</p>
<h4>开启 Tree Shaking</h4>
<p>由于目前官方文档中对于 Tree-shaking 的介绍有点混乱，所以我们这里再来介绍一下在其他模式下，如何一步一步手动开启 Tree-shaking。通过这个过程，还可以顺便了解 Tree-shaking 的工作过程和 Webpack 其他的一些优化功能。</p>
<p>这里还是上述的案例结构，我们再次运行 Webpack 打包，不过这一次我们不再使用 production 模式，而是使用 none，也就是不开启任何内置功能和插件，具体命令如下：</p>
<pre><code data-language="SQL" class="lang-SQL">$ npx webpack <span class="hljs-comment">--mode=none</span>
</code></pre>
<p>打包完成过后，我们再次找到输出的 bundle.js 文件，具体结果如下：</p>
<p><img src="https://s0.lgstatic.com/i/image/M00/0C/18/Ciqc1F7CJg2AWdwCAARsXLiQbZg849.png" alt="image (1).png"></p>
<p>这里的打包结果跟我们在第二讲中分析的是一样的，源代码中的一个模块对应这里的一个函数。</p>
<p>我们这里注意一下 components 对应的这个模块，虽然外部没有使用这里的 Link 函数和 Heading 函数，但是仍然导出了它们，具体如下图所示：</p>
<p><img src="https://s0.lgstatic.com/i/image/M00/0C/19/Ciqc1F7CJuSAWnoVAALlDoFDv_I403.png" alt="image (2).png"></p>
<p>显然这种导出是没有任何意义的。</p>
<p>明确目前打包结果的状态过后，我们打开 Webpack 的配置文件，在配置对象中添加一个 optimization 属性，这个属性用来集中配置 Webpack 内置优化功能，它的值也是一个对象。</p>
<p>在 optimization 对象中我们可以先开启一个 usedExports 选项，表示在输出结果中只导出外部使用了的成员，具体配置代码如下：</p>
<pre><code data-language="js" class="lang-js"><span class="hljs-comment">// ./webpack.config.js</span>
<span class="hljs-built_in">module</span>.exports = &#123;
  <span class="hljs-comment">// ... 其他配置项</span>
  <span class="hljs-attr">optimization</span>: &#123;
    <span class="hljs-comment">// 模块只导出被使用的成员</span>
    <span class="hljs-attr">usedExports</span>: <span class="hljs-literal">true</span>
  &#125;
&#125;
</code></pre>
<p>配置完成后，重新打包，然后我们再来看一下输出的 bundle.js，具体结果如下图：</p>
<p><img src="https://s0.lgstatic.com/i/image/M00/0C/24/CgqCHl7CJhaAYA52AAPjj4F6_IY241.png" alt="image (3).png"></p>
<p>此时你会发现 components 模块所对应的函数，就不再导出 Link 和 Heading 这两个函数了，那它们对应的代码就变成了未引用代码。而且如果你使用的是 VS Code，会发现 VS Code 将这两个函数名的颜色变淡了，这是为了表示它们未被引用。</p>
<p>对于这种未引用代码，如果我们开启压缩代码功能，就可以自动压缩掉这些没有用到的代码。</p>
<p>我们可以回到配置文件中，尝试在 optimization 配置中开启 minimize，具体配置如下：</p>
<pre><code data-language="js" class="lang-js"><span class="hljs-comment">// ./webpack.config.js</span>
<span class="hljs-built_in">module</span>.exports = &#123;
  <span class="hljs-comment">// ... 其他配置项</span>
  <span class="hljs-attr">optimization</span>: &#123;
    <span class="hljs-comment">// 模块只导出被使用的成员</span>
    <span class="hljs-attr">usedExports</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-comment">// 压缩输出结果</span>
    <span class="hljs-attr">minimize</span>: <span class="hljs-literal">true</span>
  &#125;
&#125;
</code></pre>
<p>然后再次回到命令行重新运行打包，具体结果如下图所示：</p>
<p><img src="https://s0.lgstatic.com/i/image/M00/0C/25/CgqCHl7CJviAEtOzAANZJYj6ZSM190.png" alt="image (4).png"></p>
<p>仔细查看打包结果，你会发现，Link 和 Heading 这些未引用代码都被自动移除了。</p>
<p>这就是 Tree-shaking 的实现，整个过程用到了 Webpack 的两个优化功能：</p>
<ul>
<li>usedExports - 打包结果中只导出外部用到的成员；</li>
<li>minimize - 压缩打包结果。</li>
</ul>
<p>如果把我们的代码看成一棵大树，那你可以这样理解：</p>
<ul>
<li>usedExports 的作用就是标记树上哪些是枯树枝、枯树叶；</li>
<li>minimize 的作用就是负责把枯树枝、枯树叶摇下来。</li>
</ul>
<h4>合并模块（扩展）</h4>
<p>除了 usedExports 选项之外，我们还可以使用一个 concatenateModules 选项继续优化输出。</p>
<p>普通打包只是将一个模块最终放入一个单独的函数中，如果我们的模块很多，就意味着在输出结果中会有很多的模块函数。</p>
<p>concatenateModules 配置的作用就是尽可能将所有模块合并到一起输出到一个函数中，这样既提升了运行效率，又减少了代码的体积。</p>
<p>我们回到配置文件中，这里我们在 optimization 属性中开启 concatenateModules。同时，为了更好地看到效果，我们先关闭 minimize，具体配置如下：</p>
<pre><code data-language="js" class="lang-js"><span class="hljs-comment">// ./webpack.config.js</span>
<span class="hljs-built_in">module</span>.exports = &#123;
  <span class="hljs-comment">// ... 其他配置项</span>
  <span class="hljs-attr">optimization</span>: &#123;
    <span class="hljs-comment">// 模块只导出被使用的成员</span>
    <span class="hljs-attr">usedExports</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-comment">// 尽可能合并每一个模块到一个函数中</span>
    <span class="hljs-attr">concatenateModules</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-comment">// 压缩输出结果</span>
    <span class="hljs-attr">minimize</span>: <span class="hljs-literal">false</span>
  &#125;
&#125;
</code></pre>
<p>然后回到命令行终端再次运行打包。那此时 bundle.js 中就不再是一个模块对应一个函数了，而是把所有的模块都放到了一个函数中，具体结果如下：</p>
<p><img src="https://s0.lgstatic.com/i/image/M00/0C/25/CgqCHl7CJwSAD4A7AAKMt-CKLKo558.png" alt="image (5).png"></p>
<p>这个特性又被称为 Scope Hoisting，也就是作用域提升，它是 Webpack 3.0 中添加的一个特性。</p>
<p>如果再配合 minimize 选项，打包结果的体积又会减小很多。</p>
<h4>结合 babel-loader 的问题</h4>
<p>因为早期的 Webpack 发展非常快，那变化也就比较多，所以当我们去找资料时，得到的结果不一定适用于当前我们所使用的版本。而 Tree-shaking 的资料更是如此，很多资料中都表示“<em>为 JS 模块配置 babel-loader，会导致 Tree-shaking 失效</em>”。</p>
<p>针对这个问题，这里我统一说明一下：</p>
<p>首先你需要明确一点：<strong>Tree-shaking 实现的前提是 ES Modules</strong>，也就是说：最终<strong>交给 Webpack 打包的代码，必须是使用 ES Modules 的方式来组织的模块化</strong>。</p>
<p>为什么这么说呢？</p>
<p>我们都知道 Webpack 在打包所有的模块代码之前，先是将模块根据配置交给不同的 Loader 处理，最后再将 Loader 处理的结果打包到一起。</p>
<p>很多时候，我们为了更好的兼容性，会选择使用 <a target="_blank" rel="noopener" href="https://github.com/babel/babel-loader">babel-loader</a> 去转换我们源代码中的一些 ECMAScript 的新特性。而 Babel 在转换 JS 代码时，很有可能处理掉我们代码中的 ES Modules 部分，把它们转换成 CommonJS 的方式，如下图所示：</p>
<p><img src="https://s0.lgstatic.com/i/image/M00/0C/1E/Ciqc1F7CKjiAeXTAAABAsbetEV0413.png" alt="1.png"></p>
<p>当然了，Babel 具体会不会处理 ES Modules 代码，取决于我们有没有为它配置使用转换 ES Modules 的插件。</p>
<p>很多时候，我们为 Babel 配置的都是一个 preset（预设插件集合），而不是某些具体的插件。例如，目前市面上使用最多的 <a target="_blank" rel="noopener" href="https://babeljs.io/docs/en/babel-preset-env">@babel/preset-env</a>，这个预设里面就有<a target="_blank" rel="noopener" href="https://babeljs.io/docs/en/babel-plugin-transform-modules-commonjs">转换 ES Modules 的插件</a>。所以当我们使用这个预设时，代码中的 ES Modules 部分就会被转换成 CommonJS 方式。那 Webpack 再去打包时，拿到的就是以 CommonJS 方式组织的代码了，所以 Tree-shaking 不能生效。</p>
<p>那我们这里具体来尝试一下。为了可以更容易分辨结果，我们只开启 usedExports，完整配置如下：</p>
<pre><code data-language="js" class="lang-js"><span class="hljs-comment">// ./webpack.config.js</span>
<span class="hljs-built_in">module</span>.exports = &#123;
  <span class="hljs-attr">mode</span>: <span class="hljs-string">'none'</span>,
  <span class="hljs-attr">entry</span>: <span class="hljs-string">'./src/main.js'</span>,
  <span class="hljs-attr">output</span>: &#123;
    <span class="hljs-attr">filename</span>: <span class="hljs-string">'bundle.js'</span>
  &#125;,
  <span class="hljs-attr">module</span>: &#123;
    <span class="hljs-attr">rules</span>: [
      &#123;
        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.js$/</span>,
        <span class="hljs-attr">use</span>: &#123;
          <span class="hljs-attr">loader</span>: <span class="hljs-string">'babel-loader'</span>,
          <span class="hljs-attr">options</span>: &#123;
            <span class="hljs-attr">presets</span>: [
              [<span class="hljs-string">'@babel/preset-env'</span>]
            ]
          &#125;
        &#125;
      &#125;
    ]
  &#125;,
  <span class="hljs-attr">optimization</span>: &#123;
    <span class="hljs-attr">usedExports</span>: <span class="hljs-literal">true</span>
  &#125;
&#125;
</code></pre>
<p>配置完成过后，我们打开命令行终端，运行 Webpack 打包命令，然后再找到 bundle.js，具体结果如下：</p>
<p><img src="https://s0.lgstatic.com/i/image/M00/0C/25/CgqCHl7CJyKAIcvUAAPfiYLuH3k609.png" alt="image (7).png"></p>
<p>仔细查看你会发现，结果并不是像刚刚说的那样，这里 usedExports 功能仍然正常工作了，此时，如果我们压缩代码，这些未引用的代码依然会被移除。这也就说明 Tree-shaking 并没有失效。</p>
<p>那到底是怎么回事呢？为什么很多资料都说 babel-loader 会导致 Tree-shaking 失效，但当我们<strong>实际尝试</strong>后又发现并没有失效？</p>
<p>其实，这是因为在最新版本（8.x）的 babel-loader 中，已经自动帮我们关闭了对 ES Modules 转换的插件，你可以参考对应版本 babel-loader 的<a target="_blank" rel="noopener" href="https://github.com/babel/babel-loader/blob/v8.1.0/src/injectCaller.js">源码</a>，核心代码如下：</p>
<p><img src="https://s0.lgstatic.com/i/image/M00/0C/25/CgqCHl7CJyuAXIeGAAIXqPpxX4w402.png" alt="image (8).png"></p>
<p>通过查阅 babel-loader 模块的源码，我们发现它已经在 injectCaller 函数中标识了当前环境支持 ES Modules。</p>
<p>然后再找到我们所使用的 @babal/preset-env 模块源码，部分核心代码如下：</p>
<p><img src="https://s0.lgstatic.com/i/image/M00/0C/25/CgqCHl7CJzSARd1WAAHTUcAc7ig911.png" alt="image (9).png"></p>
<p>在这个模块中，根据环境标识自动禁用了对 ES Modules 的转换插件，所以<strong>经过 babel-loader 处理后的代码默认仍然是 ES Modules，那 Webpack 最终打包得到的还是 ES Modules 代码，Tree-shaking 自然也就可以正常工作了</strong>。</p>
<p>我们也可以在 babel-loader 的配置中强制开启 ES Modules 转换插件来试一下，具体配置如下：</p>
<pre><code data-language="js" class="lang-js"><span class="hljs-comment">// ./webpack.config.js</span>
<span class="hljs-built_in">module</span>.exports = &#123;
  <span class="hljs-attr">mode</span>: <span class="hljs-string">'none'</span>,
  <span class="hljs-attr">entry</span>: <span class="hljs-string">'./src/main.js'</span>,
  <span class="hljs-attr">output</span>: &#123;
    <span class="hljs-attr">filename</span>: <span class="hljs-string">'bundle.js'</span>
  &#125;,
  <span class="hljs-attr">module</span>: &#123;
    <span class="hljs-attr">rules</span>: [
      &#123;
        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.js$/</span>,
        <span class="hljs-attr">use</span>: &#123;
          <span class="hljs-attr">loader</span>: <span class="hljs-string">'babel-loader'</span>,
          <span class="hljs-attr">options</span>: &#123;
            <span class="hljs-attr">presets</span>: [
              [<span class="hljs-string">'@babel/preset-env'</span>, &#123; <span class="hljs-attr">modules</span>: <span class="hljs-string">'commonjs'</span> &#125;]
            ]
          &#125;
        &#125;
      &#125;
    ]
  &#125;,
  <span class="hljs-attr">optimization</span>: &#123;
    <span class="hljs-attr">usedExports</span>: <span class="hljs-literal">true</span>
  &#125;
&#125;
</code></pre>
<p>给 Babel preset 添加配置的方式比较特别，这里很多人都会配错，一定要注意。它需要把预设数组中的成员定义成一个数组，然后这个数组中的第一个成员就是所使用的 preset 的名称，第二个成员就是给这个 preset 定义的配置对象。</p>
<p>我们在这个对象中将 modules 属性设置为 "commonjs"，默认这个属性是 auto，也就是根据环境判断是否开启 ES Modules 插件，我们设置为 commonjs 就表示我们强制使用 Babel 的 ES Modules 插件把代码中的 ES Modules 转换为 CommonJS。</p>
<p>完成以后，我们再次打开命令行终端，运行 Webpack 打包。然后找到 bundle.js，结果如下：</p>
<p><img src="https://s0.lgstatic.com/i/image/M00/0C/25/CgqCHl7CJz6AAc34AAKFOT56VyQ546.png" alt="image (10).png"></p>
<p>此时，你就会发现 usedExports 没法生效了。即便我们开启压缩代码，Tree-shaking 也会失效。</p>
<p>总结一下，这里通过实验发现，最新版本的 babel-loader 并不会导致 Tree-shaking 失效。如果你不确定现在使用的 babel-loader 会不会导致这个问题，最简单的办法就是在配置中将 @babel/preset-env 的 modules 属性设置为 false，确保不会转换 ES Modules，也就确保了 Tree-shaking 的前提。</p>
<p>另外，我们刚刚探索的过程也值得你仔细再去琢磨一下，通过这样的探索能够帮助你了解很多背后的原因，做到“知其然，知其所以然”。</p>
<h3>sideEffects</h3>
<p>Webpack 4 中新增了一个 sideEffects 特性，它允许我们通过配置标识我们的代码是否有副作用，从而提供更大的压缩空间。</p>
<blockquote>
<p>TIPS：模块的副作用指的就是模块执行的时候除了导出成员，是否还做了其他的事情。</p>
</blockquote>
<p>这个特性一般只有我们去开发一个 npm 模块时才会用到。因为官网把对 sideEffects 特性的介绍跟 Tree-shaking 混到了一起，所以很多人误认为它们之间是因果关系，其实它们没有什么太大的关系。</p>
<p>我们先把 sideEffects 特性本身的作用弄明白，你就更容易理解为什么说它跟 Tree-shaking 没什么关系了。</p>
<p>这里我先设计一个 sideEffects 能够发挥效果的场景，案例具体结构如下：</p>
<pre><code data-language="java" class="lang-java">.
├── src
│   ├── components
│   │   ├── button.js
│   │   ├── heading.js
│   │   ├── index.js
│   │   └── link.js
│   └── main.js
├── <span class="hljs-keyword">package</span>.json
└── webpack.config.js
</code></pre>
<p>基于上一个案例的基础上，我们把 components 模块拆分出多个组件文件，然后在 components/index.js 中集中导出，以便于外界集中导入，具体 index.js 代码如下：</p>
<pre><code data-language="js" class="lang-js"><span class="hljs-comment">// ./src/components/index.js</span>
<span class="hljs-keyword">export</span> &#123; <span class="hljs-keyword">default</span> <span class="hljs-keyword">as</span> Button &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./button'</span>
<span class="hljs-keyword">export</span> &#123; <span class="hljs-keyword">default</span> <span class="hljs-keyword">as</span> Link &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./link'</span>
<span class="hljs-keyword">export</span> &#123; <span class="hljs-keyword">default</span> <span class="hljs-keyword">as</span> Heading &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./heading'</span>
</code></pre>
<p>这也是我们经常见到一种同类文件的组织方式。另外，在每个组件中，我们都添加了一个 console 操作（副作用代码），具体代码如下：</p>
<pre><code data-language="js" class="lang-js"><span class="hljs-comment">// ./src/components/button.js</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Button component~'</span>) <span class="hljs-comment">// 副作用代码</span>


<p><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> () &#x3D;&gt; &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">‘button’</span>)<br>&#125;</p>
<p>我们再到打包入口文件（main.js）中去载入 components 中的 Button 成员，具体代码如下：</p>
<p><span class="hljs-comment">&#x2F;&#x2F; .&#x2F;src&#x2F;main.js</span><br><span class="hljs-keyword">import</span> &#123; Button &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">‘.&#x2F;components’</span></p>
<p><span class="hljs-built_in">document</span>.body.appendChild(Button())<br></code></pre></p>
<p>那这样就会出现一个问题，虽然我们在这里只是希望载入 Button 模块，但实际上载入的是 components/index.js，而 index.js 中又载入了这个目录中全部的组件模块，这就会导致所有组件模块都会被加载执行。</p>
<p>我们打开命令行终端，尝试运行打包，打包完成过后找到打包结果，具体结果如下：</p>
<p><img src="https://s0.lgstatic.com/i/image/M00/0C/26/CgqCHl7CJ0yAGDd6AAIWFCrr50U502.png" alt="image (11).png"></p>
<p>根据打包结果发现，所有的组件模块都被打包进了 bundle.js。</p>
<p>此时如果我们开启 Tree-shaking 特性（只设置 useExports），这里没有用到的导出成员其实最终也可以被移除，打包效果如下：</p>
<p><img src="https://s0.lgstatic.com/i/image/M00/0C/26/CgqCHl7CJ1WAHn9oAANiI-_U6Uw344.png" alt="image (12).png"></p>
<p>但是由于这些成员所属的模块中有副作用代码，所以就导致最终 Tree-shaking 过后，这些模块并不会被完全移除。</p>
<p>可能你会认为这些代码应该保留下来，而实际情况是，这些模块内的副作用代码一般都是为这个模块服务的，例如这里我添加的 console.log，就是希望表示一下当前这个模块被加载了。但是最终整个模块都没用到，也就没必要留下这些副作用代码了。</p>
<p>所以说，<strong>Tree-shaking 只能移除没有用到的代码成员，而想要完整移除没有用到的模块，那就需要开启 sideEffects 特性了</strong>。</p>
<h4>sideEffects 作用</h4>
<p>我们打开 Webpack 的配置文件，在 optimization 中开启 sideEffects 特性，具体配置如下：</p>
<pre><code data-language="js" class="lang-js"><span class="hljs-comment">// ./webpack.config.js</span>
<span class="hljs-built_in">module</span>.exports = &#123;
  <span class="hljs-attr">mode</span>: <span class="hljs-string">'none'</span>,
  <span class="hljs-attr">entry</span>: <span class="hljs-string">'./src/main.js'</span>,
  <span class="hljs-attr">output</span>: &#123;
    <span class="hljs-attr">filename</span>: <span class="hljs-string">'bundle.js'</span>
  &#125;,
  <span class="hljs-attr">optimization</span>: &#123;
    <span class="hljs-attr">sideEffects</span>: <span class="hljs-literal">true</span>
  &#125;
&#125;
</code></pre>
<blockquote>
<p>TIPS：注意这个特性在 production 模式下同样会自动开启。</p>
</blockquote>
<p>那此时 Webpack 在打包某个模块之前，会先检查这个模块所属的 package.json 中的 sideEffects 标识，以此来判断这个模块是否有副作用，如果没有副作用的话，这些没用到的模块就不再被打包。换句话说，即便这些没有用到的模块中存在一些副作用代码，我们也可以通过 package.json 中的 sideEffects 去强制声明没有副作用。</p>
<p>那我们打开项目 package.json 添加一个 sideEffects 字段，把它设置为 false，具体代码如下：</p>
<pre><code data-language="js" class="lang-js">&#123;
  <span class="hljs-string">"name"</span>: <span class="hljs-string">"09-side-effects"</span>,
  <span class="hljs-string">"version"</span>: <span class="hljs-string">"0.1.0"</span>,
  <span class="hljs-string">"author"</span>: <span class="hljs-string">"zce &lt;w@zce.me&gt; (https://zce.me)"</span>,
  <span class="hljs-string">"license"</span>: <span class="hljs-string">"MIT"</span>,
  <span class="hljs-string">"scripts"</span>: &#123;
    <span class="hljs-string">"build"</span>: <span class="hljs-string">"webpack"</span>
  &#125;,
  <span class="hljs-string">"devDependencies"</span>: &#123;
    <span class="hljs-string">"webpack"</span>: <span class="hljs-string">"^4.43.0"</span>,
    <span class="hljs-string">"webpack-cli"</span>: <span class="hljs-string">"^3.3.11"</span>
  &#125;,
  <span class="hljs-string">"sideEffects"</span>: <span class="hljs-literal">false</span>
&#125;
</code></pre>
<p>这样就表示我们这个项目中的所有代码都没有副作用，让 Webpack 放心大胆地去“干”。</p>
<p>完成以后我们再次运行打包，然后同样找到打包输出的 bundle.js 文件，结果如下：</p>
<p><img src="https://s0.lgstatic.com/i/image/M00/0C/1A/Ciqc1F7CJ2GAd6ktAALO5DYhwXo465.png" alt="image (13).png"></p>
<p>此时那些没有用到的模块就彻底不会被打包进来了。那这就是 sideEffects 的作用。</p>
<p>这里设置了两个地方：</p>
<ul>
<li>webpack.config.js 中的 sideEffects 用来开启这个功能；</li>
<li>package.json 中的 sideEffects 用来标识我们的代码没有副作用。</li>
</ul>
<p>目前很多第三方的库或者框架都已经使用了 sideEffects 标识，所以我们再也不用担心为了一个小功能引入一个很大体积的库了。例如，某个 UI 组件库中只有一两个组件会用到，那只要它支持 sideEffects，你就可以放心大胆的直接用了。</p>
<h4>sideEffects 注意</h4>
<p>使用 sideEffects 这个功能的前提是确定你的代码没有副作用，或者副作用代码没有全局影响，否则打包时就会误删掉你那些有意义的副作用代码。</p>
<p>例如，我这里准备的 extend.js 模块：</p>
<pre><code data-language="js" class="lang-js"><span class="hljs-comment">// ./src/extend.js</span>
<span class="hljs-comment">// 为 Number 的原型添加一个扩展方法</span>
<span class="hljs-built_in">Number</span>.prototype.pad = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">size</span>) </span>&#123;
  <span class="hljs-keyword">const</span> leadingZeros = <span class="hljs-built_in">Array</span>(size + <span class="hljs-number">1</span>).join(<span class="hljs-number">0</span>)
  <span class="hljs-keyword">return</span> leadingZeros + <span class="hljs-keyword">this</span>
&#125;
</code></pre>
<p>在这个模块中并没有导出任何成员，仅仅是在 Number 的原型上挂载了一个 pad 方法，用来为数字添加前面的导零，这是一种很早以前常见的基于原型的扩展方法。</p>
<p>我们回到 main.js 中去导入 extend 模块，具体代码如下：</p>
<pre><code data-language="js" class="lang-js"><span class="hljs-comment">// ./src/main.js</span>
<span class="hljs-keyword">import</span> <span class="hljs-string">'./extend'</span> <span class="hljs-comment">// 内部包含影响全局的副作用</span>


<p><span class="hljs-built_in">console</span>.log((<span class="hljs-number">8</span>).pad(<span class="hljs-number">3</span>)) <span class="hljs-comment">&#x2F;&#x2F; &#x3D;&gt; ‘0008’</span><br></code></pre></p>
<p>因为这个模块确实没有导出任何成员，所以这里也就不需要提取任何成员。导入过后就可以使用它为 Number 提供扩展方法了。</p>
<p>这里为 Number 类型做扩展的操作就是 extend 模块对全局产生的副作用。</p>
<p>此时如果我们还是通过 package.json 标识我们代码没有副作用，那么再次打包过后，就会出现问题。我们可以找到打包结果，如下图所示：</p>
<p><img src="https://s0.lgstatic.com/i/image/M00/0C/1A/Ciqc1F7CJ2qAEv1ZAAFrFf6WvFI346.png" alt="image (14).png"></p>
<p>我们看到，对 Number 的扩展模块并不会打包进来。</p>
<p>缺少了对 Number 的扩展操作，我们的代码再去运行的时候，就会出现错误。这种扩展的操作属于对全局产生的副作用。</p>
<p>这种基于原型的扩展方式，在很多 Polyfill 库中都会大量出现，比较常见的有 <a target="_blank" rel="noopener" href="https://github.com/stefanpenner/es6-promise">es6-promise</a>，这种模块都属于典型的副作用模块。</p>
<p>除此之外，我们在 JS 中直接载入的 CSS 模块，也都属于副作用模块，同样会面临这种问题。</p>
<p>所以说不是所有的副作用都应该被移除，有一些必要的副作用需要保留下来。</p>
<p>最好的办法就是在 package.json 中的 sideEffects 字段中标识需要保留副作用的模块路径（可以使用通配符），具体配置如下：</p>
<pre><code data-language="js" class="lang-js">&#123;
  <span class="hljs-string">"name"</span>: <span class="hljs-string">"09-side-effects"</span>,
  <span class="hljs-string">"version"</span>: <span class="hljs-string">"0.1.0"</span>,
  <span class="hljs-string">"author"</span>: <span class="hljs-string">"zce &lt;w@zce.me&gt; (https://zce.me)"</span>,
  <span class="hljs-string">"license"</span>: <span class="hljs-string">"MIT"</span>,
  <span class="hljs-string">"scripts"</span>: &#123;
    <span class="hljs-string">"build"</span>: <span class="hljs-string">"webpack"</span>
  &#125;,
  <span class="hljs-string">"devDependencies"</span>: &#123;
    <span class="hljs-string">"webpack"</span>: <span class="hljs-string">"^4.43.0"</span>,
    <span class="hljs-string">"webpack-cli"</span>: <span class="hljs-string">"^3.3.11"</span>
  &#125;,
  <span class="hljs-string">"sideEffects"</span>: [
    <span class="hljs-string">"./src/extend.js"</span>,
    <span class="hljs-string">"*.css"</span>
  ]
&#125;
</code></pre>
<p>这样 Webpack 的 sideEffects 就不会忽略确实有必要的副作用模块了。</p>
<h3>写在最后</h3>
<p>最后我们来总结一下，今天介绍到了两个 Webpack 中的高级特性，分别是 Tree-shaking 和 sideEffects。</p>
<p>Tree-shaking 的本身没有太多需要你理解和思考的地方，你只需要了解它的效果，以及相关的配置即可。</p>
<p>而 sideEffects 可能需要你花点时间去理解一下，重点就是想明白哪些副作用代码是可以随着模块的移除而移除，哪些又是不可以移除的。总结下来其实也很简单：对全局有影响的副作用代码不能移除，而只是对模块有影响的副作用代码就可以移除。</p>
<p>总之不管是 Tree-shaking 还是 sideEffects，我个人认为，它们都是为了弥补 JavaScript 早期在模块系统设计上的不足。随着 Webpack 这类技术的发展，JavaScript 的模块化确实越来越好用，也越来越合理。</p>
<p>除此之外，我还想强调一点，当你对这些特性有了一定的了解之后，就应该意识到：尽可能不要写影响全局的副作用代码。</p>

<hr>
<h3 id="精选评论"><a href="#精选评论" class="headerlink" title="精选评论"></a>精选评论</h3><h5 id="8439："><a href="#8439：" class="headerlink" title="**8439："></a>**8439：</h5><blockquote>
<p>汪老师你好，有个疑问(在这个模块中，根据环境标识自动禁用了对 ES Modules 的转换插件，所以经过 babel-loader 处理后的代码默认仍然是 ES Modules，那 Webpack 最终打包得到的还是 ES Modules 代码，Tree-shaking 自然也就可以正常工作了。)&#x3D;&#x3D;&gt;那这个意思是webpack拿到的结果是es module代码，webpack可以直接处理吗？打包得到的结果浏览器可以执行么？</p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-讲师回复："><a href="#amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; Webpack 内部可以直接处理 ES Modules，打包后的结果中 ES Modules 部分都会被转换掉</p>
</blockquote>
<h5 id="勇："><a href="#勇：" class="headerlink" title="*勇："></a>*勇：</h5><blockquote>
<p>切记：两个sideEffects 含义不一样！“webpack.config.js 中的 sideEffects 用来开启这个功能；package.json 中的 sideEffects 用来标识我们的代码没有副作用。”</p>
</blockquote>
<h5 id="胤："><a href="#胤：" class="headerlink" title="**胤："></a>**胤：</h5><blockquote>
<p>道理我都懂，可是为什么用es语法引入lodash的时候无法tree-shake掉多余代码呢<div><br></div><div><code>import &#123;get&#125; from &#39;lodash&#39;</code></div><div><br></div><div>仍然会把整个包都打包进来</div></p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-1"><a href="#amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-1" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; 因为 lodash 模块中采用的是 CommonJS，tree-shaking 的前提是 ESM</p>
</blockquote>
<h5 id="欢："><a href="#欢：" class="headerlink" title="*欢："></a>*欢：</h5><blockquote>
<p>这下终于理解tree-shaking和sideEffects以及babel-loader的关系了.</p>
</blockquote>
<h5 id="帆："><a href="#帆：" class="headerlink" title="**帆："></a>**帆：</h5><blockquote>
<p>import {get} from ‘lodash-es’ 支持ES Module</p>
</blockquote>
<h5 id="伟："><a href="#伟：" class="headerlink" title="**伟："></a>**伟：</h5><blockquote>
<p>茅塞顿开</p>
</blockquote>
<h5 id="源："><a href="#源：" class="headerlink" title="**源："></a>**源：</h5><blockquote>
<p>老师，请问，既然生成环境都会自动打开这些特性来优化，比如“树摇”，在开发环境使用有什么好处呢？开发环境可以不过多关注包体积吧?是为了方便借助开发环境分析生成环境打包情况吗？</p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-2"><a href="#amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-2" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; 我们只是为了演示出 Tree-shaking 的效果，并非是开发阶段就需要这么干，这种优化操作需要耗时的，开发阶段没必要，而且也不方便 Debug</p>
</blockquote>
<h5 id="杰："><a href="#杰：" class="headerlink" title="**杰："></a>**杰：</h5><blockquote>
<p>今日学习打卡</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/11/02/%E7%8E%A9%E8%BD%AC-Webpack-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E5%BA%94%E5%AF%B9%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96%E9%9C%80%E6%B1%82%EF%BC%88%E4%B8%8A%EF%BC%89/" data-id="claxeera8001kv8w1fjnhgfaq" data-title="玩转 Webpack 高级特性应对项目优化需求（上）" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-如何让你的模块支持热替换（HMR）机制？" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/11/02/%E5%A6%82%E4%BD%95%E8%AE%A9%E4%BD%A0%E7%9A%84%E6%A8%A1%E5%9D%97%E6%94%AF%E6%8C%81%E7%83%AD%E6%9B%BF%E6%8D%A2%EF%BC%88HMR%EF%BC%89%E6%9C%BA%E5%88%B6%EF%BC%9F/" class="article-date">
  <time class="dt-published" datetime="2022-11-02T11:39:40.000Z" itemprop="datePublished">2022-11-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/11/02/%E5%A6%82%E4%BD%95%E8%AE%A9%E4%BD%A0%E7%9A%84%E6%A8%A1%E5%9D%97%E6%94%AF%E6%8C%81%E7%83%AD%E6%9B%BF%E6%8D%A2%EF%BC%88HMR%EF%BC%89%E6%9C%BA%E5%88%B6%EF%BC%9F/">如何让你的模块支持热替换（HMR）机制？</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>在第六讲中我们已经简单了解了 Webpack Dev Server 的一些基本用法和特性，它为我们使用 Webpack 构建的项目，提供了一个比较友好的开发环境和一个用于调试的开发服务器。</p>
<p>使用 Webpack Dev Server 就可以让我们在开发过程中专注编码，因为它可以自动监视我们代码的变化然后自动进行打包，最后通过自动刷新的方式同步到浏览器以便于我们即时预览，效果如下：</p>
<p><img src="https://s0.lgstatic.com/i/image/M00/09/1D/Ciqc1F67uVGANMuRAAwzuBVY37c734.gif" alt="live-reloading.gif"></p>
<h3>自动刷新的问题</h3>
<p>但是当你实际去使用 Webpack Dev Server 自动刷新的特性去完成具体的开发任务时，你会发现还是有一些不舒服的地方。</p>
<p>例如，这里是一个编辑器应用，我想要即时调试这个编辑器中内容文本的样式。那正常的操作肯定是我先尝试在编辑器里面去添加一些文本，作为展示样例，再回到开发工具中，找到控制编辑器样式的 CSS 文件，然后进行编辑，具体操作如下：</p>
<p><img src="https://s0.lgstatic.com/i/image/M00/09/1D/Ciqc1F67uV2ASstCAA8cz1bBH8g073.gif" alt="live-reloading-issue.gif"></p>
<p>那这时候我们就能够发现问题了：当我们修改完编辑器文本对应的样式过后，原本想着可以即时看到最新的界面效果，但是这时编辑器中的内容却没有了。</p>
<p>这时就不得不再次回到应用中再来添加一些测试文本，查看样式效果。那如果修改后还是对样式不满意的话，你还需要继续调整样式，<strong>调整之后又会面临文本内容丢失的问题</strong>。那久而久之你就会发现，自动刷新这个功能还是有点鸡肋，并没有想象的那么好用。</p>
<p>出现这个问题的原因，是因为我们每次修改完代码，Webpack 都可以监视到变化，然后自动打包，再通知浏览器自动刷新，一旦页面整体刷新，那页面中的任何操作状态都将会丢失，所以才会出现我们上面所看到的情况。</p>
<p>但是聪明的你总会想到一些应对方法，例如：</p>
<ul>
<li>回到代码中先写死一个文本内容到编辑器中，这样即便页面刷新，也不会丢失。</li>
<li>通过代码将编辑器中的内容及时保存到 LocalStorage 之类的地方，刷新过后再取回来。</li>
</ul>
<p>总之就是：你有问题，我有办法。</p>
<p>确实这些都是好办法，但是也存在一些不足，因为它们都是典型的“有漏补漏”的操作，并不能根治自动刷新导致页面状态丢失问题，而且这些方法都需要去编写一些与业务本身无关的辅助代码，不利于维护。</p>
<p>更好的办法自然是能够实现在页面不刷新的情况下，代码也可以及时的更新到浏览器的页面中，重新执行，避免页面状态丢失。针对这个需求，Webpack 同样可以满足。</p>
<h3>模块热替换（HMR）</h3>
<p>HMR 全称 Hot Module Replacement，翻译过来叫作“模块热替换”或“模块热更新”。</p>
<p>计算机行业经常听到一个叫作热拔插的名词，指的就是我们可以在一个正在运行的机器上随时插拔设备，机器的运行状态不会受插拔的影响，而且插上去的设备可以立即工作，例如我们电脑上的 USB 端口就可以热拔插。</p>
<p>模块热替换中的“热”和这里提到的“热拔插”是相同的意思，都是指在运行过程中的即时变化。</p>
<p>Webpack 中的模块热替换，指的是我们可以在应用运行过程中，实时的去替换掉应用中的某个模块，而应用的运行状态不会因此而改变。例如，我们在应用运行过程中修改了某个模块，通过自动刷新会导致整个应用的整体刷新，那页面中的状态信息都会丢失；而如果使用的是 HMR，就可以实现只将修改的模块实时替换至应用中，不必完全刷新整个应用。</p>
<p>这里我们可以先来对比一下使用热更新和使用自动刷新两种方式之间的体验差异，我们尝试在项目中开启 HMR 特性，具体效果如下图所示：</p>
<p><img src="https://s0.lgstatic.com/i/image/M00/09/1D/Ciqc1F67uWqAImJxAA3J0FNFIDo287.gif" alt="hmr-experience.gif"></p>
<p>有了 HMR 支持后，我们同样先在页面中随意添加一些内容，也就是为页面制造一些运行状态，然后我们回到开发工具中，再来尝试修改文本的样式，保存过后页面并没有整体刷新，而且我们能立即看到最新的样式。这种体验相对于自动刷新会友好很多。</p>
<p>HMR 对于项目中其他代码文件的修改，也可以有相同的热更新体验。你可以再去尝试修改一下 JS 文件，保存过后，浏览器中同样不会刷新页面，而是直接执行了你刚刚修改的这个模块，具体效果如下：</p>
<p><img src="https://s0.lgstatic.com/i/image/M00/09/1D/Ciqc1F67uXOAc64lAA4l0No8gOk355.gif" alt="hmr-experience-js.gif"></p>
<p>不仅如此，对于非文本文件同样也可以使用热更新。例如这个案例中显示的 Logo 图片，如果你在外部修改了它，同样也可以及时更新到浏览器中。</p>
<p>那这就是 HMR 的作用和体验，HMR 可以算是 Webpack 中最为强大的特性之一，而且也是最受欢迎的特性，因为它确实极大程度地提高了开发者的工作效率。</p>
<h4>开启 HMR</h4>
<p>对于 HMR 这种强大的功能而言，使用起来并不算特别复杂。接下来我们就一起了解一下如何去实现项目中的 HMR。</p>
<p>HMR 已经集成在了 webpack 模块中了，所以不需要再单独安装什么模块。</p>
<p>使用这个特性最简单的方式就是，在运行 webpack-dev-server 命令时，通过 --hot 参数去开启这个特性。</p>
<p>或者也可以在配置文件中通过添加对应的配置来开启这个功能。那我们这里打开配置文件，这里需要配置两个地方：</p>
<ul>
<li>首先需要将 devServer 对象中的 hot 属性设置为 true；</li>
<li>然后需要载入一个插件，这个插件是 webpack 内置的一个插件，所以我们先导入 webpack 模块，有了这个模块过后，这里使用的是一个叫作 HotModuleReplacementPlugin 的插件。</li>
</ul>
<p>具体配置代码如下：</p>
<pre><code data-language="js" class="lang-js"><span class="hljs-comment">// ./webpack.config.js</span>
<span class="hljs-keyword">const</span> webpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">'webpack'</span>)


<p><span class="hljs-built_in">module</span>.exports &#x3D; &#123;<br>  <span class="hljs-comment">&#x2F;&#x2F; …</span><br>  <span class="hljs-attr">devServer</span>: &#123;<br>    <span class="hljs-comment">&#x2F;&#x2F; 开启 HMR 特性，如果资源不支持 HMR 会 fallback 到 live reloading</span><br>    <span class="hljs-attr">hot</span>: <span class="hljs-literal">true</span><br>    <span class="hljs-comment">&#x2F;&#x2F; 只使用 HMR，不会 fallback 到 live reloading</span><br>    <span class="hljs-comment">&#x2F;&#x2F; hotOnly: true</span><br>  &#125;,<br>  <span class="hljs-attr">plugins</span>: [<br>    <span class="hljs-comment">&#x2F;&#x2F; …</span><br>    <span class="hljs-comment">&#x2F;&#x2F; HMR 特性所需要的插件</span><br>    <span class="hljs-keyword">new</span> webpack.HotModuleReplacementPlugin()<br>  ]<br>&#125;<br></code></pre></p>
<p>配置完成以后，我们打开命令行终端，运行 webpack-dev-server，启动开发服务器。那接下来你就可以来体验 HMR 了。</p>
<p>我们回到开发工具中，这里我们先来尝试修改一下 CSS 文件。样式文件修改保存过后，确实能够以不刷新的形式更新到页面中。</p>
<p>然后我们再来尝试一下修改 JS 文件。保存过后你会发现，这里的页面依然自动刷新了，好像并没有之前所说 HMR 的体验。</p>
<p>为了再次确认，你可以尝试先在页面中的编辑器里随意添加一些文字，然后修改代码，保存过后你就会看到页面自动刷新，页面中的状态也就丢失了，具体效果如下图：</p>
<p><img src="https://s0.lgstatic.com/i/image/M00/09/1D/Ciqc1F67uY6AWK-DAAo_tpO6GaI873.gif" alt="js-live-reloading.gif"></p>
<p>那这是为什么呢？为什么 CSS 文件热替换没出现问题，而到了 JS 这块就不行了呢？我们又该如何去实现其他类型模块的热替换呢？</p>
<h4>HMR 的疑问</h4>
<p>通过之前的体验我们发现模块热替换确实提供了非常友好的体验，但是当我们自己去尝试开启 HMR 过后，效果却不尽如人意。</p>
<p>很明显：HMR 并不像 Webpack 的其他特性一样可以开箱即用，需要有一些额外的操作。</p>
<p>具体来说，Webpack 中的 HMR 需要我们手动通过代码去处理，当模块更新过后该，如何把更新后的模块替换到页面中。</p>
<p>Q1：可能你会问，为什么我们开启 HMR 过后，样式文件的修改就可以直接热更新呢？我们好像也没有手动处理样式模块的更新啊？</p>
<p>A1：这是因为样式文件是经过 Loader 处理的，在 style-loader 中就已经自动处理了样式文件的热更新，所以就不需要我们额外手动去处理了。</p>
<p>Q2：那你可能会想，凭什么样式就可以自动处理，而我们的脚本就需要自己手动处理呢？</p>
<p>A2：这个原因也很简单，因为样式模块更新过后，只需要把更新后的 CSS 及时替换到页面中，它就可以覆盖掉之前的样式，从而实现更新。</p>
<p>而我们所编写的 JavaScript 模块是没有任何规律的，你可能导出的是一个对象，也可能导出的是一个字符串，还可能导出的是一个函数，使用时也各不相同。所以 Webpack 面对这些毫无规律的 JS 模块，根本不知道该怎么处理更新后的模块，也就无法直接实现一个可以通用所有情况的模块替换方案。</p>
<p>那这就是为什么样式文件可以直接热更新，而 JS 文件更新后页面还是回退到自动刷新的原因。</p>
<p>Q3：那可能还有一些平时使用 vue-cli 或者 create-react-app 这种框架脚手架工具的人会说，“我的项目就没有手动处理，JavaScript 代码照样可以热替换，也没你说的那么麻烦”。</p>
<p>A3：这是因为你使用的是框架，使用框架开发时，我们项目中的每个文件就有了规律，例如 React 中要求每个模块导出的必须是一个函数或者类，那这样就可以有通用的替换办法，所以这些工具内部都已经帮你实现了通用的替换操作，自然就不需要手动处理了。</p>
<p>当然如果你之前没有接触过这样的工具，那你可以忽略这一条，这也并不影响后面的理解。</p>
<p><strong>综上所述，我们还是需要自己手动通过代码来处理，当 JavaScript 模块更新过后，该如何将更新后的模块替换到页面中。</strong></p>
<h4>HMR APIs</h4>
<p>HotModuleReplacementPlugin 为我们的 JavaScript 提供了一套用于处理 HMR 的 API，我们需要在我们自己的代码中，使用这套 API 将更新后的模块替换到正在运行的页面中。</p>
<p>接下来我们回到代码中，尝试通过 HMR 的 API 手动处理模块更新后的热替换。</p>
<p>这里我们打开 main.js，具体代码如下：</p>
<pre><code data-language="js" class="lang-js"><span class="hljs-comment">// ./src/main.js</span>
<span class="hljs-keyword">import</span> createEditor <span class="hljs-keyword">from</span> <span class="hljs-string">'./editor'</span>
<span class="hljs-keyword">import</span> logo <span class="hljs-keyword">from</span> <span class="hljs-string">'./icon.png'</span>
<span class="hljs-keyword">import</span> <span class="hljs-string">'./global.css'</span>


<p><span class="hljs-keyword">const</span> img &#x3D; <span class="hljs-keyword">new</span> Image()<br>img.src &#x3D; logo<br><span class="hljs-built_in">document</span>.body.appendChild(img)</p>
<p><span class="hljs-keyword">const</span> editor &#x3D; createEditor()<br><span class="hljs-built_in">document</span>.body.appendChild(editor)<br></code></pre></p>
<p>这是 Webpack 打包的入口文件，正常情况下，在这个文件中会加载一些其他模块。正是因为在 main.js 中使用了这些模块，<strong>所以一旦这些模块更新了过后，我们在 main.js 中就必须重新使用更新后的模块</strong>。</p>
<p>所以说，我们需要在这个文件中添加一些额外的代码，去处理它所依赖的这些模块更新后的热替换逻辑。</p>
<p>对于开启 HMR 特性的环境中，我们可以访问到全局的 module 对象中的 hot 成员，这个成员是一个对象，这个对象就是 HMR API 的核心对象，它提供了一个 accept 方法，用于注册当某个模块更新后的处理函数。accept 方法第一个参数接收的就是所监视的依赖模块路径，第二个参数就是依赖模块更新后的处理函数。</p>
<p>那我们这里先尝试注册 ./editor 模块更新过后的处理函数，第一个参数就是 editor 模块的路径，第二个参数则需要我们传入一个函数，然后在这个函数中打印一个消息，具体代码如下：</p>
<pre><code data-language="js" class="lang-js"><span class="hljs-comment">// ./main.js</span>


<p><span class="hljs-comment">&#x2F;&#x2F; … 原本的业务代码</span></p>
<p><span class="hljs-built_in">module</span>.hot.accept(<span class="hljs-string">‘.&#x2F;editor’</span>, () &#x3D;&gt; &#123;<br>  <span class="hljs-comment">&#x2F;&#x2F; 当 .&#x2F;editor.js 更新，自动执行此函数</span><br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">‘editor 更新了～～’</span>)<br>&#125;)<br></code></pre></p>
<p>完成过后，我们打开命令行终端再次启动 webpack-dev-server 命令，然后回到浏览器，打开开发人员工具。</p>
<p>此时，如果我们修改了 editor 模块，保存过后，浏览器的控制台中就会自动打印我们上面在代码中添加的消息，而且浏览器也不会自动刷新了。</p>
<p>那也就是说一旦这个模块的更新被我们手动处理了，就不会触发自动刷新；反之，如果没有手动处理，热替换会自动 fallback（回退）到自动刷新。</p>
<h4>JS 模块热替换</h4>
<p>了解了这个 HMR API 的作用过后，接下来需要考虑的就是：具体如何实现 editor 模块的热替换。</p>
<p>这个模块导出的是一个 createEditor 函数，我们先正常把它打印到控制台，然后在模块更新后的处理函数中再打印一次，具体代码如下：</p>
<pre><code data-language="js" class="lang-js"><span class="hljs-comment">// ./main.js</span>
<span class="hljs-keyword">import</span> createEditor <span class="hljs-keyword">from</span> <span class="hljs-string">'./editor'</span>


<p><span class="hljs-comment">&#x2F;&#x2F; … 原本的业务代码</span></p>
<p><span class="hljs-built_in">console</span>.log(createEditor)<br><span class="hljs-built_in">module</span>.hot.accept(<span class="hljs-string">‘.&#x2F;editor’</span>, () &#x3D;&gt; &#123;<br>  <span class="hljs-built_in">console</span>.log(createEditor)<br>&#125;)<br></code></pre></p>
<p>这个时候如果你再次修改 editor 模块，保存过后，你就会发现当模块更新后，我们这里拿到的 createEditor 函数也就更新为了最新的结果，具体结果如下图所示：</p>
<p><img src="https://s0.lgstatic.com/i/image/M00/09/1D/Ciqc1F67uZ6AU5wjAAvFBUDd75g274.png" alt="image.png"></p>
<p>既然<strong>模块</strong>文件<strong>更新后</strong> createEditor 函数<strong>可以自动更新</strong>，那剩下的就好办了。我们这里使用 createEditor 函数是用来创建一个界面元素的，那模块一旦更新了，这个元素也就需要重新创建，所以我们这里先移除原来的元素，然后再调用更新后的 createEditor 函数，创建一个新的元素追加到页面中，具体代码如下：</p>
<pre><code data-language="js" class="lang-js"><span class="hljs-comment">// ./main.js</span>
<span class="hljs-keyword">import</span> createEditor <span class="hljs-keyword">from</span> <span class="hljs-string">'./editor'</span>


<p><span class="hljs-keyword">const</span> editor &#x3D; createEditor()<br><span class="hljs-built_in">document</span>.body.appendChild(editor)</p>
<p><span class="hljs-comment">&#x2F;&#x2F; … 原本的业务代码</span></p>
<p><span class="hljs-comment">&#x2F;&#x2F; HMR ———————————–</span><br><span class="hljs-built_in">module</span>.hot.accept(<span class="hljs-string">‘.&#x2F;editor’</span>, () &#x3D;&gt; &#123;<br>  <span class="hljs-built_in">document</span>.body.removeChild(editor) <span class="hljs-comment">&#x2F;&#x2F; 移除之前创建的元素</span><br>  <span class="hljs-keyword">const</span> newEditor &#x3D; createEditor() <span class="hljs-comment">&#x2F;&#x2F; 用新模块创建新元素</span><br>  <span class="hljs-built_in">document</span>.body.appendChild(newEditor)<br>&#125;)<br></code></pre></p>
<p>但如果只是这样实现的话，一次热替换结束后，第二次就没法再实现热替换了。因为第二次执行这个函数的时候，editor 变量指向的元素已经在上一次执行时被移除了，所以我们这里还应该记录下来每次热替换创建的新元素，以便于下一次热替换时的操作，具体代码如下：</p>
<pre><code data-language="js" class="lang-js"><span class="hljs-comment">// ./main.js</span>
<span class="hljs-keyword">import</span> createEditor <span class="hljs-keyword">from</span> <span class="hljs-string">'./editor'</span>


<p><span class="hljs-keyword">const</span> editor &#x3D; createEditor()<br><span class="hljs-built_in">document</span>.body.appendChild(editor)</p>
<p><span class="hljs-comment">&#x2F;&#x2F; … 原本的业务代码</span></p>
<p><span class="hljs-comment">&#x2F;&#x2F; HMR ———————————–</span><br><span class="hljs-keyword">let</span> lastEditor &#x3D; editor<br><span class="hljs-built_in">module</span>.hot.accept(<span class="hljs-string">‘.&#x2F;editor’</span>, () &#x3D;&gt; &#123;<br>  <span class="hljs-built_in">document</span>.body.removeChild(lastEditor) <span class="hljs-comment">&#x2F;&#x2F; 移除之前创建的元素</span><br>  lastEditor &#x3D; createEditor() <span class="hljs-comment">&#x2F;&#x2F; 用新模块创建新元素</span><br>  <span class="hljs-built_in">document</span>.body.appendChild(lastEditor)<br>&#125;)<br></code></pre></p>
<p>完成以后，我们再来尝试修改 editor 模块，此时就应该是正常的热替换效果了，具体效果如下图：</p>
<p><img src="https://s0.lgstatic.com/i/image/M00/09/1E/CgqCHl67uamADY97AA4Ht2ooOXA786.gif" alt="module-hot.gif"></p>
<h4>热替换的状态保持</h4>
<p>此时，如果我们尝试在界面上输入一些内容（形成页面操作状态），然后回到代码中再次修改 editor 模块。那此时你仍然会发现问题，由于热替换时，把界面上之前的编辑器元素移除了，替换成了一个新的元素，所以页面上之前的状态同样会丢失。</p>
<p>这也就证明我们的热替换操作还需要改进，我们必须在替换时把状态保留下来。</p>
<p>我们回到 main.js 中，要想保留这个状态也很简单，就是在替换前先拿到编辑器中的内容，然后替换后在放回去就行了。那因为我这里使用的是可编辑元素，而不是文本框，所以我们需要通过 innerHTML 拿到之前编辑的内容，然后设置到更新后创建的新元素中，具体代码如下：</p>
<pre><code data-language="js" class="lang-js"><span class="hljs-comment">// ./main.js</span>
<span class="hljs-keyword">import</span> createEditor <span class="hljs-keyword">from</span> <span class="hljs-string">'./editor'</span>


<p><span class="hljs-keyword">const</span> editor &#x3D; createEditor()<br><span class="hljs-built_in">document</span>.body.appendChild(editor)</p>
<p><span class="hljs-comment">&#x2F;&#x2F; … 原本的业务代码</span></p>
<p><span class="hljs-comment">&#x2F;&#x2F; HMR ——————————–</span><br><span class="hljs-keyword">let</span> lastEditor &#x3D; editor<br><span class="hljs-built_in">module</span>.hot.accept(<span class="hljs-string">‘.&#x2F;editor’</span>, () &#x3D;&gt; &#123;<br>  <span class="hljs-comment">&#x2F;&#x2F; 当 editor.js 更新，自动执行此函数</span><br>  <span class="hljs-comment">&#x2F;&#x2F; 临时记录更新前编辑器内容</span><br>  <span class="hljs-keyword">const</span> value &#x3D; lastEditor.innerHTML<br>  <span class="hljs-comment">&#x2F;&#x2F; 移除更新前的元素</span><br>  <span class="hljs-built_in">document</span>.body.removeChild(lastEditor)<br>  <span class="hljs-comment">&#x2F;&#x2F; 创建新的编辑器</span><br>  <span class="hljs-comment">&#x2F;&#x2F; 此时 createEditor 已经是更新过后的函数了</span><br>  lastEditor &#x3D; createEditor()<br>  <span class="hljs-comment">&#x2F;&#x2F; 还原编辑器内容</span><br>  lastEditor.innerHTML &#x3D; value<br>  <span class="hljs-comment">&#x2F;&#x2F; 追加到页面</span><br>  <span class="hljs-built_in">document</span>.body.appendChild(lastEditor)<br>&#125;)<br></code></pre></p>
<p>这样就可以解决界面状态保存的问题了。</p>
<p>至此，对于 editor 模块的热替换逻辑就算是全部实现了。通过这个过程你应该能够发现，为什么 Webpack 需要我们自己处理 JS 模块的热更新了：因为不同的模块有不同的情况，不同的情况，在这里处理时肯定也是不同的。就好像，我们这里是一个文本编辑器应用，所以需要保留状态，如果不是这种类型那就不需要这样做。所以说 Webpack 没法提供一个通用的 JS 模块替换方案。</p>
<h4>图片模块热替换</h4>
<p>相比于 JavaScript 模块热替换，图片的热替换逻辑就简单多了，这里我们快速来看一下。</p>
<p>我们同样通过 module.hot.accept 注册这个图片模块的热替换处理函数，在这个函数中，我们只需要重新给图片元素的 src 设置更新后的图片路径就可以了。因为图片修改过后图片的文件名会发生变化，而这里我们就可以直接得到更新后的路径，所以重新设置图片的 src 就能实现图片热替换，具体代码如下：</p>
<pre><code data-language="js" class="lang-js"><span class="hljs-comment">// ./src/main.js</span>
<span class="hljs-keyword">import</span> logo <span class="hljs-keyword">from</span> <span class="hljs-string">'./icon.png'</span>
<span class="hljs-comment">// ... 其他代码</span>
<span class="hljs-built_in">module</span>.hot.accept(<span class="hljs-string">'./icon.png'</span>, () =&gt; &#123;
  <span class="hljs-comment">// 当 icon.png 更新后执行</span>
  <span class="hljs-comment">// 重写设置 src 会触发图片元素重新加载，从而局部更新图片</span>
  img.src = logo
&#125;)
</code></pre>
<h4>常见问题</h4>
<p>如果你刚开始使用 Webpack 的 HMR 特性，肯定会遇到一些问题，接下来我分享几个最容易发生的问题。</p>
<p>第一个问题，如果处理热替换的代码（处理函数）中有错误，结果也会导致自动刷新。例如我们这里在处理函数中故意加入一个运行时错误，代码如下：</p>
<pre><code data-language="js" class="lang-js"><span class="hljs-comment">// ./src/main.js</span>
<span class="hljs-comment">// ... 其他代码</span>
<span class="hljs-built_in">module</span>.hot.accept(<span class="hljs-string">'./editor'</span>, () =&gt; &#123;
  <span class="hljs-comment">// 刻意造成运行异常</span>
  <span class="hljs-literal">undefined</span>.foo()
&#125;)
</code></pre>
<p>直接测试你会发现 HMR 不会正常工作，而且根本看不到异常，效果如下图：</p>
<p><img src="https://s0.lgstatic.com/i/image/M00/09/1E/Ciqc1F67ubeAT4knAA-uyhsCyD0801.gif" alt="hmr-error.gif"></p>
<p>这是因为 HMR 过程报错导致 HMR 失败，HMR 失败过后，会自动回退到自动刷新，页面一旦自动刷新，控制台中的错误信息就会被清除，这样的话，如果不是很明显的错误，就很难被发现。</p>
<p>在这种情况下，我们可以使用 hotOnly 的方式来解决，因为现在使用的 hot 方式，如果热替换失败就会自动回退使用自动刷新，而 hotOnly 的情况下并不会使用自动刷新。</p>
<p>我们回到配置文件中，这里我们将 devServer 中的 hot 等于 true 修改为 hotOnly 等于 true，具体代码如下：</p>
<pre><code data-language="js" class="lang-js"><span class="hljs-comment">// ./webpack.config.js</span>
<span class="hljs-keyword">const</span> webpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">'webpack'</span>)


<p><span class="hljs-built_in">module</span>.exports &#x3D; &#123;<br>  <span class="hljs-comment">&#x2F;&#x2F; …</span><br>  <span class="hljs-attr">devServer</span>: &#123;<br>    <span class="hljs-comment">&#x2F;&#x2F; 只使用 HMR，不会 fallback 到 live reloading</span><br>    <span class="hljs-attr">hotOnly</span>: <span class="hljs-literal">true</span><br>  &#125;,<br>  <span class="hljs-attr">plugins</span>: [<br>    <span class="hljs-comment">&#x2F;&#x2F; …</span><br>    <span class="hljs-comment">&#x2F;&#x2F; HMR 特性所需要的插件</span><br>    <span class="hljs-keyword">new</span> webpack.HotModuleReplacementPlugin()<br>  ]<br>&#125;<br></code></pre></p>
<p>配置完成以后，重新启动 webpack-dev-server。此时我们再去修改代码，无论是否处理了这个代码模块的热替换逻辑，浏览器都不会自动刷新了，这样的话，热替换逻辑中的错误信息就可以直接看到了，具体效果如下图：</p>
<p><img src="https://s0.lgstatic.com/i/image/M00/09/1E/Ciqc1F67ucCAB6tmAAw05eRHK1o555.png" alt="image (1).png"></p>
<p>第二个问题，对于使用了 HMR API 的代码，如果我们在没有开启 HMR 功能的情况下运行 Webpack 打包，此时运行环境中就会报出 Cannot read property 'accept' of undefined 的错误，具体错误信息如下：</p>
<p><img src="https://s0.lgstatic.com/i/image/M00/09/1E/Ciqc1F67ucaABUSHAAFH9zDbzcU466.png" alt="image (2).png"></p>
<p>原因是 module.hot 是 HMR 插件提供的成员，没有开启这个插件，自然也就没有这个对象。</p>
<p>解决办法也很简单，与我们在业务代码中判断 API 兼容一样，我们先判断是否存在这个对象，然后再去使用就可以了，具体代码如下：</p>
<pre><code data-language="js" class="lang-js"><span class="hljs-comment">// HMR -----------------------------------</span>
<span class="hljs-keyword">if</span> (<span class="hljs-built_in">module</span>.hot) &#123; <span class="hljs-comment">// 确保有 HMR API 对象</span>
  <span class="hljs-built_in">module</span>.hot.accept(<span class="hljs-string">'./editor'</span>, () =&gt; &#123;
    <span class="hljs-comment">// ...</span>
  &#125;)
&#125;
</code></pre>
<p>除此之外，可能你还有一个问题：我们在代码中写了很多与业务功能本身无关的代码，会不会对生产环境有影响？</p>
<p>那这个问题的答案很简单，我通过一个简单的操作来帮你解答，我们回到配置文件中，确保已经将热替换特性关闭，并且移除掉了 HotModuleReplacementPlugin 插件，然后打开命令行终端，正常运行一下 Webpack 打包，打包过后，我们找到打包生成的 bundle.js 文件，然后找到里面 main.js 对应的模块，具体结果如下图：</p>
<p><img src="https://s0.lgstatic.com/i/image/M00/09/1E/Ciqc1F67uc6ACTacAAGT2VwSBrk938.png" alt="image (3).png"></p>
<p>你会发现之前我们编写的处理热替换的代码都被移除掉了，只剩下一个 if (false) 的空判断，这种没有意义的判断，在压缩过后也会自动去掉，所以根本不会对生产环境有任何影响。</p>
<h3>写在最后</h3>
<p>以上就是我们对 Webpack 模块热替换特性做的一些探索，整体下来可能你会觉得 HMR 比较麻烦，需要写一些额外的代码，甚至觉得不如不用。</p>
<p>我个人的看法是利大于弊，这个道理就像是为什么现在的开发者都愿意写单元测试一样，对于长期开发的项目而言，这点额外的工作不算什么，而且如果你能为自己的代码设计出一些规律，那你也可以实现一个通用替换方案。</p>
<p>那当然，如果你是使用 React 或者 Vue.js 这类的框架开发，那么使用 HMR 功能会更加简单，因为大部分框架都有成熟的 HMR 方案，你只需要使用就可以了。但是如果你是使用纯原生 JavaScript 开发，那 HMR 功能使用起来相对就会麻烦一点。这也正是为什么大部分人都喜欢选择集成式框架的原因。</p>
<p>关于框架的 HMR，因为在大多数情况下是开箱即用的，所以这里不做过多介绍，详细可以参考：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/gaearon/react-hot-loader">React HMR 方案</a>；</li>
<li><a target="_blank" rel="noopener" href="https://vue-loader.vuejs.org/guide/hot-reload.html">Vue.js HMR 方案</a>。</li>
</ul>

<hr>
<h3 id="精选评论"><a href="#精选评论" class="headerlink" title="精选评论"></a>精选评论</h3><h5 id="婷："><a href="#婷：" class="headerlink" title="**婷："></a>**婷：</h5><blockquote>
<p>坚持到第八讲了…加油😎</p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-编辑回复："><a href="#amp-nbsp-amp-nbsp-amp-nbsp-编辑回复：" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 编辑回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 编辑回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; 加油，胜利就在前方！</p>
</blockquote>
<h5 id="伟："><a href="#伟：" class="headerlink" title="*伟："></a>*伟：</h5><blockquote>
<p>最近用原生做开发，hot配置为true一直没效果，都是直接刷新整个页面，为此找了各种资料都没搞好，最后来这里解决了问题，原来原生js开发需要自己写module.hot.accept，老师讲的很仔细，不错</p>
</blockquote>
<h5 id="桢："><a href="#桢：" class="headerlink" title="*桢："></a>*桢：</h5><blockquote>
<p>请问一下，这个HotModuleReplacementPlugin插件引入是必须的吗，我测试的时候去掉，似乎也没什么不一样的地方。</p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-讲师回复："><a href="#amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; 后续新版本的 Webpack，开启 hot 选项，这个插件会自动引入</p>
</blockquote>
<h5 id="生："><a href="#生：" class="headerlink" title="**生："></a>**生：</h5><blockquote>
<p>在React项目，按照这个文档做了遍设置<a target="_blank" rel="noopener" href="https://shubo.io/react-hot-module-replacement/%EF%BC%88%E5%90%8Chttps://github.com/gaearon/react-hot-loader%E7%9A%84%E6%96%87%E6%A1%A3%EF%BC%89%EF%BC%8C%E5%9C%A8%E4%BF%AE%E6%94%B9%E4%BB%A3%E7%A0%81%E5%90%8E%E4%BF%9D%E5%AD%98%EF%BC%8C%E7%84%B6%E5%90%8E%E5%9C%A8%E6%9C%AC%E5%9C%B0%E6%9F%A5%E7%9C%8BChromeDevtools%E9%87%8C%E9%9D%A2%E5%8F%AF%E4%BB%A5%E5%8F%91%E7%8E%B0%E5%A4%9A%E4%BA%86%E4%B8%A4%E4%B8%AA%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%EF%BC%8C%E4%B8%8D%E8%BF%87%E9%A1%B5%E9%9D%A2%E4%B8%AD%E7%9A%84%E5%86%85%E5%AE%B9%E5%8D%B4%E6%B2%A1%E6%9C%89%E6%9B%B4%E6%96%B0%E6%88%90%E6%9C%80%E6%96%B0%E7%9A%84%EF%BC%8C%E8%AF%B7%E9%97%AE%E5%BA%94%E8%AF%A5%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9A1%E3%80%81http://localhost:8080/b2a8fb16bb66cc49eb93.hot-update.json%E8%AF%A5%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E4%B8%BA%EF%BC%9A%7B&quot;h&quot;:&quot;a2a7911039cc417fbe89&quot;,&quot;c&quot;:%7B&quot;app&quot;:true%7D%7D2%E3%80%81http://localhost:8080/app.b2a8fb16bb66cc49eb93.hot-update.js%E8%AF%A5%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E4%B8%BA%EF%BC%9AwebpackHotUpdate">https://shubo.io/react-hot-module-replacement/（同https://github.com/gaearon/react-hot-loader的文档），在修改代码后保存，然后在本地查看ChromeDevtools里面可以发现多了两个网络请求，不过页面中的内容却没有更新成最新的，请问应该如何解决：1、http://localhost:8080/b2a8fb16bb66cc49eb93.hot-update.json该文件内容为：{&quot;h&quot;:&quot;a2a7911039cc417fbe89&quot;,&quot;c&quot;:{&quot;app&quot;:true}}2、http://localhost:8080/app.b2a8fb16bb66cc49eb93.hot-update.js该文件内容为：webpackHotUpdate</a>(“app”, { &#x2F;<strong><em>&#x2F; “.&#x2F;src&#x2F;pages&#x2F;list&#x2F;index.tsx”: &#x2F;</em>!</strong><em><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>!<em>\ !</em></strong> .&#x2F;src&#x2F;pages&#x2F;list&#x2F;index.tsx <em><strong>! *</strong></em></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></em>&#x2F; &#x2F;***&#x2F; (function(module, exports, <strong>webpack_require</strong>) { “use strict”; eval(“xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx”); &#x2F;&#x2F; 此处省略了具体代码内容，这里eval内的内容确实随着代码的修改进行了更新，但是更新的代码却没有渲染到页面上 } )})</p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-1"><a href="#amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-1" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; 先明确一下 React 的版本以及 react-hot-loader 的版本，最新的版本中 React 官方建议使用 Fast Refresh 取代 react-hot-loader</p>
</blockquote>
<h5 id="一："><a href="#一：" class="headerlink" title="*一："></a>*一：</h5><blockquote>
<p>老师您好，文章都是提到当入口文件的导入模块发生变化时，可以使用module.hot.accept去处理热替换，但是当入口文件发生改变是不是还是得重新刷新页面啊？还有就是，当我修改webpack.config.js 配置文件的时候，每次都得重新开启webpack-dev-server才能应用上去，有没有什么办法可以让配置文件实时更新到webpack-dev-server上呢？谢谢老师</p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-2"><a href="#amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-2" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; 第一个问题，入口修改确实需要刷新，所以一般需要单独做一个单独的微内核的入口；<br>第二个问题，单纯使用 webpack-dev-server 很难实现，需要配合其他工具，例如 watch，或者干脆自己一点代码调用 Webpack-dev-middleware</p>
</blockquote>
<h5 id="遥："><a href="#遥：" class="headerlink" title="*遥："></a>*遥：</h5><blockquote>
<p>精彩 精彩</p>
</blockquote>
<h5 id="龙："><a href="#龙：" class="headerlink" title="**龙："></a>**龙：</h5><blockquote>
<p>到了后面确实跟单元测试类似了，幸好框架自带（有点侥幸了）</p>
</blockquote>
<h5 id="啸："><a href="#啸：" class="headerlink" title="*啸："></a>*啸：</h5><blockquote>
<p>坚持看下去</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/11/02/%E5%A6%82%E4%BD%95%E8%AE%A9%E4%BD%A0%E7%9A%84%E6%A8%A1%E5%9D%97%E6%94%AF%E6%8C%81%E7%83%AD%E6%9B%BF%E6%8D%A2%EF%BC%88HMR%EF%BC%89%E6%9C%BA%E5%88%B6%EF%BC%9F/" data-id="claxeera00012v8w197sd1p0j" data-title="如何让你的模块支持热替换（HMR）机制？" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-如何配置-Webpack-SourceMap-的最佳实践？" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/11/02/%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE-Webpack-SourceMap-%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%EF%BC%9F/" class="article-date">
  <time class="dt-published" datetime="2022-11-02T11:39:04.000Z" itemprop="datePublished">2022-11-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/11/02/%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE-Webpack-SourceMap-%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%EF%BC%9F/">如何配置 Webpack SourceMap 的最佳实践？</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>上一讲我们介绍了如何使用 Webpack Dev Server 提高开发效率，今天我们来介绍需要编译的前端项目该如何调试。</p>
<p>通过构建或者编译之类的操作，我们将开发阶段编写的源代码转换为能够在生产环境中运行的代码，这种进步同时也意味着我们实际运行的代码和我们真正编写的代码之间存在很大的差异。</p>
<p>在这种情况下，如果需要调试我们的应用，或是应用运行的过程中出现意料之外的错误，那我们将无从下手。因为无论是调试还是报错，都是基于构建后的代码进行的，我们只能看到错误信息在构建后代码中具体的位置，却很难直接定位到源代码中对应的位置。</p>
<p>所以我们今天来聊聊如何借助工具解决现代化前端应用的调试问题。</p>
<h3>Source Map 简介</h3>
<p>Source Map（源代码地图）就是解决此类问题最好的办法，从它的名字就能够看出它的作用：映射转换后的代码与源代码之间的关系。一段转换后的代码，通过转换过程中生成的 Source Map 文件就可以逆向解析得到对应的源代码。</p>
<p><img src="https://s0.lgstatic.com/i/image/M00/07/31/CgqCHl65BMmAH6A5AAB71vulYEw615.png" alt="image (1).png"></p>
<p>目前很多第三方库在发布的文件中都会同时提供一个 .map 后缀的 Source Map 文件。例如 jQuery。我们可以打开它的 Source Map 文件看一下，如下图所示：</p>
<p><img src="https://s0.lgstatic.com/i/image/M00/07/31/Ciqc1F65BNaAd1HlAAFTcrTVgBg517.png" alt="image (2).png"></p>
<p>这是一个 JSON 格式的文件，为了更容易阅读，我提前对该文件进行了格式化。这个 JSON 里面记录的就是转换后和转换前代码之间的映射关系，主要存在以下几个属性：</p>
<ul>
<li>version 是指定所使用的 Source Map 标准版本；</li>
<li>sources 中记录的是转换前的源文件名称，因为有可能出现多个文件打包转换为一个文件的情况，所以这里是一个数组；</li>
<li>names 是源代码中使用的一些成员名称，我们都知道一般压缩代码时会将我们开发阶段编写的有意义的变量名替换为一些简短的字符，这个属性中记录的就是原始的名称；</li>
<li>mappings 属性，这个属性最为关键，它是一个叫作 base64-VLQ 编码的字符串，里面记录的信息就是转换后代码中的字符与转换前代码中的字符之间的映射关系，具体如下图所示：</li>
</ul>
<p><img src="https://s0.lgstatic.com/i/image/M00/07/31/CgqCHl65BOaAYEH0AAQM_57iYlk560.png" alt="image (3).png"></p>
<p>一般我们会在转换后的代码中通过添加一行注释的方式来去引入 Source Map 文件。不过这个特性只是用于开发调试的，所以最新版本的 jQuery 已经去除了引入 Source Map 的注释，我们需要手动添加回来，这里我们在最后一行添加 //# sourceMappingURL=jquery-3.4.1.min.map，具体效果如下：</p>
<p><img src="https://s0.lgstatic.com/i/image/M00/07/31/Ciqc1F65BPCAed3hAAD-bDL2c1w048.png" alt="image (4).png"></p>
<p>这样我们在 Chrome 浏览器中如果打开了开发人员工具，它就会自动请求这个文件，然后根据这个文件的内容逆向解析出来源代码，以便于调试。同时因为有了映射关系，所以代码中如果出现了错误，也就能自动定位找到源代码中的位置了。</p>
<p>我们回到浏览器中，打开开发人员工具，找到 Source 面板，这里我们就能看到转换前的 jQuery 源代码了，具体效果如下图所示：</p>
<p><img src="https://s0.lgstatic.com/i/image/M00/07/31/CgqCHl65BPqAZ12pAAZAHqAjwBU330.png" alt="image (5).png"></p>
<p>我们还可以添加一个断点，然后刷新页面，进行单步调试，此时调试过程中使用的就是源代码而不是压缩过后的代码，具体效果如下图所示：</p>
<p><img src="https://s0.lgstatic.com/i/image/M00/07/32/CgqCHl65BUqAc5WEAAxIGZoDsgw274.png" alt="image (6).png"></p>
<h3>Webpack 中配置 Source Map</h3>
<p>我们使用 Webpack 打包的过程，同样支持为打包结果生成对应的 Source Map。用法上也很简单，不过它提供了很多不同模式，导致大部分初学者操作起来可能会比较懵。那接下来我们就一起研究一下在 Webpack 中如何开启 Source Map，然后再来了解一下几种不同的 Source Map 模式之间存在哪些差异。</p>
<p>我们回到配置文件中，这里我们要使用的配置属性叫作 devtool。这个属性就是用来配置开发过程中的辅助工具，也就是与 Source Map 相关的一些功能。我们可以先将这个属性设置为 source-map，具体代码如下：</p>
<pre><code data-language="js" class="lang-js"><span class="hljs-comment">// ./webpack.config.js</span>
<span class="hljs-built_in">module</span>.exports = &#123;
  <span class="hljs-attr">devtool</span>: <span class="hljs-string">'source-map'</span> <span class="hljs-comment">// source map 设置</span>
&#125;
</code></pre>
<p>然后打开命令行终端，运行 Webpack 打包。打包完成过后，我们打开 dist 目录，此时这个目录中就会生成我们 bundle.js 的 Source Map 文件，与此同时 bundle.js 中也会通过注释引入这个 Source Map 文件，具体如下图所示：</p>
<p><img src="https://s0.lgstatic.com/i/image/M00/07/32/CgqCHl65BVWAQAhuAAE7vvXo_eo963.png" alt="image (7).png"></p>
<p>我们再回到命令行，通过 <a target="_blank" rel="noopener" href="http://github.com/zeit/serve">serve</a> 工具把打包结果运行起来，然后打开浏览器，再打开开发人员工具，此时我们就可以直接定位到错误所在的位置了。当然如果需要调试，这里也可以直接调试源代码。</p>
<p><img src="https://s0.lgstatic.com/i/image/M00/07/68/CgqCHl65LS6AQ3RLAA8Qi5GdMKM734.gif" alt="source-map.gif"></p>
<p>如果你只是需要使用 Source Map 的话，操作到这里就已经实现了。<strong>但是只会使用这种最普通的 Source Map 模式还远远不够。</strong></p>
<p>为什么这么说呢？</p>
<p>因为现阶段 Webpack 支持的 Source Map 模式有很多种。每种模式下所生成的 Source Map 效果和生成速度都不一样。显然，效果好的一般生成速度会比较慢，而生成速度快的一般就没有什么效果。</p>
<p>那具体哪种 Source Map 模式才是最好呢？这里我们还需要继续去探索。</p>
<p>Webpack 中的 devtool 配置，除了可以使用 source-map 这个值，它还支持很多其他的选项，具体的我们可以参考<a target="_blank" rel="noopener" href="https://webpack.js.org/configuration/devtool/#devtool">文档</a>中的不同模式的对比表。</p>
<p><img src="https://s0.lgstatic.com/i/image/M00/07/35/Ciqc1F65B2aAGTvVAANPGIkqtEY706.png" alt="1.png"></p>
<p>上表分别从初次构建速度、监视模式重新构建速度、是否适合生成环境使用，以及 Source Map 的质量，这四个维度去横向对比了不同的 Source Map 模式之间的差异。</p>
<p>通过表格中四个维度的对比你可能觉得不够清晰，也不太好理解，所以接下来我们会根据表格中的介绍，通过实际操作来体会这些模式之间的差异，从而带你找到适合自己的最佳实践。</p>
<h4>Eval 模式</h4>
<p>首先来看 eval 模式。在去具体了解 Webpack eval 模式的 Source Map 之前，我们需要先了解一下 JavaScript 中 eval 的一些特点。</p>
<p>eval 其实指的是 JavaScript 中的一个函数，可以用来运行字符串中的 JavaScript 代码。例如下面这段代码，字符串中的 console.log("foo~") 就会作为一段 JavaScript 代码被执行：</p>
<pre><code data-language="java" class="lang-java"><span class="hljs-keyword">const</span> code = <span class="hljs-string">'console.log("foo~")'</span>
eval(code) <span class="hljs-comment">// 将 code 中的字符串作为 JS 代码执行</span>
</code></pre>
<p>在默认情况下，这段代码运行在一个临时的虚拟机环境中，我们在控制台中就能够看到：</p>
<p><img src="https://s0.lgstatic.com/i/image/M00/07/32/Ciqc1F65BY2AH0CCAAFYgxojzco362.png" alt="image (8).png"></p>
<p>其实我们可以通过 sourceURL 来声明这段代码所属文件路径，接下来我们再来尝试在执行的 JavaScript 字符串中添加一个 sourceURL 的声明，具体操作如下：</p>
<p><img src="https://s0.lgstatic.com/i/image/M00/07/32/CgqCHl65BZSACFl5AAGGHw1vkY0791.png" alt="image (9).png"></p>
<p>具体就是在 eval 函数执行的字符串代码中添加一个注释，注释的格式：# sourceURL=./path/to/file.js，这样的话这段代码就会执行在指定路径下。</p>
<p>在了解了 eval 函数可以通过 sourceURL 指定代码所属文件路径这个特点过后，我们再来尝试使用这个叫作 eval 模式的 Source Map。</p>
<p>我们回到 Webpack 的配置文件中，将 devtool 属性设置为 eval，具体如下：</p>
<pre><code data-language="java" class="lang-java"><span class="hljs-comment">// ./webpack.config.js</span>
<span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = &#123;
  devtool: <span class="hljs-string">'eval'</span>
&#125;
</code></pre>
<p>然后我们回到命令行终端再次运行打包，打包过后，找到生成的 bundle.js 文件，你会发现每个模块中的代码都被包裹到了一个 eval 函数中，而且每段模块代码的最后都会通过 sourceURL 的方式声明这个模块对应的源文件路径，具体如下：</p>
<p><img src="https://s0.lgstatic.com/i/image/M00/07/32/Ciqc1F65BaCAaChSAALB1bStzyo434.png" alt="image (10).png"></p>
<p>那此时如果我们回到浏览器运行这里的 bundle.js，一旦出现错误，浏览器的控制台就可以定位到具体是哪个模块中的代码，具体效果如下：</p>
<p><img src="https://s0.lgstatic.com/i/image/M00/07/33/CgqCHl65BauAc85YAAFTP1qAxo4213.png" alt="image (11).png"></p>
<p>但是当你点击控制台中的文件名打开这个文件后，看到的却是打包后的模块代码，而并非我们真正的源代码，具体如下：</p>
<p><img src="https://s0.lgstatic.com/i/image/M00/07/33/Ciqc1F65BdaAAGc0AAHURbLxs24154.png" alt="image (12).png"></p>
<p>综上所述，在 eval 模式下，Webpack 会将每个模块转换后的代码都放到 eval 函数中执行，并且通过 sourceURL 声明对应的文件路径，这样浏览器就能知道某一行代码到底是在源代码的哪个文件中。</p>
<p>因为在 eval 模式下并不会生成 Source Map 文件，所以它的构建速度最快，但是缺点同样明显：它只能定位源代码的文件路径，无法知道具体的行列信息。</p>
<h4>案例准备工作</h4>
<p>为了可以更好地对比不同模式的 Source Map 之间的差异，这里我们使用一个新项目，同时创建出不同模式下的打包结果，通过具体实验来横向对比它们之间的差异。</p>
<p>在这个案例中，项目中只有两个 JS 模块，在 main.js 中，我故意加入了一个运行时错误，具体项目结构和部分代码如下：</p>
<pre><code data-language="java" class="lang-java">└─ <span class="hljs-number">07</span>-devtool-diff
   ├── src
   │   ├── heading.js
   │   └── main.js
   ├── <span class="hljs-keyword">package</span>.json
   └── webpack.config.js
</code></pre>
<pre><code data-language="java" class="lang-java"><span class="hljs-comment">// ./src/main.js</span>
<span class="hljs-keyword">import</span> createHeading from <span class="hljs-string">'./heading.js'</span>
<span class="hljs-keyword">const</span> heading = createHeading()
document.body.append(heading)
console.log(<span class="hljs-string">'main.js running'</span>)
<span class="hljs-comment">// 运行时错误</span>
console.log111(<span class="hljs-string">'main.js running'</span>)
</code></pre>
<p>然后我们打开 Webpack 的配置文件，在这个文件中定义一个数组，数组中每一个成员都是 devtool 配置取值的一种，具体代码如下：</p>
<pre><code data-language="java" class="lang-java"><span class="hljs-keyword">const</span> allDevtoolModes = [
  <span class="hljs-string">'eval'</span>,
  <span class="hljs-string">'cheap-eval-source-map'</span>,
  <span class="hljs-string">'cheap-module-eval-source-map'</span>,
  <span class="hljs-string">'eval-source-map'</span>,
  <span class="hljs-string">'cheap-source-map'</span>,
  <span class="hljs-string">'cheap-module-source-map'</span>,
  <span class="hljs-string">'inline-cheap-source-map'</span>,
  <span class="hljs-string">'inline-cheap-module-source-map'</span>,
  <span class="hljs-string">'source-map'</span>,
  <span class="hljs-string">'inline-source-map'</span>,
  <span class="hljs-string">'hidden-source-map'</span>,
  <span class="hljs-string">'nosources-source-map'</span>
]
</code></pre>
<p>在上一课时中我们也提到过，Webpack 的配置文件除了可以导出一个配置对象，还可以导出一个数组，数组中每一个元素就是一个单独的打包配置，那这样就可以在一次打包过程中同时执行多个打包任务。</p>
<p>例如，我们这里导出一个数组，然后在这个数组中添加两个打包配置，它们的 entry 都是 src 中的 main.js，不过它们输出的文件名不同，具体代码如下：</p>
<pre><code data-language="java" class="lang-java"><span class="hljs-comment">// ./webpack.config.js</span>
<span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = [
  &#123;
    entry: <span class="hljs-string">'./src/main.js'</span>,
    output: &#123;
      filename: <span class="hljs-string">'output1.js'</span>
    &#125;
  &#125;,
  &#123;
    entry: <span class="hljs-string">'./src/main.js'</span>,
    output: &#123;
      filename: <span class="hljs-string">'output2.js'</span>
    &#125;
  &#125;
]
</code></pre>
<p>这么配置的话，再次打包就会有两个打包子任务工作，我们的 dist 中生成的结果也就是两个文件，具体结果如下：</p>
<p><img src="https://s0.lgstatic.com/i/image/M00/07/33/CgqCHl65BfWAYAaeAAFSJ5cYfbo850.png" alt="image (13).png"></p>
<p>了解了 Webpack 这种配置用法过后，我们再次回到配置文件中，遍历刚刚定义的数组，为每一个模式单独创建一个打包配置，这样就可以一次性生成所有模式下的不同结果，这比我们一个一个去试验的效率更高，而且对比起来也更明显。</p>
<p>具体配置代码如下：</p>
<pre><code data-language="js" class="lang-js"><span class="hljs-comment">// ./webpack.config.js</span>
<span class="hljs-keyword">const</span> HtmlWebpackPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">'html-webpack-plugin'</span>)


<p><span class="hljs-keyword">const</span> allModes &#x3D; [<br>  <span class="hljs-string">‘eval’</span>,<br>  <span class="hljs-string">‘cheap-eval-source-map’</span>,<br>  <span class="hljs-string">‘cheap-module-eval-source-map’</span>,<br>  <span class="hljs-string">‘eval-source-map’</span>,<br>  <span class="hljs-string">‘cheap-source-map’</span>,<br>  <span class="hljs-string">‘cheap-module-source-map’</span>,<br>  <span class="hljs-string">‘inline-cheap-source-map’</span>,<br>  <span class="hljs-string">‘inline-cheap-module-source-map’</span>,<br>  <span class="hljs-string">‘source-map’</span>,<br>  <span class="hljs-string">‘inline-source-map’</span>,<br>  <span class="hljs-string">‘hidden-source-map’</span>,<br>  <span class="hljs-string">‘nosources-source-map’</span><br>]</p>
<p><span class="hljs-built_in">module</span>.exports &#x3D; allModes.map(<span class="hljs-function"><span class="hljs-params">item</span> &#x3D;&gt;</span> (&#123;<br>  <span class="hljs-attr">devtool</span>: item,<br>  <span class="hljs-attr">mode</span>: <span class="hljs-string">‘none’</span>,<br>  <span class="hljs-attr">entry</span>: <span class="hljs-string">‘.&#x2F;src&#x2F;main.js’</span>,<br>  <span class="hljs-attr">output</span>: &#123;<br>    <span class="hljs-attr">filename</span>: <span class="hljs-string"><code>js/&lt;span class=&quot;hljs-subst&quot;&gt;$&#123;item&#125;&lt;/span&gt;.js</code></span><br>  },<br>  <span class="hljs-attr">module</span>: {<br>    <span class="hljs-attr">rules</span>: [<br>      {<br>        <span class="hljs-attr">test</span>: <span class="hljs-regexp">&#x2F;.js$&#x2F;</span>,<br>        <span class="hljs-attr">use</span>: {<br>          <span class="hljs-attr">loader</span>: <span class="hljs-string">‘babel-loader’</span>,<br>          <span class="hljs-attr">options</span>: {<br>            <span class="hljs-attr">presets</span>: [<span class="hljs-string">‘@babel&#x2F;preset-env’</span>]<br>          }<br>        }<br>      }<br>    ]<br>  },<br>  <span class="hljs-attr">plugins</span>: [<br>    <span class="hljs-keyword">new</span> HtmlWebpackPlugin({<br>      <span class="hljs-attr">filename</span>: <span class="hljs-string"><code>&lt;span class=&quot;hljs-subst&quot;&gt;$&#123;item&#125;&lt;/span&gt;.html</code></span><br>    })<br>  ]<br>}))<br></code></pre></p>
<p>这里简单解释一下这个配置中的部分配置用意：</p>
<ol>
<li>定义 devtool 属性，它就是当前所遍历的模式名称；</li>
<li>将 mode 设置为 none，确保 Webpack 内部不做额外处理；</li>
<li>设置打包入口和输出文件名称，打包入口都是 src/main.js，输出文件名称我们就放在 js 目录中，以模式名称命名，至于为什么放在单独目录中，你可以在接下来的内容中找到答案；</li>
<li>为 js 文件配置一个 babel-loader，配置 babel-loader 的目的是稍后能够辨别其中一类模式的差异。</li>
<li>配置一个 html-webpack-plugin，也就是为每个打包任务生成一个 HTML 文件，通过前面的内容，我们知道 html-webpack-plugin 可以生成使用打包结果的 HTML，接下来我们就是通过这些 HTML 在浏览器中进行尝试。</li>
</ol>
<p>配置完成以后，我们再次回到命令行终端运行打包，那此时这个打包过程就自动生成了不同模式下的打包结果，具体结果如下图所示：</p>
<p><img src="https://s0.lgstatic.com/i/image/M00/07/33/CgqCHl65BgCAbZVrAAUumD0yd4g992.png" alt="image (14).png"></p>
<p>然后我们通过 serve 把结果运行起来，打开浏览器，此时我们能够在页面中看到每一个使用不同模式 Source Map 的 HTML 文件，具体如下图：</p>
<p><img src="https://s0.lgstatic.com/i/image/M00/07/33/CgqCHl65BgiAU1D1AAExFMFyQcc456.png" alt="image (15).png"></p>
<p>那如果刚刚没有把 JS 文件输出到单独目录中，这里的文件就会非常多，导致 HTML 文件寻找起来特别麻烦。</p>
<h4>不同模式的对比</h4>
<p>有了不同模式下生成的结果过后，我们就可以仔细去对比不同 Source Map 模式之间的具体差异了。其实也没必要真的一个一个去看，这里我先带你看几个比较典型的模式，然后找出它们的规律，这样你就再也不用头大了。</p>
<p>首先 eval 模式，这个模式刚刚已经单独看过了，它就是将模块代码放到 eval 函数中执行，并且通过 sourceURL 标注所属文件路径，在这种模式下没有 Source Map 文件，所以只能定位是哪个文件出错，具体效果如下图：</p>
<p><img src="https://s0.lgstatic.com/i/image/M00/07/33/CgqCHl65BhCABeebAAFnubG2mPA332.png" alt="image (16).png"></p>
<p>然后我们再来看一个叫作 eval-source-map 的模式，这个模式也是使用 eval 函数执行模块代码，不过这里有所不同的是，eval-source-map 模式除了定位文件，还可以定位具体的行列信息。相比于 eval 模式，它能够生成 Source Map 文件，可以反推出源代码，具体效果如下：</p>
<p><img src="https://s0.lgstatic.com/i/image/M00/07/68/Ciqc1F65LV2ABnPSAAOQByCZ1X8805.gif" alt="eval-source-map.gif"></p>
<p>紧接着我们再来看一个叫作 cheap-eval-source-map 的模式。根据这个模式的名字就能推断出一些信息，它就是在 eval-source-map 基础上添加了一个 cheap，也就是便宜的，或者叫廉价的。用计算机行业的常用说法，就是阉割版的 eval-source-map，因为它虽然也生成了 Source Map 文件，但是这种模式下的 Source Map 只能定位到行，而定位不到列，所以在效果上差了一点点，但是构建速度会提升很多，具体效果如下图：</p>
<p><img src="https://s0.lgstatic.com/i/image/M00/07/68/CgqCHl65LXKAL1X9AAQvU6NQre0545.gif" alt="cheap-eval-source-map.gif"></p>
<p>接下来再看一个叫作 cheap-module-eval-source-map 的模式。慢慢地我们就发现 Webpack 中这些模式的名字不是随意的，好像都有某种规律。这里就是在 cheap-eval-source-map 的基础上多了一个 module，具体效果如下图：</p>
<p><img src="https://s0.lgstatic.com/i/image/M00/07/68/Ciqc1F65LYKAb35fAAWpO16gIpE536.gif" alt="cheap-module-eval-source-map.gif"></p>
<p>这种模式同样也只能定位到行，它的特点相比于 cheap-eval-source-map 并不明显 ，如果你没有发现差异，可以再去看看上一种模式，仔细做一个对比，相信对比之后你会发现，cheap-module-eval-source-map 中定位的源代码与我们编写的源代码是一模一样的，而 cheap-eval-source-map 模式中定位的源代码是经过 ES6 转换后的结果，具体对比如下（左图是 cheap-eval-source-map）：</p>
<p><img src="https://s0.lgstatic.com/i/image/M00/07/33/Ciqc1F65BjSAE-KLAAFGXAIp67I615.png" alt="image (17).png"></p>
<p>这也是为什么之前我要给 JS 文件配置 Loader 的原因：因为这种名字中带有 module 的模式，解析出来的源代码是没有经过 Loader 加工的，<strong>而名字中不带 module 的模式，解析出来的源代码是经过 Loader 加工后的结果</strong>。也就是说如果我们想要还原一模一样的源代码，就需要选择 cheap-module-eval-source-map 模式。</p>
<p>了解了这些过后，你基本上就算通盘了解了 <strong>Webpack 中所有 Source Map 模式之间的差异</strong>，因为其它的模式无外乎就是这几个特点的排列组合罢了。</p>
<p>例如，我们再来看一个 cheap-source-map 模式，这个模式的名字中没有 eval，意味着它没用 eval 执行代码，而名字中没有 module，意味着 Source Map 反推出来的是 Loader 处理后的代码，有 cheap 表示只能定位源代码的行号。</p>
<p>那以上就是我们在日常开发过程中经常用到的几种 Source Map 模式，你在尝试的时候一定要注意：找规律很重要。</p>
<p>除此之外，还有几个特殊一点的模式，我们单独介绍一下：</p>
<ul>
<li>inline-source-map 模式</li>
</ul>
<p>它跟普通的 source-map 效果相同，只不过这种模式下 Source Map 文件不是以物理文件存在，而是以 data URLs 的方式出现在代码中。我们前面遇到的 eval-source-map 也是这种 inline 的方式。</p>
<ul>
<li>hidden-source-map 模式</li>
</ul>
<p>在这个模式下，我们在开发工具中看不到 Source Map 的效果，但是它也确实生成了 Source Map 文件，这就跟 jQuery 一样，虽然生成了 Source Map 文件，但是代码中并没有引用对应的 Source Map 文件，开发者可以自己选择使用。</p>
<ul>
<li>nosources-source-map 模式：</li>
</ul>
<p>在这个模式下，我们能看到错误出现的位置（包含行列位置），但是点进去却看不到源代码。这是为了保护源代码在生产环境中不暴露。</p>
<h3>写在最后</h3>
<p>虽然 Webpack 中支持各种各样的 Source Map 模式，但一般应用开发时我们只会用到其中的几种。其实在我们掌握了它们的特点过后，选择上就没有什么需要纠结的地方了。</p>
<p>这里再分享一下我个人开发时的选择，供你参考。</p>
<p>首先开发过程中（开发环境），我会选择 cheap-module-eval-source-map，原因有以下三点：</p>
<ul>
<li>我使用框架的情况会比较多，以 React 和 Vue.js 为例，无论是 JSX 还是 vue 单文件组件，Loader 转换后差别都很大，我需要调试 Loader 转换前的源代码。</li>
<li>一般情况下，我编写的代码每行不会超过 80 个字符，对我而言能够定位到行到位置就够了，而且省略列信息还可以提升构建速度。</li>
<li>虽然在这种模式下启动打包会比较慢，但大多数时间内我使用的 webpack-dev-server 都是在监视模式下重新打包，它重新打包的速度非常快。</li>
</ul>
<p>综上所述，开发环境下我会选择 cheap-module-eval-source-map。</p>
<p>至于发布前的打包，也就是生产环境的打包，我选择 none，它不会生成 Source Map。原因很简单：</p>
<ul>
<li>首先，Source Map 会暴露我的源代码到生产环境。如果没有控制 Source Map 文件访问权限的话，但凡是有点技术的人都可以很容易的复原项目中涉及的绝大多数源代码，这非常不合理也不安全，我想很多人可能都忽略了这个问题。</li>
<li>其次，调试应该是开发阶段的事情，你应该在开发阶段就尽可能找到所有问题和隐患，而不是到了生产环境中再去全民公测。如果你对自己的代码实在没有信心，我建议你选择 nosources-source-map 模式，这样出现错误可以定位到源码位置，也不至于暴露源码。</li>
</ul>
<p>当然这些选择不是绝对的，我们理解这些模式之间的差异的目的，就是为了可以在不同环境中快速选择一个合适的模式，而不是寻求一个通用法则，开发行业也根本不会有绝对的通用法则！</p>
<p>除此之外，我还要强调一点，Source Map 并不是 Webpack 特有的功能，它们两者的关系只是：Webpack 支持 Source Map。大多数的构建或者编译工具也都支持 Source Map。希望你不要把它们二者捆绑到一起，混为一谈。</p>

<hr>
<h3 id="精选评论"><a href="#精选评论" class="headerlink" title="精选评论"></a>精选评论</h3><h5 id="浩："><a href="#浩：" class="headerlink" title="*浩："></a>*浩：</h5><blockquote>
<p>立flag的小伙子哪里去了？</p>
</blockquote>
<h5 id="俊："><a href="#俊：" class="headerlink" title="**俊："></a>**俊：</h5><blockquote>
<p>cheap-module-eval-source-map： eval不生成source-map 文件， module保留源代码不经过 babel 转换, cheap 显示行信息</p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-讲师回复："><a href="#amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; 总结的还不错，不过 eval 不是不生成 source-map 文件，只是使用 eval 执行代码</p>
</blockquote>
<h5 id="文："><a href="#文：" class="headerlink" title="**文："></a>**文：</h5><blockquote>
<p>讲的很棒，受益匪浅</p>
</blockquote>
<h5 id="Sept："><a href="#Sept：" class="headerlink" title="Sept："></a>Sept：</h5><blockquote>
<p>官网没有cheap-module-eval-source-map，有eval-cheap-module-source-map，是后来改了吗，还是文中写错了？</p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-1"><a href="#amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-1" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; 官方考虑之前的选项比较乱，现在开始慢慢规整了，不过仍然还可以这么使用，没有区别，建议遵循最新的官方文档使用，避免后期调整</p>
</blockquote>
<h5 id="用户0571："><a href="#用户0571：" class="headerlink" title="**用户0571："></a>**用户0571：</h5><blockquote>
<p>而是以 data URLs 的方式出现在代码中。。 请问老师data URLs 是啥意思？存在于内存中？</p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-2"><a href="#amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-2" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; data URLs 的数据就在 URL 字符串内哇，并不会涉及到请求</p>
</blockquote>
<h5 id="威："><a href="#威：" class="headerlink" title="**威："></a>**威：</h5><blockquote>
<p>在vue-cli3中，开发环境下如何配置sourceMap调试组件？</p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-3"><a href="#amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-3" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; vue-cli 内部开发模式下默认开启了 source map，不需要手动开启；如果需要特殊配制可以在 vue.config.js 中配制</p>
</blockquote>
<h5 id="遥："><a href="#遥：" class="headerlink" title="*遥："></a>*遥：</h5><blockquote>
<p>赞赞赞</p>
</blockquote>
<h5 id="硕："><a href="#硕：" class="headerlink" title="*硕："></a>*硕：</h5><blockquote>
<p>获益匪浅</p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-编辑回复："><a href="#amp-nbsp-amp-nbsp-amp-nbsp-编辑回复：" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 编辑回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 编辑回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; 加油哦</p>
</blockquote>
<h5 id="鑫："><a href="#鑫：" class="headerlink" title="**鑫："></a>**鑫：</h5><blockquote>
<p>老师你好，我想请问下，如果要上报错误堆栈，那么是不是应该采用hidden source map</p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-4"><a href="#amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-4" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; 一般就是 hidden-sourcemap 配合 sentry</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/11/02/%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE-Webpack-SourceMap-%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%EF%BC%9F/" data-id="claxeera30016v8w13fpceibh" data-title="如何配置 Webpack SourceMap 的最佳实践？" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-如何使用-Dev-Server-提高你的本地开发效率？" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/11/02/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-Dev-Server-%E6%8F%90%E9%AB%98%E4%BD%A0%E7%9A%84%E6%9C%AC%E5%9C%B0%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%EF%BC%9F/" class="article-date">
  <time class="dt-published" datetime="2022-11-02T11:38:21.000Z" itemprop="datePublished">2022-11-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/11/02/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-Dev-Server-%E6%8F%90%E9%AB%98%E4%BD%A0%E7%9A%84%E6%9C%AC%E5%9C%B0%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%EF%BC%9F/">如何使用 Dev Server 提高你的本地开发效率？</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>你好，我是汪磊，通过前面几个课时的学习，相信你已经了解了 Webpack 的相关概念、基本用法，以及核心工作原理，看似好像已经掌握了 Webpack，但是如果以目前的认知状态去应对日常的开发工作，其实还远远不够。</p>
<p>因为“编写源代码 → Webpack 打包 → 运行应用 → 浏览器查看”这种周而复始的开发方式过于原始，在实际开发过程中，如果你还是按照这种方式来工作，开发效率必然会十分低下。</p>
<p>那究竟该如何提高我们的开发效率呢？</p>
<p>这里我先对一个较为理想的开发环境做出设想：</p>
<ul>
<li>首先，它必须能够使用 HTTP 服务运行而不是文件形式预览。这样的话，一来更接近生产环境状态，二来我们的项目可能需要使用 AJAX 之类的 API，以文件形式访问会产生诸多问题。</li>
<li>其次，在我们修改完代码过后，Webpack 能够自动完成构建，然后浏览器可以即时显示最新的运行结果，这样就大大减少了开发过程中额外的重复操作，同时也会让我们更加专注，效率自然得到提升。</li>
<li>最后，它还需要能提供 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Tools/Debugger/How_to/Use_a_source_map">Source Map</a> 支持。这样一来，运行过程中出现的错误就可以快速定位到源代码中的位置，而不是打包后结果中的位置，更便于我们快速定位错误、调试应用。</li>
</ul>
<p>对于以上的这些需求 Webpack 都已经提供了相对应的功能，其中部分功能需要用到一些周边的工具，具体效果如下：</p>
<p><img src="https://s0.lgstatic.com/i/image/M00/03/60/CgqCHl6ykgmAQxFBAPPMpiFtDhw170.gif" alt="理想的环境.gif"></p>
<p>所以，今天我们的主题就是：学习如何增强使用 Webpack 的开发体验。</p>
<h3>Webpack 自动编译</h3>
<p>正如前面所讲，如果我们每次修改完代码，都是通过命令行手动重复运行 Webpack 命令，从而得到最新的打包结果，那么这样的操作过程根本没有任何开发体验可言。</p>
<p>针对上述这个问题，我们可以使用 Webpack CLI 提供的另外一种 watch 工作模式来解决。</p>
<p>如果你之前了解过其它的一些构建工具，你应该对 watch 模式并不陌生。在这种模式下，Webpack 完成初次构建过后，项目中的源文件会被监视，一旦发生任何改动，Webpack 都会自动重新运行打包任务。</p>
<p>具体的用法也非常简单，就是在启动 Webpack 时，添加一个 --watch 的 CLI 参数，这样的话，Webpack 就会以监视模式启动运行。在打包完成过后，CLI 不会立即退出，它会等待文件变化再次工作，直到我们手动结束它或是出现不可控的异常。</p>
<p>在 watch 模式下我们就只需专注编码，不必再去手动完成编译工作了，相比于原始手动操作的方式，有了很明显的进步。</p>
<p>我们还可以再开启另外一个命令行终端，同时以 HTTP 形式运行我们的应用，然后打开浏览器去预览应用。</p>
<p>我们可以将浏览器移至屏幕的左侧，然后将编辑器移至右侧，此时我们尝试修改源代码，保存过后，以 watch 模式工作的 Webpack 就会自动重新打包，然后我们就可以在浏览器中刷新页面查看最新的结果，具体效果如下图所示：</p>
<p><img src="https://s0.lgstatic.com/i/image/M00/03/18/Ciqc1F6yYKmAQNcsAAgeCW_ItQU095.png" alt="image.png"></p>
<p>那此时我们的开发体验就是：修改代码 → Webpack 自动打包 → 手动刷新浏览器 → 预览运行结果。</p>
<p>P.S. 这里我使用的静态文件服务器是一个 npm 模块，叫作 <a target="_blank" rel="noopener" href="https://github.com/zeit/serve">serve</a>。</p>
<p>此时距离我们的目标状态还差一点，如果浏览器能够在 Webpack 打包过后自动刷新，那我们的开发体验将会更好一些。</p>
<p>如果你已经了解过一个叫作 <a target="_blank" rel="noopener" href="https://www.browsersync.io">BrowserSync</a> 的工具，你应该知道 BrowserSync 就可以帮我们实现文件变化过后浏览器自动刷新的功能。</p>
<p>所以，我们就可以使用 BrowserSync 工具替换 serve 工具，启动 HTTP 服务，这里还需要同时监听 dist 目录下文件的变化，具体命令如下：</p>
<pre><code># 可以先通过 npm 全局安装 browser-sync 模块，然后再使用这个模块
$ npm install browser-sync --global
$ browser-sync dist --watch


<h1 id="或者也可以使用-npx-直接使用远端模块"><a href="#或者也可以使用-npx-直接使用远端模块" class="headerlink" title="或者也可以使用 npx 直接使用远端模块"></a>或者也可以使用 npx 直接使用远端模块</h1><p>$ npx browser-sync dist –watch<br></code></pre></p>
<p>启动过后，我们回到编辑器，然后尝试修改源文件，保存完成以后浏览器就会自动刷新，显示最新结果。</p>
<p>它的原理就是 Webpack 监视源代码变化，自动打包源代码到 dist 中，而 dist 中文件的变化又被 BrowserSync 监听了，从而实现自动编译并且自动刷新浏览器的功能，整个过程由两个工具分别监视不同的内容。</p>
<p>这种 watch 模式 + BrowserSync 虽然也实现了我们的需求，但是这种方法有很多弊端：</p>
<ul>
<li>操作烦琐，我们需要同时使用两个工具，那么需要了解的内容就会更多，学习成本大大提高；</li>
<li>效率低下，因为整个过程中， Webpack 会将文件写入磁盘，BrowserSync 再进行读取。过程中涉及大量磁盘读写操作，必然会导致效率低下。</li>
</ul>
<p>所以这只能算是“曲线救国”，并不完美，我们仍然需要继续改善。</p>
<h3>Webpack Dev Server</h3>
<p><a target="_blank" rel="noopener" href="https://github.com/webpack/webpack-dev-server">webpack-dev-server</a> 是 Webpack 官方推出的一款开发工具，根据它的名字我们就应该知道，它提供了一个开发服务器，并且将自动编译和自动刷新浏览器等一系列对开发友好的功能全部集成在了一起。</p>
<p>Webpack 官方推出 webpack-dev-server 这款工具的初衷，就是为了提高开发者日常的开发效率，使用这个工具就可以解决我在开头所提出的问题。而且它是一个高度集成的工具，使用起来十分的方便。</p>
<p>webpack-dev-server 同样也是一个独立的 npm 模块，所以我们需要通过 npm 将 webpack-dev-server 作为项目的开发依赖安装。安装完成过后，这个模块为我们提供了一个叫作 webpack-dev-server 的 CLI 程序，我们同样可以直接通过 npx 直接去运行这个 CLI，或者把它定义到 npm scripts 中，具体操作如下：</p>
<pre><code># 安装 webpack-dev-server
$ npm install webpack-dev-server --save-dev
# 运行 webpack-dev-server
$ npx webpack-dev-server
</code></pre>
<p>运行 webpack-dev-server 这个命令时，它内部会启动一个 HTTP Server，为打包的结果提供静态文件服务，并且自动使用 Webpack 打包我们的应用，然后监听源代码的变化，一旦文件发生变化，它会立即重新打包，大致流程如下：</p>
<p><img src="https://s0.lgstatic.com/i/image/M00/03/61/CgqCHl6ykrKAKqeOAABe6Avstu0065.png" alt="4.png"></p>
<p>不过这里需要注意的是，webpack-dev-server 为了提高工作速率，它并没有将打包结果写入到磁盘中，而是暂时存放在内存中，内部的 HTTP Server 也是从内存中读取这些文件的。这样一来，就会减少很多不必要的磁盘读写操作，大大提高了整体的构建效率。</p>
<p><img src="https://s0.lgstatic.com/i/image/M00/03/61/CgqCHl6ykr2ATByyAAA43IcwZBo618.png" alt="3.png"></p>
<p>我们还可以为 webpack-dev-server 命令传入一个 --open 的参数，用于自动唤起浏览器打开我们的应用。打开浏览器过后，此时如果你有两块屏幕，就可以把浏览器放到另外一块屏幕上，然后体验一边编码，一边即时预览的开发环境了。</p>
<h4>配置选项</h4>
<p>Webpack 配置对象中可以有一个叫作 devServer 的属性，专门用来为 webpack-dev-server 提供配置，具体如下：</p>
<pre><code data-language="js" class="lang-js"><span class="hljs-comment">// ./webpack.config.js</span>
<span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>)


<p><span class="hljs-built_in">module</span>.exports &#x3D; &#123;<br>  <span class="hljs-comment">&#x2F;&#x2F; …</span><br>  <span class="hljs-attr">devServer</span>: &#123;<br>    <span class="hljs-attr">contentBase</span>: path.join(__dirname, <span class="hljs-string">‘dist’</span>),<br>    <span class="hljs-attr">compress</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">port</span>: <span class="hljs-number">9000</span><br>    <span class="hljs-comment">&#x2F;&#x2F; …</span><br>    <span class="hljs-comment">&#x2F;&#x2F; 详细配置文档：<a target="_blank" rel="noopener" href="https://webpack.js.org/configuration/dev-server/">https://webpack.js.org/configuration/dev-server/</a></span><br>  &#125;<br>&#125;<br></code></pre></p>
<p>具体有哪些配置我们就不在这里一一介绍了，你可以在它的<a target="_blank" rel="noopener" href="https://webpack.js.org/configuration/dev-server/">官网</a>中找到相对应的说明文档。</p>
<p>接下来我们来看几个 webpack-dev-server 的常用功能。</p>
<h4>静态资源访问</h4>
<p>webpack-dev-server 默认会将构建结果和输出文件全部作为开发服务器的资源文件，也就是说，只要通过 Webpack 打包能够输出的文件都可以直接被访问到。但是如果你还有一些没有参与打包的静态文件也需要作为开发服务器的资源被访问，那你就需要额外通过配置“告诉” webpack-dev-server。</p>
<p>具体的方法就是在 webpack-dev-server 的配置对象中添加一个对应的配置。我们回到配置文件中，找到 devServer 属性，它的类型是一个对象，我们可以通过这个 devServer 对象的 contentBase 属性指定额外的静态资源路径。这个 contentBase 属性可以是一个字符串或者数组，也就是说你可以配置一个或者多个路径。具体配置如下：</p>
<pre><code data-language="js" class="lang-js"><span class="hljs-comment">// ./webpack.config.js</span>
<span class="hljs-built_in">module</span>.exports = &#123;
  <span class="hljs-comment">// ...</span>
  <span class="hljs-attr">devServer</span>: &#123;
    <span class="hljs-attr">contentBase</span>: <span class="hljs-string">'public'</span>
  &#125;
&#125;
</code></pre>
<p>我们这里将这个路径设置为项目中的 public 目录。可能有人会有疑问，之前我们在使用插件的时候已经将这个目录通过 copy-webpack-plugin 输出到了输出目录，按照刚刚的说法，所有输出的文件都可以直接被 serve，也就是能直接访问到，按道理应该不需要再作为开发服务器的静态资源路径了。</p>
<p>确实是这样的，而且如果你能想到这一点，也就证明你真正理解了webpack-dev-server 的文件加载规则。</p>
<p>但是在实际使用 Webpack 时，我们一般都会把 copy-webpack-plugin 这种插件留在上线前的那一次打包中使用，而开发过程中一般不会用它。因为在开发过程中，我们会频繁重复执行打包任务，假设这个目录下需要拷贝的文件比较多，如果每次都需要执行这个插件，那打包过程开销就会比较大，每次构建的速度也就自然会降低。</p>
<p>至于如何实现某些插件只在生产模式打包时使用，是额外的话题，所以具体的操作方式会在 10 课时中详细介绍。这里我们先移除 CopyWebpackPlugin，确保这里的打包不会输出 public 目录中的静态资源文件，然后回到命令行再次执行 webpack-dev-server。</p>
<p>启动过后，我们打开浏览器，这里我们访问的页面文件和 bundle.js 文件均来自于打包结果。我们再尝试访问 favicon.ico，因为这个文件已经没有参与打包了，所以这个文件必然来源于 contentBase 中配置的目录了。</p>
<p><img src="https://s0.lgstatic.com/i/image/M00/03/19/Ciqc1F6yYX2ANKWcAAPBaG2a7VI047.png" alt="image (3).png"></p>
<h4>Proxy 代理</h4>
<p>由于 webpack-dev-server 是一个本地开发服务器，所以我们的应用在开发阶段是独立运行在 localhost 的一个端口上，而后端服务又是运行在另外一个地址上。但是最终上线过后，我们的应用一般又会和后端服务部署到同源地址下。</p>
<p>那这样就会出现一个非常常见的问题：在实际生产环境中能够直接访问的 API，回到我们的开发环境后，再次访问这些 API 就会产生跨域请求问题。</p>
<p>可能有人会说，我们可以用跨域资源共享（CORS）解决这个问题。确实如此，如果我们请求的后端 API 支持 CORS，那这个问题就不成立了。但是并不是每种情况下服务端的 API 都支持 CORS。如果前后端应用是同源部署，也就是协议 / 域名 / 端口一致，那这种情况下，根本没必要开启 CORS，所以跨域请求的问题仍然是不可避免的。</p>
<p>那解决这种开发阶段跨域请求问题最好的办法，就是在开发服务器中配置一个后端 API 的代理服务，也就是把后端接口服务代理到本地的开发服务地址。</p>
<p>webpack-dev-server 就支持直接通过配置的方式，添加代理服务。接下来，我们来看一下它的具体用法。</p>
<p>这里我们假定 GitHub 的 API 就是我们应用的后端服务，那我们的目标就是将 GitHub API 代理到本地开发服务器中。</p>
<p>我们可以先在浏览器中尝试访问其中的一个接口，具体结果如下图：</p>
<p><img src="https://s0.lgstatic.com/i/image/M00/03/19/CgqCHl6yYZaANEg7AAcJihajV7o403.png" alt="image (4).png"></p>
<p>GitHub API 的 Endpoint 都是在根目录下，也就是说不同的 Endpoint 只是 URL 中的路径部分不同，例如 https://api.github.com/users 和 https://api.github.com/events。</p>
<p>知道 API 地址的规则过后，我们回到配置文件中，在 devServer 配置属性中添加一个 proxy 属性，这个属性值需要是一个对象，对象中的每个属性就是一个代理规则配置。</p>
<p>属性的名称是需要被代理的请求路径前缀，一般为了辨别，我都会设置为 /api。值是所对应的代理规则配置，我们将代理目标地址设置为 https://api.github.com，具体代码如下：</p>
<pre><code data-language="js" class="lang-js"><span class="hljs-comment">// ./webpack.config.js</span>
<span class="hljs-built_in">module</span>.exports = &#123;
  <span class="hljs-comment">// ...</span>
  <span class="hljs-attr">devServer</span>: &#123;
    <span class="hljs-attr">proxy</span>: &#123;
      <span class="hljs-string">'/api'</span>: &#123;
        <span class="hljs-attr">target</span>: <span class="hljs-string">'https://api.github.com'</span>
      &#125;
    &#125;
  &#125;
&#125;
</code></pre>
<p>那此时我们请求 http://localhost:8080/api/users ，就相当于请求了 https://api.github.com/api/users。</p>
<p><img src="https://s0.lgstatic.com/i/image/M00/03/61/CgqCHl6ykvCAKWlNAAAktiTnWHU229.png" alt="2.png"></p>
<p>而我们真正希望请求的地址是 https://api.github.com/users，所以对于代理路径开头的 /api 我们要重写掉。我们可以添加一个 pathRewrite 属性来实现代理路径重写，重写规则就是把路径中开头的 /api 替换为空，pathRewrite 最终会以正则的方式来替换请求路径。</p>
<pre><code data-language="js" class="lang-js"><span class="hljs-comment">// ./webpack.config.js</span>
<span class="hljs-built_in">module</span>.exports = &#123;
  <span class="hljs-comment">// ...</span>
  <span class="hljs-attr">devServer</span>: &#123;
    <span class="hljs-attr">proxy</span>: &#123;
      <span class="hljs-string">'/api'</span>: &#123;
        <span class="hljs-attr">target</span>: <span class="hljs-string">'https://api.github.com'</span>,
        <span class="hljs-attr">pathRewrite</span>: &#123;
          <span class="hljs-string">'^/api'</span>: <span class="hljs-string">''</span> <span class="hljs-comment">// 替换掉代理地址中的 /api</span>
        &#125;
      &#125;
    &#125;
  &#125;
&#125;
</code></pre>
<p>这样我们代理的地址就正常了。</p>
<p><img src="https://s0.lgstatic.com/i/image/M00/03/61/CgqCHl6ykt-AfcoLAAAkkBntZkc327.png" alt="图片1.png"></p>
<p>除此之外，我们还需设置一个 changeOrigin 属性为 true。这是因为默认代理服务器会以我们实际在浏览器中请求的主机名，也就是 localhost:8080 作为代理请求中的主机名。而一般服务器需要根据请求的主机名判断是哪个网站的请求，那 localhost:8080 这个主机名，对于 GitHub 的服务器来说，肯定无法正常请求，所以需要修改。</p>
<p>将代理规则配置的 changeOrigin 属性设置为 true，就会以实际代理请求地址中的主机名去请求，也就是我们正常请求这个地址的主机名是什么，实际请求 GitHub 时就会设置成什么。</p>
<pre><code data-language="js" class="lang-js"><span class="hljs-comment">// ./webpack.config.js</span>
<span class="hljs-built_in">module</span>.exports = &#123;
  <span class="hljs-comment">// ...</span>
  <span class="hljs-attr">devServer</span>: &#123;
    <span class="hljs-attr">proxy</span>: &#123;
      <span class="hljs-string">'/api'</span>: &#123;
        <span class="hljs-attr">target</span>: <span class="hljs-string">'https://api.github.com'</span>,
        <span class="hljs-attr">pathRewrite</span>: &#123;
          <span class="hljs-string">'^/api'</span>: <span class="hljs-string">''</span> <span class="hljs-comment">// 替换掉代理地址中的 /api</span>
        &#125;,
        <span class="hljs-attr">changeOrigin</span>: <span class="hljs-literal">true</span> <span class="hljs-comment">// 确保请求 GitHub 的主机名就是：api.github.com</span>
      &#125;
    &#125;
  &#125;
&#125;
</code></pre>
<p>完成以后，打开命令行终端，运行 webpack-dev-server。然后打开浏览器，这里我们直接尝试请求 http://localhost:8080/api/users，得到的就是 GitHub 的用户数据。 因为这个地址已经被代理到了 GitHub 的用户数据接口。</p>
<p><img src="https://s0.lgstatic.com/i/image/M00/03/19/Ciqc1F6yYeGAJ8GbAAcUqWinpoA554.png" alt="image (7).png"></p>
<p>此时，我们就可以回到代码中使用代理后的本地同源地址去请求后端接口，而不必担心出现跨域问题了。</p>
<h3>写在最后</h3>
<p>最后再来总结一下今天的内容，今天跟你分享了一个叫作 webpack-dev-server 的工具，它是 Webpack 周边工具中最重要的一个，作用就是提升开发者的开发体验，帮助开发者更快更高效的完成开发工作。</p>
<p>当然 webpack-dev-server 提供的体验还不止如此，它还可以提供一种叫作“模块热替换”的开发体验，这一块内容相对复杂一些，我会在 08 课时中详细介绍。</p>
<p>另外我想说，现代化的前端开发过程已经非常方便了，如果你还在使用原始“刀耕火种”的方式进行开发，就一定要尝试一下这些现代化的工具。</p>

<hr>
<h3 id="精选评论"><a href="#精选评论" class="headerlink" title="精选评论"></a>精选评论</h3><h5 id="煜："><a href="#煜：" class="headerlink" title="**煜："></a>**煜：</h5><blockquote>
<p>第六讲打卡&amp;nbsp;汪老师太棒了，你的课后面必须买😀</p>
</blockquote>
<h5 id="翔："><a href="#翔：" class="headerlink" title="*翔："></a>*翔：</h5><blockquote>
<p>老师npx webpack –watch 第一次打包有index.html文件 后面修改文件就没有index.html生成了</p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-讲师回复："><a href="#amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; 正常来说 watch 模式下，文件重新打包是覆盖原来的文件</p>
</blockquote>
<h5 id="宏："><a href="#宏：" class="headerlink" title="**宏："></a>**宏：</h5><blockquote>
<p>大佬,请问下，使用webpack 构建react项目然后使用webpack-dev-server 结果发现 react.js 404 那我是不是要把整个node_modules copy到dist 目录下，copy-webpack-plugin</p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-1"><a href="#amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-1" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; 对于第三方模块应该采用 import 的方式载入，webpack 会自动找到对应的模块文件，最终合并到一起，并不需要单独拷贝</p>
</blockquote>
<h5 id="伟："><a href="#伟：" class="headerlink" title="**伟："></a>**伟：</h5><blockquote>
<p>这个Server是属于loader啊还是属于插件呢？</p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-2"><a href="#amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-2" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; Webpack Dev Server 属于 Webpack 功能体系之外的，属于单独的模块，只是内部使用到了 Webpack 完成构建</p>
</blockquote>
<h5 id="琼："><a href="#琼：" class="headerlink" title="**琼："></a>**琼：</h5><blockquote>
<p>老师，这句话我没怎么理解：’就是在开发服务器中配置一个后端 API 的代理服务，也就是把后端接口服务代理到本地的开发服务地址’。我之前的理解是，webpack-dev-server中的http-proxy-middleware相当于一个Nginx服务器的作用，帮助我们做请求转发，相当于用webpack-dev-server代理的请求就不走浏览器，而是通过我们本地的服务器发送出去，就不存在浏览器的跨域行为了</p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-3"><a href="#amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-3" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; 没有代理的情况下：我们的应用在浏览器端直接请求真实的服务器；<br>有代理的情况下：我们的应用才浏览器端先请求 Webpack Dev Server，再由 Webpack Dev Server 帮着请求真实的服务器；</p>
</blockquote>
<h5 id="6364："><a href="#6364：" class="headerlink" title="**6364："></a>**6364：</h5><blockquote>
<p>为什么我的按照步骤server后页面出现一个bundle.js文件而不不是我的HTML啊，谢谢老师。</p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-4"><a href="#amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-4" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; 问题描述的并不是很清楚哈，我猜测你可能是没有使用 HTML Webpack Plugin 生成 index.html，或者是 contentBase 中没有 index.html，然后默认地址显示的是一个文件列表</p>
</blockquote>
<h5 id="戴："><a href="#戴：" class="headerlink" title="*戴："></a>*戴：</h5><blockquote>
<p>老师有点迷糊了，哈哈，问您下。开发环境的配置中配置devServer,生产环境的配置也需要这样写吗？生产环境不写target的话，需要把所有请求替换成真实完全的api地址吗？</p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-编辑回复："><a href="#amp-nbsp-amp-nbsp-amp-nbsp-编辑回复：" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 编辑回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 编辑回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; Webpack 只是开发阶段需要用的东西，最终到线上只有打包过后的代码文件，不会到线上用 Webpack Dev Server 运行的，至于代理配置，如果需要，线上一般会用 nginx</p>
</blockquote>
<h5 id="斌："><a href="#斌：" class="headerlink" title="*斌："></a>*斌：</h5><blockquote>
<p>加油，继续学习，还有一半</p>
</blockquote>
<h5 id="兰："><a href="#兰：" class="headerlink" title="**兰："></a>**兰：</h5><blockquote>
<p>开发环境下也就是devserve下，如果要访问copy-webpack-plugin拷贝的静态资源文件是不是要配置contentbase</p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-5"><a href="#amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-5" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; 我猜测你是直接用 file 协议访问包含 esmodules 引入的 html，这是不被允许的，import 操作要求必须是 http 形式，这就跟 AJAX 的 API 一样</p>
</blockquote>
<h5 id="GS："><a href="#GS：" class="headerlink" title="GS："></a>GS：</h5><blockquote>
<p>666</p>
</blockquote>
<h5 id="无限："><a href="#无限：" class="headerlink" title="**无限："></a>**无限：</h5><blockquote>
<p>老师好，为什么我配置了proxy之后，输入localhost:8080&#x2F;api&#x2F;users后跳转到了下面这个链接呢<div><span style="font-size: 16.0125px;"><a target="_blank" rel="noopener" href="https://developer.github.com/v3/users/">https://developer.github.com/v3/users/</a></span><br></div></p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-6"><a href="#amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-6" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; 单看你的描述是无法明确你遇到的问题，你应该提供具体你是怎么配置的，最后的现象是如何。或者能有一个复现问题的仓库</p>
</blockquote>
<h5 id="8193："><a href="#8193：" class="headerlink" title="**8193："></a>**8193：</h5><blockquote>
<p>dev server 怎么实现保存文件后自动刷新页面呢</p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-7"><a href="#amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-7" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; 默认就是修改文件后自动刷新页面的</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/11/02/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-Dev-Server-%E6%8F%90%E9%AB%98%E4%BD%A0%E7%9A%84%E6%9C%AC%E5%9C%B0%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%EF%BC%9F/" data-id="claxeer9y000wv8w13aci1832" data-title="如何使用 Dev Server 提高你的本地开发效率？" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-探索-Webpack-运行机制与核心工作原理" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/11/02/%E6%8E%A2%E7%B4%A2-Webpack-%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%E4%B8%8E%E6%A0%B8%E5%BF%83%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/" class="article-date">
  <time class="dt-published" datetime="2022-11-02T11:37:36.000Z" itemprop="datePublished">2022-11-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/11/02/%E6%8E%A2%E7%B4%A2-Webpack-%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%E4%B8%8E%E6%A0%B8%E5%BF%83%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/">探索 Webpack 运行机制与核心工作原理</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>在前面的课时中我们已经对 Webpack 两个最重要的特性：Loader 和插件机制有了深入的了解，今天我们再来解读一下 Webpack 的运行机制和核心工作原理。</p>
<h3>工作过程简介</h3>
<p>其实 Webpack 官网首屏的英雄区就已经很清楚地描述了它的工作原理，如下图所示：</p>
<p><img src="https://s0.lgstatic.com/i/image/M00/00/4E/CgqCHl6pSFmAC5UzAAEwx63IBwE024.png" alt="1.png"></p>
<p>那这里我们先来快速理解一下 Webpack 打包的核心工作过程。我们以一个普通的前端项目为例，项目中一般都会散落着各种各样的代码及资源文件，如下图所示：</p>
<p><img src="https://s0.lgstatic.com/i/image/M00/00/4E/Ciqc1F6pSGGAc9qLAAAkYGOB6fY837.png" alt="2.png"></p>
<p>比如 JS、CSS、图片、字体等，这些文件在 Webpack 的思想中都属于当前项目中的一个模块。Webpack 可以通过打包，将它们最终聚集到一起。Webpack 在整个打包的过程中：</p>
<ul>
<li>通过 Loader 处理特殊类型资源的加载，例如加载样式、图片；</li>
<li>通过 Plugin 实现各种自动化的构建任务，例如自动压缩、自动发布。</li>
</ul>
<p>具体来看打包的过程，Webpack 启动后，会根据我们的配置，找到项目中的某个指定文件（一般这个文件都会是一个 JS 文件）作为入口。然后顺着入口文件中的代码，根据代码中出现的 import（ES Modules）或者是 require（CommonJS）之类的语句，解析推断出来这个文件所依赖的资源模块，然后再分别去解析每个资源模块的依赖，周而复始，最后形成整个项目中所有用到的文件之间的依赖关系树，下面这个动画生动的演示了这个过程：</p>
<p><img src="https://s0.lgstatic.com/i/image/M00/00/4E/Ciqc1F6pSHiAbuTBACPS6wVVqZw547.gif" alt="3.gif"></p>
<p>有了这个依赖关系树过后， Webpack 会遍历（递归）这个依赖树，找到每个节点对应的资源文件，然后根据配置选项中的 Loader 配置，交给对应的 Loader 去加载这个模块，最后将加载的结果放入 bundle.js（打包结果）中，从而实现整个项目的打包，具体操作可以参考下面的动画：</p>
<p><img src="https://s0.lgstatic.com/i/image/M00/00/54/Ciqc1F6pUBeAfHWtAG70TcGBhSM152.gif" alt="4小.gif"></p>
<p>对于依赖模块中无法通过 JavaScript 代码表示的资源模块，例如图片或字体文件，一般的 Loader 会将它们单独作为资源文件拷贝到输出目录中，然后将这个资源文件所对应的访问路径作为这个模块的导出成员暴露给外部。</p>
<p>整个打包过程中，Loader 机制起了很重要的作用，因为如果没有 Loader 的话，Webpack 就无法实现各种各样类型的资源文件加载，那 Webpack 也就只能算是一个用来合并 JS 模块代码的工具了。</p>
<p>至于自定义插件机制，在 04 课时中我们也详细介绍过了，它并不会影响 Webpack 的核心工作过程，只是 Webpack 为了提供一个强大的扩展能力，它为整个工作过程的每个环节都预制了一个钩子，也就是说我们可以通过插件往 Webpack 工作过程的任意环节植入一些自定义的任务，从而扩展 Webpack 打包功能以外的能力。</p>
<p>至此，你就已经了解到了 Webpack 的核心工作过程。</p>
<h3>工作原理剖析</h3>
<p>对于一般的应用开发过程来说，了解以上这些内容基本上就足以应对了，但如果你想了解 Webpack 整个工作过程的细节，那么你就需要更深入地了解刚刚说到的每一个环节，它们落实到代码层面到底做了些什么，或者说是如何实现的。</p>
<p>在这种情况下，我们就必须有针对性的去“查阅”Webpack 的源代码了。注意这里我们强调的是“查阅”，而不是“阅读”。</p>
<p>至于为什么要扣这个字眼，我们先卖个关子，今天的最后再来解释。</p>
<p>既然是“查阅”，我们就必须要有个线索，否则挨个去看每个源代码，就是无意义的阅读。这里我们的思路就是顺着前面刚刚介绍的 Webpack 打包的核心工作过程，提炼出关键环节，然后再有针对性地去找每个环节的实现方式就可以了。</p>
<p>这里我们先提炼出 Webpack 核心工作过程中的关键环节，明确“查阅”源码的思路：</p>
<ol>
<li>Webpack CLI 启动打包流程；</li>
<li>载入 Webpack 核心模块，创建 Compiler 对象；</li>
<li>使用 Compiler 对象开始编译整个项目；</li>
<li>从入口文件开始，解析模块依赖，形成依赖关系树；</li>
<li>递归依赖树，将每个模块交给对应的 Loader 处理；</li>
<li>合并 Loader 处理完的结果，将打包结果输出到 dist 目录。</li>
</ol>
<p>接下来我们将对上述关键环节中的部分内容进行详细介绍。</p>
<h4>一、Webpack CLI</h4>
<p>从 Webpack 4 开始 Webpack 的 CLI 部分就被单独抽到了 <a target="_blank" rel="noopener" href="https://github.com/webpack/webpack-cli">webpack-cli</a> 模块中，目的是为了增强 Webpack 本身的灵活性。所以这一部分的内容我们需要找到 webpack-cli 所对应的源码。</p>
<p>我们这里分析的是 v3.3.11 版本的 webpack-cli，你可以参考该版本的<a target="_blank" rel="noopener" href="https://github.com/webpack/webpack-cli/tree/v3.3.11">源码固定链接</a>。</p>
<blockquote>
<p>P.S. 目前 webpack-cli 官方仓库默认分支下的代码不是 3.x 版本的。</p>
</blockquote>
<p>Webpack CLI 的作用就是将 CLI 参数和 Webpack 配置文件中的配置整合，得到一个完整的配置对象。</p>
<p>这部分操作在 webpack-cli 的入口文件 bin/cli.js 中，这个文件中内容比较多，我们这里只截取部分核心代码，你可以对照截图中的行号找到源代码中对应的位置。</p>
<p>首先，Webpack CLI 会通过 yargs 模块解析 CLI 参数，所谓 CLI 参数指的就是我们在运行 webpack 命令时通过命令行传入的参数，例如 --mode=production，具体位置如下：</p>
<p><img src="https://s0.lgstatic.com/i/image/M00/00/51/Ciqc1F6pS9iAE-dtAAOjZcVPPzw330.png" alt="5.png"></p>
<p>紧接着后面，调用了 bin/utils/convert-argv.js 模块，将得到的命令行参数转换为 Webpack 的配置选项对象，具体操作如下：</p>
<p><img src="https://s0.lgstatic.com/i/image/M00/00/53/CgqCHl6pTd-ASt6BAADU-S6qhDo690.png" alt="image.png"></p>
<p>在 convert-argv.js 工作过程中，首先为传递过来的命令行参数设置了默认值，然后判断了命令行参数中是否指定了一个具体的配置文件路径，如果指定了就加载指定配置文件，反之则需要根据默认配置文件加载规则找到配置文件，具体代码如下：</p>
<p><img src="https://s0.lgstatic.com/i/image/M00/00/53/Ciqc1F6pTeaAedzEAAS80vohmio167.png" alt="image (1).png"></p>
<p>找到配置文件过后，将配置文件中的配置和 CLI 参数中的配置合并，如果出现重复的情况，会优先使用 CLI 参数，最终得到一个完整的配置选项。</p>
<p>有了配置选项过后，开始载入 Webpack 核心模块，传入配置选项，创建 Compiler 对象，这个 Compiler 对象就是整个 Webpack 工作过程中最核心的对象了，负责完成整个项目的构建工作。</p>
<p><img src="https://s0.lgstatic.com/i/image/M00/00/53/CgqCHl6pTe6AKEyAAAFWM1c2jo4379.png" alt="image (2).png"></p>
<h4>二、创建 Compiler 对象</h4>
<p>随着 Webpack CLI 载入 Webpack 核心模块，整个执行过程就到了 Webpack 模块中，所以这一部分的代码需要回到 Webpack 模块中，我这里分析的是 v4.43.0 版本的 Webpack，可参考这个版本的<a target="_blank" rel="noopener" href="https://github.com/webpack/webpack/tree/v4.43.0">源代码的固定链接</a>。</p>
<p>同样，这里我们需要找到这个模块的入口文件，也就是 lib/webpack.js 文件。这个文件导出的是一个用于创建 Compiler 的函数，具体如下：</p>
<p><img src="https://s0.lgstatic.com/i/image/M00/00/53/CgqCHl6pThGAYBSpAAOrHJC19zY284.png" alt="image (3).png"></p>
<p>在这个函数中，首先校验了外部传递过来的 options 参数是否符合要求，紧接着判断了 options 的类型。</p>
<p>根据这个函数中的代码，我们发现 options 不仅仅可以是一个对象，还可以是一个数组。如果我们传入的是一个数组，那么 Webpack 内部创建的就是一个 MultiCompiler，也就是说 Webpack 应该支持同时开启多路打包，配置数组中的每一个成员就是一个独立的配置选项。而如果我们传入的是普通的对象，就会按照我们最熟悉的方式创建一个 Compiler 对象，进行单线打包。</p>
<p><img src="https://s0.lgstatic.com/i/image/M00/00/53/Ciqc1F6pThqAB_XKAAPEsCITm7Q145.png" alt="image (4).png"></p>
<p>我们顺着主线接着往下看，如下图所示：在创建了 Compiler 对象过后，Webpack 就开始注册我们配置中的每一个插件了，因为再往后 Webpack 工作过程的生命周期就要开始了，所以必须先注册，这样才能确保插件中的每一个钩子都能被命中。</p>
<p><img src="https://s0.lgstatic.com/i/image/M00/00/53/Ciqc1F6pTiKAHHyCAAJMG1UWDSA408.png" alt="image (5).png"></p>
<h4>三、开始构建</h4>
<p>完成 Compiler 对象的创建过后，紧接着这里的代码开始判断配置选项中是否启用了监视模式，具体操作如下：</p>
<p><img src="https://s0.lgstatic.com/i/image/M00/00/53/Ciqc1F6pTl6AIg5uAAJLEZQnnTE844.png" alt="image (6).png"></p>
<ul>
<li>如果是监视模式就调用 Compiler 对象的 watch 方法，以监视模式启动构建，但这不是我们主要关心的主线。</li>
<li>如果不是监视模式就调用 Compiler 对象的 run 方法，开始构建整个应用。</li>
</ul>
<p>这个 run 方法定义在 Compiler 类型中，具体文件在 webpack 模块下的 lib/Compiler.js 中，代码位置如下：</p>
<p><img src="https://s0.lgstatic.com/i/image/M00/00/53/Ciqc1F6pTmmAT8OjAALe_UlnYVs734.png" alt="image (7).png"></p>
<p>这个方法内部就是先触发了beforeRun 和 run 两个钩子，然后最关键的是调用了当前对象的 compile 方法，真正开始编译整个项目，具体代码位置如下：</p>
<p><img src="https://s0.lgstatic.com/i/image/M00/00/53/Ciqc1F6pTnCAIOwcAAO9SzOiSUg967.png" alt="image (8).png"></p>
<p>compile 方法内部主要就是创建了一个 Compilation 对象，这个对象我们在 04 课时中有提到，Compilation 字面意思是“合集”，实际上，你就可以理解为一次构建过程中的上下文对象，里面包含了这次构建中全部的资源和信息。</p>
<p><img src="https://s0.lgstatic.com/i/image/M00/00/53/Ciqc1F6pTniAHnnDAAHoLTnzs9A306.png" alt="image (9).png"></p>
<p>创建完 Compilation 对象过后，紧接着触发了一个叫作 make 的钩子，进入整个构建过程最核心的 make 阶段。</p>
<h4>四、make 阶段</h4>
<p>make 阶段主体的目标就是：根据 entry 配置找到入口模块，开始依次递归出所有依赖，形成依赖关系树，然后将递归到的每个模块交给不同的 Loader 处理。</p>
<p><img src="https://s0.lgstatic.com/i/image/M00/00/54/Ciqc1F6pTzWABOtoAAEXDnF67ow274.png" alt="image (10).png"></p>
<p>由于这个阶段的调用过程并不像之前一样，直接调用某个对象的某个方法，而是采用事件触发机制，让外部监听这个 make 事件的地方开始执行，所以从这里往后的代码可能找起来会费点劲儿。</p>
<p>这里我简单提示一下：想要知道这个事件触发后，哪些地方会开始执行，前提是得知道哪里注册了这个叫作 make 的事件。</p>
<p>Webpack 的插件系统是基于官方自己的 Tapable 库实现的，我们想要知道在哪里注册了某个事件，必须要知道如何注册的事件。Tapable 的注册方式具体如下：</p>
<p><img src="https://s0.lgstatic.com/i/image/M00/00/54/CgqCHl6pT0SAQu2BAAD1mVx6IOM261.png" alt="image (11).png"></p>
<p>所以，我们只需要通过开发工具搜索源代码中的 make.tap，就应该能够找到事件注册的位置，具体操作如下：</p>
<p><img src="https://s0.lgstatic.com/i/image/M00/00/54/Ciqc1F6pT06AdneyAARyPGKqWLw664.png" alt="image (12).png"></p>
<p>这里搜索到了六个插件中都注册了 make 事件，这些插件实际上是前面创建 Compiler 对象的时候创建的，刚刚因为没有影响，所以我们就忽略了：</p>
<p><img src="https://s0.lgstatic.com/i/image/M00/00/54/Ciqc1F6pT1aAfcDBAANqf-qyrV8871.png" alt="image (13).png"></p>
<p>因为我们默认使用的就是单一入口打包的方式，所以这里最终会执行其中的 SingleEntryPlugin。</p>
<p><img src="https://s0.lgstatic.com/i/image/M00/00/54/Ciqc1F6pT12AfmmEAAF7uDrm_DY692.png" alt="image (14).png"></p>
<p>这个插件中调用了 Compilation 对象的 addEntry 方法，开始解析我们源代码中的入口文件，以此开始“顺藤摸瓜”式的寻找。</p>
<p>因为时间的关系，我在这里就不再带你继续一步一步的往后探索每一个阶段了，你可以顺着我们刚刚的思路，私下继续去尝试。</p>
<p>对于 make 阶段后续的流程，这里我们概括一下：</p>
<ol>
<li>SingleEntryPlugin 中调用了 Compilation 对象的 addEntry 方法，开始解析入口；</li>
<li>addEntry 方法中又调用了 _addModuleChain 方法，将入口模块添加到模块依赖列表中；</li>
<li>紧接着通过 Compilation 对象的 buildModule 方法进行模块构建；</li>
<li>buildModule 方法中执行具体的 Loader，处理特殊资源加载；</li>
<li>build 完成过后，通过 <a target="_blank" rel="noopener" href="https://github.com/acornjs/acorn">acorn</a> 库生成模块代码的 AST 语法树；</li>
<li>根据语法树分析这个模块是否还有依赖的模块，如果有则继续循环 build 每个依赖；</li>
<li>所有依赖解析完成，build 阶段结束；</li>
<li>最后合并生成需要输出的 bundle.js 写入 dist 目录。</li>
</ol>
<h3>写在最后</h3>
<p>今天的内容，我算是抛砖引玉，围绕着 Webpack 打包的核心工作过程，单独通过查阅对应源码的方式，深入理解了一下 Webpack “前半程”的工作原理，其实我重点想跟你分享的是<strong>如何通过查阅源码来增强对技术理解的方式</strong>。</p>
<p>最后再来解释一下，为什么我要说查阅源代码而不是阅读源代码。</p>
<p>其实我是想说，现在市面上很多的资料动不动就跟你说：“你一定要阅读 XXX 项目的源码”。而当你真的相信了这种说法，自己花费时间去尝试阅读源码的时候，大多数结果都是感觉看不懂，即使是你耗费了很多的时间，把 XXX 项目的源码啃下来了，结果仍然感觉没有太大进步。我不敢说这种“啃源码”的方式一点意义没有，只是投入回报比太低了。</p>
<p>原因是，很多时候你都是为了证明你看过源码而去看的源码，这种目的就决定了，你的效率和效果都不会很好。为什么这么说呢？</p>
<p>因为我们阅读源代码的目的，很多时候都是为了去看某个问题在内部具体是如何实现的。这种情况下我们都是带着问题去看的源码，这种阅读源码的情况越多，积累的就更多，解决问题的能力自然就可以得到提升。</p>
<p>打个比方，源码就好像是牛津词典一样，你是应该没事抱着它一页一页的读，还是应该遇到不懂的单词再去查呢？答案显而易见。</p>
<p>所以说，学习任何东西都需要一个清晰的目标，带着问题，一边学习一边找答案，而不是漫无目的学到哪里是哪里。</p>

<hr>
<h3 id="精选评论"><a href="#精选评论" class="headerlink" title="精选评论"></a>精选评论</h3><h5 id="乐："><a href="#乐：" class="headerlink" title="**乐："></a>**乐：</h5><blockquote>
<p>学习了webpack，收获了人生道理。难得的好讲师，还有别的课程开设吗</p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-编辑回复："><a href="#amp-nbsp-amp-nbsp-amp-nbsp-编辑回复：" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 编辑回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 编辑回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; 会的哦，可以期待一下！</p>
</blockquote>
<h5 id="儿："><a href="#儿：" class="headerlink" title="**儿："></a>**儿：</h5><blockquote>
<p>最后一段话真的太有收获了</p>
</blockquote>
<h5 id="宇："><a href="#宇：" class="headerlink" title="**宇："></a>**宇：</h5><blockquote>
<p>老师的VSCode主题是什么？感觉颜色很好看</p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-讲师回复："><a href="#amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; 截图里面用的应该是 One Dark Pro，我现在使用的是 GitHub Theme</p>
</blockquote>
<h5 id="laza："><a href="#laza：" class="headerlink" title="laza："></a>laza：</h5><blockquote>
<p>遇到问题去看源码，而不是为了源码而源码，太对了。</p>
</blockquote>
<h5 id="娟："><a href="#娟：" class="headerlink" title="**娟："></a>**娟：</h5><blockquote>
<p>讲的太好了</p>
</blockquote>
<h5 id="论："><a href="#论：" class="headerlink" title="**论："></a>**论：</h5><blockquote>
<p>不跑堂</p>
</blockquote>
<h5 id="伟："><a href="#伟：" class="headerlink" title="**伟："></a>**伟：</h5><blockquote>
<p>鼓掌</p>
</blockquote>
<h5 id="强："><a href="#强：" class="headerlink" title="*强："></a>*强：</h5><blockquote>
<p>学习了</p>
</blockquote>
<h5 id="飞："><a href="#飞：" class="headerlink" title="*飞："></a>*飞：</h5><blockquote>
<p>今天被一个nodejs问题搞晕了，引入一个模块，这个模块a里有一个 属性 c: C3 其中C3是个class， 我想判断C3是不是C1 继承来的，用的是 a.c.prototype instanceof C1 , 这时有报错 C1 不存在， 但是当我import 进来 import C1 from “C1” 这样进来可以执行，但是 a.c.prototype instanceof C1 这个会一直是false。搞了很久就一直没搞出结果，最后打印出来两个Function都一摸一样了，还是用等号判断是false。最后我不得不使用了__proto__遍历判断这种硬来的方式先绕过了。不知道是不是nodejs的module和export引起的，我在chrome上用class测试是OK的</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/11/02/%E6%8E%A2%E7%B4%A2-Webpack-%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%E4%B8%8E%E6%A0%B8%E5%BF%83%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/" data-id="claxeera5001dv8w1gx8xaksq" data-title="探索 Webpack 运行机制与核心工作原理" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-如何利用插件机制横向扩展-Webpack-的构建能力？" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/11/02/%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8%E6%8F%92%E4%BB%B6%E6%9C%BA%E5%88%B6%E6%A8%AA%E5%90%91%E6%89%A9%E5%B1%95-Webpack-%E7%9A%84%E6%9E%84%E5%BB%BA%E8%83%BD%E5%8A%9B%EF%BC%9F/" class="article-date">
  <time class="dt-published" datetime="2022-11-02T11:37:06.000Z" itemprop="datePublished">2022-11-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/11/02/%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8%E6%8F%92%E4%BB%B6%E6%9C%BA%E5%88%B6%E6%A8%AA%E5%90%91%E6%89%A9%E5%B1%95-Webpack-%E7%9A%84%E6%9E%84%E5%BB%BA%E8%83%BD%E5%8A%9B%EF%BC%9F/">如何利用插件机制横向扩展 Webpack 的构建能力？</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p data-nodeid="1053" class="">上回说到 Webpack 的 Loader 机制，今天我要跟你分享 Webpack 的另外一个重要的核心特性：插件机制。</p>
<p data-nodeid="1054">Webpack 插件机制的目的是为了增强 Webpack 在项目自动化构建方面的能力。通过上一讲的介绍你应该知道，Loader 就是负责完成项目中各种各样资源模块的加载，从而实现整体项目的模块化，而 Plugin 则是用来解决项目中除了资源模块打包以外的其他自动化工作，所以说 Plugin 的能力范围更广，用途自然也就更多。</p>
<p data-nodeid="1055">我在这里先介绍几个插件最常见的应用场景：</p>
<ul data-nodeid="1056">
<li data-nodeid="1057">
<p data-nodeid="1058">实现自动在打包之前清除 dist 目录（上次的打包结果）；</p>
</li>
<li data-nodeid="1059">
<p data-nodeid="1060">自动生成应用所需要的 HTML 文件；</p>
</li>
<li data-nodeid="1061">
<p data-nodeid="1062">根据不同环境为代码注入类似 API 地址这种可能变化的部分；</p>
</li>
<li data-nodeid="1063">
<p data-nodeid="1064">拷贝不需要参与打包的资源文件到输出目录；</p>
</li>
<li data-nodeid="1065">
<p data-nodeid="1066">压缩 Webpack 打包完成后输出的文件；</p>
</li>
<li data-nodeid="1067">
<p data-nodeid="1068">自动发布打包结果到服务器实现自动部署。</p>
</li>
</ul>
<p data-nodeid="1069">总之，有了 Plugin 的 Webpack 几乎“无所不能”。借助插件，我们就可以轻松实现前端工程化中绝大多数经常用到的功能，这也正是很多初学者会认为 “Webpack 就是前端工程化，或者前端工程化就是 Webpack” 的原因。</p>
<p data-nodeid="1070">那接下来我们通过一些常用插件的使用，具体聊聊 Webpack 的插件机制，最后再通过开发一个自己的插件，去理解插件的工作原理。</p>
<h3 data-nodeid="1071">体验插件机制</h3>
<p data-nodeid="1072">这里我们先来体验几个最常见的插件，首先第一个就是用来自动清除输出目录的插件。</p>
<p data-nodeid="1073">通过之前的尝试，你可能已经发现，Webpack 每次打包的结果都是直接覆盖到 dist 目录。而在打包之前，dist 目录中就可能已经存入了一些在上一次打包操作时遗留的文件，当我们再次打包时，只能覆盖掉同名文件，而那些已经移除的资源文件就会一直累积在里面，最终导致部署上线时出现多余文件，这显然非常不合理。</p>
<p data-nodeid="1074">更为合理的做法就是在每次完整打包之前，自动清理 dist 目录，这样每次打包过后，dist 目录中就只会存在那些必要的文件。</p>
<p data-nodeid="1075">clean-webpack-plugin 这个插件就很好的实现了这一需求。它是一个第三方的 npm 包，我们需要先通过 npm 安装一下，具体操作如下：</p>
<pre class="lang-js" data-nodeid="1076"><code data-language="js">$ npm install clean-webpack-plugin --save-dev
</code></pre>
<p data-nodeid="1077">安装过后，我们回到 Webpack 的配置文件中，然后导入 clean-webpack-plugin 插件，这个插件模块导出了一个叫作 CleanWebpackPlugin 的成员，我们先把它解构出来，具体代码如下。</p>
<pre class="lang-js" data-nodeid="1078"><code data-language="js"><span class="hljs-keyword">const</span> &#123; CleanWebpackPlugin &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">'clean-webpack-plugin'</span>)
</code></pre>
<p data-nodeid="1079">回到配置对象中，添加一个 plugins 属性，这个属性就是专门用来配置插件的地方，它是一个数组，添加一个插件就是在这个数组中添加一个元素。</p>
<p data-nodeid="1080">绝大多数插件模块导出的都是一个类型，我们这里的 CleanWebpackPlugin 也不例外，使用它，就是通过这个类型创建一个实例，放入 plugins 数组中，具体代码如下：</p>
<pre class="lang-js" data-nodeid="1081"><code data-language="js"><span class="hljs-comment">// ./webpack.config.js</span>


<p><span class="hljs-keyword">const</span> &#123; CleanWebpackPlugin &#125; &#x3D; <span class="hljs-built_in">require</span>(<span class="hljs-string">‘clean-webpack-plugin’</span>)</p>
<p><span class="hljs-built_in">module</span>.exports &#x3D; &#123;<br>  <span class="hljs-attr">entry</span>: <span class="hljs-string">‘.&#x2F;src&#x2F;main.js’</span>,<br>  <span class="hljs-attr">output</span>: &#123;<br>    <span class="hljs-attr">filename</span>: <span class="hljs-string">‘bundle.js’</span><br>  &#125;,<br>  <span class="hljs-attr">plugins</span>: [<br>    <span class="hljs-keyword">new</span> CleanWebpackPlugin()<br>  ]<br>&#125;<br></code></pre></p>
<p data-nodeid="1082">完成以后我们来测试一下 clean-webpack-plugin 插件的效果。回到命令行终端，再次运行 Webpack 打包，此时之前的打包结果就不会存在了，dist 目录中存放的就都是我们本次打包的结果。</p>
<p data-nodeid="1083">在这里，我只是希望通过这个非常简单的插件带你体验一下 Webpack 插件的使用。一般来说，当我们有了某个自动化的需求过后，可以先去找到一个合适的插件，然后安装这个插件，最后将它配置到 Webpack 配置对象的 plugins 数组中，这个过程唯一有可能不一样的地方就是，有的插件可能需要有一些配置参数。</p>
<h4 data-nodeid="1084">用于生成 HTML 的插件</h4>
<p data-nodeid="1085">除了自动清理 dist 目录，我们还有一个非常常见的需求，就是自动生成使用打包结果的 HTML，所谓使用打包结果指的是在 HTML 中自动注入 Webpack 打包生成的 bundle。</p>
<p data-nodeid="1086">在使用接下来这个插件之前，我们的 HTML 文件一般都是通过硬编码的方式，单独存放在项目根目录下的，这种方式有两个问题：<br>
项目发布时，我们需要同时发布根目录下的 HTML 文件和 dist 目录中所有的打包结果，非常麻烦，而且上线过后还要确保 HTML 代码中的资源文件路径是正确的。<br>
如果打包结果输出的目录或者文件名称发生变化，那 HTML 代码中所对应的 script 标签也需要我们手动修改路径。</p>
<p data-nodeid="1087">解决这两个问题最好的办法就是让 Webpack 在打包的同时，自动生成对应的 HTML 文件，让 HTML 文件也参与到整个项目的构建过程。这样的话，在构建过程中，Webpack 就可以自动将打包的 bundle 文件引入到页面中。</p>
<p data-nodeid="1088">相比于之前写死 HTML 文件的方式，自动生成 HTML 的优势在于：</p>
<ul data-nodeid="1089">
<li data-nodeid="1090">
<p data-nodeid="1091">HTML 也输出到 dist 目录中了，上线时我们只需要把 dist 目录发布出去就可以了；</p>
</li>
<li data-nodeid="1092">
<p data-nodeid="1093">HTML 中的 script 标签是自动引入的，所以可以确保资源文件的路径是正常的。</p>
</li>
</ul>
<p data-nodeid="1094">具体的实现方式就需要借助于 html-webpack-plugin 插件来实现，这个插件也是一个第三方的 npm 模块，我们这里同样需要单独安装这个模块，具体操作如下：</p>
<pre class="lang-js" data-nodeid="1095"><code data-language="js">$ npm install html-webpack-plugin --save-dev
</code></pre>
<p data-nodeid="1096">安装完成过后，回到配置文件，载入这个模块，不同于 clean-webpack-plugin，html-webpack-plugin 插件默认导出的就是插件类型，不需要再解构内部成员，具体如下：</p>
<pre class="lang-js" data-nodeid="1097"><code data-language="js"><span class="hljs-keyword">const</span> HtmlWebpackPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">'html-webpack-plugin'</span>)
</code></pre>
<p data-nodeid="1098">有了这个类型过后，回到配置对象的 plugins 属性中，同样需要添加一下这个类型的实例对象，完成这个插件的使用，具体配置代码如下：</p>
<pre class="lang-js" data-nodeid="1099"><code data-language="js"><span class="hljs-comment">// ./webpack.config.js</span>
<span class="hljs-keyword">const</span> HtmlWebpackPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">'html-webpack-plugin'</span>)
<span class="hljs-keyword">const</span> &#123; CleanWebpackPlugin &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">'clean-webpack-plugin'</span>)


<p><span class="hljs-built_in">module</span>.exports &#x3D; &#123;<br>  <span class="hljs-attr">entry</span>: <span class="hljs-string">‘.&#x2F;src&#x2F;main.js’</span>,<br>  <span class="hljs-attr">output</span>: &#123;<br>    <span class="hljs-attr">filename</span>: <span class="hljs-string">‘bundle.js’</span><br>  &#125;,<br>  <span class="hljs-attr">plugins</span>: [<br>    <span class="hljs-keyword">new</span> CleanWebpackPlugin(),<br>    <span class="hljs-keyword">new</span> HtmlWebpackPlugin()<br>  ]<br>&#125;<br></code></pre></p>
<p data-nodeid="1100">最后我们回到命令行终端，再次运行打包命令，此时打包过程中就会自动生成一个 index.html 文件到 dist 目录。我们找到这个文件，可以看到文件中的内容就是一段使用了 bundle.js 的空白 HTML，具体结果如下：</p>
<p data-nodeid="1101"><img src="https://s0.lgstatic.com/i/image3/M01/09/76/CgoCgV6mUnaAde1lAAEPswbjvdg271.png" alt="1.png" data-nodeid="1225"><br>
至此，Webpack 就可以动态生成应用所需的 HTML 文件了，但是这里仍然存在一些需要改进的地方：</p>
<ul data-nodeid="1102">
<li data-nodeid="1103">
<p data-nodeid="1104">对于生成的 HTML 文件，页面 title 必须要修改；</p>
</li>
<li data-nodeid="1105">
<p data-nodeid="1106">很多时候还需要我们自定义页面的一些 meta 标签和一些基础的 DOM 结构。</p>
</li>
</ul>
<p data-nodeid="1107">也就是说，还需要我们能够充分自定义这个插件最终输出的 HTML 文件。</p>
<p data-nodeid="1108">如果只是简单的自定义，我们可以通过修改 HtmlWebpackPlugin 的参数来实现。</p>
<p data-nodeid="1109">我们回到 Webpack 的配置文件中，这里我们给 HtmlWebpackPlugin 构造函数传入一个对象参数，用于指定配置选项。其中，title 属性设置的是 HTML 的标题，我们把它设置为 Webpack Plugin Simple。meta 属性需要以对象的形式设置页面中的元数据标签，这里我们尝试为页面添加一个 viewport 设置，具体代码如下：</p>
<pre class="lang-js" data-nodeid="1110"><code data-language="js"><span class="hljs-comment">// ./webpack.config.js</span>
<span class="hljs-keyword">const</span> HtmlWebpackPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">'html-webpack-plugin'</span>)
<span class="hljs-keyword">const</span> &#123; CleanWebpackPlugin &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">'clean-webpack-plugin'</span>)


<p><span class="hljs-built_in">module</span>.exports &#x3D; &#123;<br>  <span class="hljs-attr">entry</span>: <span class="hljs-string">‘.&#x2F;src&#x2F;main.js’</span>,<br>  <span class="hljs-attr">output</span>: &#123;<br>    <span class="hljs-attr">filename</span>: <span class="hljs-string">‘bundle.js’</span><br>  &#125;,<br>  <span class="hljs-attr">plugins</span>: [<br>    <span class="hljs-keyword">new</span> CleanWebpackPlugin(),<br>    <span class="hljs-keyword">new</span> HtmlWebpackPlugin(&#123;<br>      <span class="hljs-attr">title</span>: <span class="hljs-string">‘Webpack Plugin Sample’</span>,<br>      <span class="hljs-attr">meta</span>: &#123;<br>        <span class="hljs-attr">viewport</span>: <span class="hljs-string">‘width&#x3D;device-width’</span><br>      &#125;<br>    &#125;)<br>  ]<br>&#125;<br></code></pre></p>
<p data-nodeid="1111">完成以后回到命令行终端，再次打包，然后我们再来看一下生成的 HTML 文件，此时这里的 title 和 meta 标签就会根据配置生成，具体结果如下：</p>
<p data-nodeid="1112"><img src="https://s0.lgstatic.com/i/image3/M01/09/76/CgoCgV6mUuaAYMySAAFCwyyCVRE614.png" alt="2.png" data-nodeid="1236"></p>
<p data-nodeid="1113">如果需要对 HTML 进行大量的自定义，更好的做法是在源代码中添加一个用于生成 HTML 的模板，然后让 html-webpack-plugin 插件根据这个模板去生成页面文件。</p>
<p data-nodeid="1114">我们这里在 src 目录下新建一个 index.html 文件作为 HTML 文件的模板，然后根据我们的需要在这个文件中添加相应的元素。对于模板中动态的内容，可以使用 Lodash 模板语法输出，模板中可以通过 htmlWebpackPlugin.options 访问这个插件的配置数据，例如我们这里输出配置中的 title 属性，具体代码如下：</p>
<pre class="lang-html" data-nodeid="1115"><code data-language="html"><span class="hljs-comment">&lt;!-- ./src/index.html --&gt;</span>
<span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width, initial-scale=1.0"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">"X-UA-Compatible"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"ie=edge"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">%=</span> <span class="hljs-attr">htmlWebpackPlugin.options.title</span> %&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"container"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>页面上的基础结构<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"root"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre>
<p data-nodeid="1116">有了模板文件过后，回到配置文件中，我们通过 HtmlWebpackPlugin 的 template 属性指定所使用的模板，具体配置如下：</p>
<pre class="lang-js" data-nodeid="1117"><code data-language="js"><span class="hljs-comment">// ./webpack.config.js</span>
<span class="hljs-keyword">const</span> HtmlWebpackPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">'html-webpack-plugin'</span>)
<span class="hljs-keyword">const</span> &#123; CleanWebpackPlugin &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">'clean-webpack-plugin'</span>)


<p><span class="hljs-built_in">module</span>.exports &#x3D; &#123;<br>  <span class="hljs-attr">entry</span>: <span class="hljs-string">‘.&#x2F;src&#x2F;main.js’</span>,<br>  <span class="hljs-attr">output</span>: &#123;<br>    <span class="hljs-attr">filename</span>: <span class="hljs-string">‘bundle.js’</span><br>  &#125;,<br>  <span class="hljs-attr">plugins</span>: [<br>    <span class="hljs-keyword">new</span> CleanWebpackPlugin(),<br>    <span class="hljs-keyword">new</span> HtmlWebpackPlugin(&#123;<br>      <span class="hljs-attr">title</span>: <span class="hljs-string">‘Webpack Plugin Sample’</span>,<br>      <span class="hljs-attr">template</span>: <span class="hljs-string">‘.&#x2F;src&#x2F;index.html’</span><br>    &#125;)<br>  ]<br>&#125;<br></code></pre></p>
<p data-nodeid="1118">完成以后我们回到命令行终端，运行打包命令，然后再来看一下生成的 HTML 文件，此时 HTML 中就都是根据模板生成的内容了，具体结果如下：</p>
<p data-nodeid="1119"><img src="https://s0.lgstatic.com/i/image3/M01/09/77/CgoCgV6mUzmAXCllAAH_iep7GfI751.png" alt="3.png" data-nodeid="1243"></p>
<p data-nodeid="1120">至此，你应该了解了如何通过 html-webpack-plugin 自定义输出 HTML 文件内容。</p>
<p data-nodeid="1121">关于 html-webpack-plugin 插件，除了自定义输出文件的内容，同时输出多个 HTML 文件也是一个非常常见的需求，除非我们的应用是一个单页应用程序，否则一定需要输出多个 HTML 文件。</p>
<p data-nodeid="1122">如果需要同时输出多个 HTML 文件，其实也非常简单，我们回到配置文件中，这里通过 HtmlWebpackPlugin 创建的对象就是用于生成 index.html 的，那我们完全可以再创建一个新的实例对象，用于创建额外的 HTML 文件。</p>
<p data-nodeid="1123">例如，这里我们再来添加一个 HtmlWebpackPlugin 实例用于创建一个 about.html 的页面文件，我们需要通过 filename 指定输出文件名，这个属性的默认值是 index.html，我们把它设置为 about.html，具体配置如下：</p>
<pre class="lang-js" data-nodeid="1124"><code data-language="js"><span class="hljs-comment">// ./webpack.config.js</span>
<span class="hljs-keyword">const</span> HtmlWebpackPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">'html-webpack-plugin'</span>)
<span class="hljs-keyword">const</span> &#123; CleanWebpackPlugin &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">'clean-webpack-plugin'</span>)


<p><span class="hljs-built_in">module</span>.exports &#x3D; &#123;<br>  <span class="hljs-attr">entry</span>: <span class="hljs-string">‘.&#x2F;src&#x2F;main.js’</span>,<br>  <span class="hljs-attr">output</span>: &#123;<br>    <span class="hljs-attr">filename</span>: <span class="hljs-string">‘bundle.js’</span><br>  &#125;,<br>  <span class="hljs-attr">plugins</span>: [<br>    <span class="hljs-keyword">new</span> CleanWebpackPlugin(),<br>    <span class="hljs-comment">&#x2F;&#x2F; 用于生成 index.html</span><br>    <span class="hljs-keyword">new</span> HtmlWebpackPlugin(&#123;<br>      <span class="hljs-attr">title</span>: <span class="hljs-string">‘Webpack Plugin Sample’</span>,<br>      <span class="hljs-attr">template</span>: <span class="hljs-string">‘.&#x2F;src&#x2F;index.html’</span><br>    &#125;),<br>    <span class="hljs-comment">&#x2F;&#x2F; 用于生成 about.html</span><br>    <span class="hljs-keyword">new</span> HtmlWebpackPlugin(&#123;<br>      <span class="hljs-attr">filename</span>: <span class="hljs-string">‘about.html’</span><br>    &#125;)<br>  ]<br>&#125;<br></code></pre></p>
<p data-nodeid="1125">完成以后我们再次回到命令行终端，运行打包命令，然后我们展开 dist 目录，此时 dist 目录中就同时生成了 index.html 和 about.html 两个页面文件。</p>
<p data-nodeid="1126">根据这个尝试我们就应该知道，如果需要创建多个页面，就需要在插件列表中加入多个 HtmlWebpackPlugin 的实例对象，让每个对象负责一个页面文件的生成。</p>
<p data-nodeid="1127">当然了，对于同时输出多个 HTML，一般我们还会配合 Webpack 多入口打包的用法，这样就可以让不同的 HTML 使用不同的打包结果。不过关于多入口打包的用法不在本课时的讨论范畴内，我们后面再进行介绍。</p>
<h4 data-nodeid="1128">用于复制文件的插件</h4>
<p data-nodeid="1129">在我们的项目中一般还有一些不需要参与构建的静态文件，那它们最终也需要发布到线上，例如网站的 favicon、robots.txt 等。</p>
<p data-nodeid="1130">一般我们建议，把这类文件统一放在项目根目录下的 public 或者 static 目录中，我们希望 Webpack 在打包时一并将这个目录下所有的文件复制到输出目录。</p>
<p data-nodeid="1131">对于这种需求，我们可以使用 copy-webpack-plugin 插件来帮我们实现。</p>
<p data-nodeid="1132">同理，我们需要先安装一下 copy-webpack-plugin 插件，安装完成过后，回到配置文件中，导入这个插件类型。然后同样在 plugins 属性中添加一个这个类型的实例，具体代码如下：</p>
<pre class="lang-js te-preview-highlight" data-nodeid="1316"><code data-language="js"><span class="hljs-comment">// ./webpack.config.js</span>
<span class="hljs-keyword">const</span> HtmlWebpackPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">'html-webpack-plugin'</span>)
<span class="hljs-keyword">const</span> CopyWebpackPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">'copy-webpack-plugin'</span>)
<span class="hljs-keyword">const</span> &#123; CleanWebpackPlugin &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">'clean-webpack-plugin'</span>)


<p><span class="hljs-built_in">module</span>.exports &#x3D; &#123;<br>  <span class="hljs-attr">entry</span>: <span class="hljs-string">‘.&#x2F;src&#x2F;main.js’</span>,<br>  <span class="hljs-attr">output</span>: &#123;<br>    <span class="hljs-attr">filename</span>: <span class="hljs-string">‘bundle.js’</span><br>  &#125;,<br>  <span class="hljs-attr">plugins</span>: [<br>    <span class="hljs-keyword">new</span> CleanWebpackPlugin(),<br>    <span class="hljs-keyword">new</span> HtmlWebpackPlugin(&#123;<br>      <span class="hljs-attr">title</span>: <span class="hljs-string">‘Webpack Plugin Sample’</span>,<br>      <span class="hljs-attr">template</span>: <span class="hljs-string">‘.&#x2F;src&#x2F;index.html’</span><br>    &#125;),<br>    <span class="hljs-keyword">new</span> CopyWebpackPlugin(&#123;<br>      <span class="hljs-attr">patterns</span>: [<span class="hljs-string">‘public’</span>] <span class="hljs-comment">&#x2F;&#x2F; 需要拷贝的目录或者路径通配符</span><br>    &#125;)<br>  ]<br>&#125;<br></code></pre></p>
<p data-nodeid="1134">这个插件类型的构造函数需要我们传入一个字符串数组，用于指定需要拷贝的文件路径。它可以是一个通配符，也可以是一个目录或者文件的相对路径。我们这里传入的是 public 目录，表示将这个目录下所有文件全部拷贝到输出目录中。当然了，你还可以在这个数组中继续添加其它路径，这样它在工作时可以同时拷贝。</p>
<p data-nodeid="1135">配置完成以后回到命令行终端，再次运行 Webpack，此时 public 目录下的文件就会同时拷贝到输出目录中。</p>
<p data-nodeid="1136">至此，我们简单了解了几个非常常用的插件，这里的重点是，你不仅要学会使用这几个插件的使用，还要能够总结出大多数插件在使用上的共性。</p>
<h3 data-nodeid="1137">开发一个插件</h3>
<p data-nodeid="1138">通过前面的介绍，我们知道相比于 Loader，插件的能力范围更宽，因为 Loader 只是在模块的加载环节工作，而插件的作用范围几乎可以触及 Webpack 工作的每一个环节。</p>
<p data-nodeid="1139">那么，这种插件机制是如何实现的呢？</p>
<p data-nodeid="1140">其实说起来也非常简单，Webpack 的插件机制就是我们在软件开发中最常见的钩子机制。</p>
<p data-nodeid="1141">钩子机制也特别容易理解，它有点类似于 Web 中的事件。在 Webpack 整个工作过程会有很多环节，为了便于插件的扩展，Webpack 几乎在每一个环节都埋下了一个钩子。这样我们在开发插件的时候，通过往这些不同节点上挂载不同的任务，就可以轻松扩展 Webpack 的能力。</p>
<p data-nodeid="1142"><img src="https://s0.lgstatic.com/i/image3/M01/16/A6/Ciqah16mU4KAX07hABBXsBqlv1U403.gif" alt="4.gif" data-nodeid="1266"></p>
<p data-nodeid="1143">具体有哪些预先定义好的钩子，我们可以参考官方文档的 API：</p>
<ul data-nodeid="1144">
<li data-nodeid="1145">
<p data-nodeid="1146"><a target="_blank" rel="noopener" href="https://webpack.js.org/api/compiler-hooks/" data-nodeid="1270">Compiler Hooks</a>；</p>
</li>
<li data-nodeid="1147">
<p data-nodeid="1148"><a target="_blank" rel="noopener" href="https://webpack.js.org/api/compilation-hooks/" data-nodeid="1274">Compilation Hooks</a>；</p>
</li>
<li data-nodeid="1149">
<p data-nodeid="1150"><a target="_blank" rel="noopener" href="https://webpack.js.org/api/parser/" data-nodeid="1278">JavascriptParser Hooks</a>。</p>
</li>
</ul>
<p data-nodeid="1151">接下来，我们来开发一个自己的插件，看看具体如何往这些钩子上挂载任务。</p>
<p data-nodeid="1152">这里我的需求是，希望我们开发的这个插件能够自动清除 Webpack 打包结果中的注释，这样一来，我们的 bundle.js 将更容易阅读，如下图所示：</p>
<p data-nodeid="1153"><img src="https://s0.lgstatic.com/i/image3/M01/16/A6/Ciqah16mU7eAe9FhAANSGI-INmg120.png" alt="5.png" data-nodeid="1284"></p>
<p data-nodeid="1154">那这里我们同样在项目根目录下添加一个单独的 JS 文件。</p>
<pre class="lang-js" data-nodeid="1155"><code data-language="js">└─ <span class="hljs-number">04</span>-webpack-plugins ······················· sample root dir
    ├── public ······························· <span class="hljs-keyword">static</span> dir
    │   └── favicon.ico ······················ <span class="hljs-keyword">static</span> file
    ├── src ·································· source dir
    │   └── main.js ·························· entry <span class="hljs-built_in">module</span>
    ├── package.json ························· package file
+   ├── remove-comments-plugin.js ············ my plugin
    └── webpack.config.js ···················· webpack config file
</code></pre>
<p data-nodeid="1156">Webpack 要求我们的插件必须是一个函数或者是一个包含 apply 方法的对象，一般我们都会定义一个类型，在这个类型中定义 apply 方法。然后在使用时，再通过这个类型来创建一个实例对象去使用这个插件。</p>
<p data-nodeid="1157">所以我们这里定义一个 RemoveCommentsPlugin 类型，然后在这个类型中定义一个 apply 方法，这个方法会在 Webpack 启动时被调用，它接收一个 compiler 对象参数，这个对象是 Webpack 工作过程中最核心的对象，里面包含了我们此次构建的所有配置信息，我们就是通过这个对象去注册钩子函数，具体代码如下：</p>
<pre class="lang-js" data-nodeid="1158"><code data-language="js"><span class="hljs-comment">// ./remove-comments-plugin.js</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RemoveCommentsPlugin</span> </span>&#123;
  apply (compiler) &#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'RemoveCommentsPlugin 启动'</span>)
    <span class="hljs-comment">// compiler =&gt; 包含了我们此次构建的所有配置信息</span>
  &#125;
&#125;
</code></pre>
<p data-nodeid="1159">知道这些过后，还需要明确我们这个任务的执行时机，也就是到底应该把这个任务挂载到哪个钩子上。</p>
<p data-nodeid="1160">我们的需求是删除 bundle.js 中的注释，也就是说只有当 Webpack 需要生成的 bundle.js 文件内容明确过后才可能实施。</p>
<p data-nodeid="1161"><img src="https://s0.lgstatic.com/i/image3/M01/09/77/CgoCgV6mU-uAK0ADAAC9ZzsLxNA415.png" alt="6.png" data-nodeid="1292"></p>
<p data-nodeid="1162">那根据 API 文档中的介绍，我们找到一个叫作 emit 的钩子，这个钩子会在 Webpack 即将向输出目录输出文件时执行，非常符合我们的需求。</p>
<p data-nodeid="1163">我们回到代码中，通过 compiler 对象的 hooks 属性访问到 emit 钩子，再通过 tap 方法注册一个钩子函数，这个方法接收两个参数：</p>
<ul data-nodeid="1164">
<li data-nodeid="1165">
<p data-nodeid="1166">第一个是插件的名称，我们这里的插件名称是 RemoveCommentsPlugin；</p>
</li>
<li data-nodeid="1167">
<p data-nodeid="1168">第二个是要挂载到这个钩子上的函数；</p>
</li>
</ul>
<p data-nodeid="1169">根据 API 文档中的提示，这里我们在这个函数中接收一个 compilation 对象参数，这个对象可以理解为此次运行打包的上下文，所有打包过程中产生的结果，都会放到这个对象中。</p>
<p data-nodeid="1170">我们可以使用这个对象中的 assets 属性获取即将写入输出目录的资源文件信息，它是一个对象，我们这里通过 for in 去遍历这个对象，其中键就是每个文件的名称，我们尝试把它打印出来，具体代码如下：</p>
<pre class="lang-js" data-nodeid="1171"><code data-language="js"><span class="hljs-comment">// ./remove-comments-plugin.js</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RemoveCommentsPlugin</span> </span>&#123;
  apply (compiler) &#123;
    compiler.hooks.emit.tap(<span class="hljs-string">'RemoveCommentsPlugin'</span>, compilation =&gt; &#123;
      <span class="hljs-comment">// compilation =&gt; 可以理解为此次打包的上下文</span>
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> name <span class="hljs-keyword">in</span> compilation.assets) &#123;
        <span class="hljs-built_in">console</span>.log(name) <span class="hljs-comment">// 输出文件名称</span>
      &#125;
    &#125;)
  &#125;
&#125;
</code></pre>
<p data-nodeid="1172">完成以后，我们将这个插件应用到 Webpack 的配置中，然后回到命令行重新打包，此时打包过程就会打印我们输出的文件名称，代码如下：</p>
<p data-nodeid="1173"><img src="https://s0.lgstatic.com/i/image3/M01/16/A6/Ciqah16mVA2AXtYNAAIJVZqL4l0487.png" alt="7.png" data-nodeid="1302"></p>
<p data-nodeid="1174">我们再回到代码中，来打印一下每个资源文件的内容，文件内容需要通过遍历的值对象中的 source 方法获取，具体代码如下：</p>
<pre class="lang-js" data-nodeid="1175"><code data-language="js"><span class="hljs-comment">// ./remove-comments-plugin.js</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RemoveCommentsPlugin</span> </span>&#123;
  apply (compiler) &#123;
    compiler.hooks.emit.tap(<span class="hljs-string">'RemoveCommentsPlugin'</span>, compilation =&gt; &#123;
      <span class="hljs-comment">// compilation =&gt; 可以理解为此次打包的上下文</span>
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> name <span class="hljs-keyword">in</span> compilation.assets) &#123;
        <span class="hljs-comment">// console.log(name)</span>
        <span class="hljs-built_in">console</span>.log(compilation.assets[name].source()) <span class="hljs-comment">// 输出文件内容</span>
      &#125;
    &#125;)
  &#125;
&#125;
</code></pre>
<p data-nodeid="1176">回到命令行，再次打包，此时输出的文件内容也可以正常被打印。</p>
<p data-nodeid="1177">能够拿到文件名和文件内容后，我们回到代码中。这里需要先判断文件名是不是以 .js 结尾，因为 Webpack 打包还有可能输出别的文件，而我们的需求只需要处理 JS 文件。</p>
<p data-nodeid="1178">那如果是 JS 文件，我们将文件内容得到，再通过正则替换的方式移除掉代码中的注释，最后覆盖掉 compilation.assets 中对应的对象，在覆盖的对象中，我们同样暴露一个 source 方法用来返回新的内容。另外还需要再暴露一个 size 方法，用来返回内容大小，这是 Webpack 内部要求的格式，具体代码如下：</p>
<pre class="lang-js" data-nodeid="1179"><code data-language="js"><span class="hljs-comment">// ./remove-comments-plugin.js</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RemoveCommentsPlugin</span> </span>&#123;
  apply (compiler) &#123;
    compiler.hooks.emit.tap(<span class="hljs-string">'RemoveCommentsPlugin'</span>, compilation =&gt; &#123;
      <span class="hljs-comment">// compilation =&gt; 可以理解为此次打包的上下文</span>
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> name <span class="hljs-keyword">in</span> compilation.assets) &#123;
        <span class="hljs-keyword">if</span> (name.endsWith(<span class="hljs-string">'.js'</span>)) &#123;
          <span class="hljs-keyword">const</span> contents = compilation.assets[name].source()
          <span class="hljs-keyword">const</span> noComments = contents.replace(<span class="hljs-regexp">/\/\*&#123;2,&#125;\/\s?/g</span>, <span class="hljs-string">''</span>)
          compilation.assets[name] = &#123;
            <span class="hljs-attr">source</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> noComments,
            <span class="hljs-attr">size</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> noComments.length
          &#125;
        &#125;
      &#125;
    &#125;)
  &#125;
&#125;
</code></pre>
<p data-nodeid="1180">完成以后回到命令行终端，再次打包，打包完成过后，我们再来看一下 bundle.js，此时 bundle.js 中每行开头的注释就都被移除了。</p>
<p data-nodeid="1181"><img src="https://s0.lgstatic.com/i/image3/M01/16/A6/Ciqah16mVDaAdaknAAKANs8CYJM313.png" alt="8.png" data-nodeid="1310"></p>
<p data-nodeid="1182">以上就是我们实现一个移除注释插件的过程，通过这个过程我们了解了：插件都是通过往 Webpack 生命周期的钩子中挂载任务函数实现的。</p>
<h3 data-nodeid="1183">写在最后</h3>
<p data-nodeid="1184">最后我们再来总结一下今天的内容：</p>
<p data-nodeid="1185">首先，我们简单了解了几个非常常用的插件，这些插件一般都适用于任何类型的项目。不管你有没有使用框架，或者使用的是哪一个框架，它们基本上都会用到，所以说，在这之后你最好能够仔细过一遍这些插件的官方说明，看看它们还可以有哪些特别的用法，做到心中有数。</p>
<p data-nodeid="1186" class="">除此之外，社区中还提供了成百上千的插件，你并不需要也不可能全部认识。当你遇到一些具体的构建需求时，再去提炼你需求中的关键词然后搜索它们，例如，我想要压缩输出的图片，我会搜索 imagemin webpack plugin。虽然说每个插件的作用不尽相同，但是在用法上基本都是类似的。</p>

<hr>
<h3 id="精选评论"><a href="#精选评论" class="headerlink" title="精选评论"></a>精选评论</h3><h5 id="力："><a href="#力：" class="headerlink" title="**力："></a>**力：</h5><blockquote>
<p>copy-webpack-plugin那块，英文文档上是这样配置的：new CopyWebpackPlugin({      patterns: [‘public’]    }),</p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-讲师回复："><a href="#amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; Clean Webpack Plugin 这个插件最近更新了新版本，API 上发生了一点变化</p>
</blockquote>
<h5 id="前："><a href="#前：" class="headerlink" title="**前："></a>**前：</h5><blockquote>
<p>想请教一个问题。面头条遇到的一个面试题。plugin能完成loader的功能吗？<br>根据这两节的学习，loader是在加载过程中，拿到源文件内容，再进行一些处理，最后转化成js代码。plugin也能够在合适的时机拿到源文件内容，并通过一些操作，最后覆盖源文件。plugin是loader的扩展，完成loader无法完成的功能。<div>但仍然无法确定plugin是否能完成loader的功能，如果可以，是否有必要干掉loader？</div></p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-1"><a href="#amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-1" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; 理论上是可行的，比如对 CSS 文件进行处理，Plugin 就可以在 Loader 执行之前先处理 CSS 文件。但是这种方式太麻烦，并不符合 Webpack 的设计</p>
</blockquote>
<h5 id="玲："><a href="#玲：" class="headerlink" title="**玲："></a>**玲：</h5><blockquote>
<p>讲的非常好，这是我听过最详细易懂的webpack讲解。知其然，知其所以然😄😄😄</p>
</blockquote>
<h5 id="Rainbow556："><a href="#Rainbow556：" class="headerlink" title="Rainbow556："></a>Rainbow556：</h5><blockquote>
<p>作者写的很好，对想入门webpack的同学来说非常友好，解释了很多为什么</p>
</blockquote>
<h5 id="银："><a href="#银：" class="headerlink" title="*银："></a>*银：</h5><blockquote>
<p>报：RemoveCommentsPlugin is not a constructor的错误， 需要在remove-comments-plugin.js 导出类型,添加：module.exports&#x3D;RemoveCommentsPlugin</p>
</blockquote>
<h5 id="浩："><a href="#浩：" class="headerlink" title="*浩："></a>*浩：</h5><blockquote>
<p>讲的非常好，捡到宝了一样，后续出实战版的时候会通知么</p>
</blockquote>
<h5 id="源："><a href="#源：" class="headerlink" title="**源："></a>**源：</h5><blockquote>
<p>踩两个小坑：1.<span style="font-size: 16.0125px;">new CopyWebpackPlugin({ patterns: [{</span><div><span style="font-size: 16.0125px;">&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; from: ‘xxx’,</span></div><div><span style="font-size: 16.0125px;">&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; to:’xxx’</span></div><div><span style="font-size: 16.0125px;">&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }]</span></div><div><span style="font-size: 16.0125px;">&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; })</span></div><div><span style="font-size: 16.0125px;">2.&amp;nbsp;const noComments &#x3D; contents.replace(&#x2F;/*{2,}/\s?&#x2F;g, ‘’),<br></span>这个得先加上toString()</div><div><span style="font-size: 16.0125px;">const noComments &#x3D; contents.toString().</span>replace(&#x2F;/*{2,}/\s?&#x2F;g, ‘’),</div><div><br></div></p>
</blockquote>
<h5 id="论："><a href="#论：" class="headerlink" title="**论："></a>**论：</h5><blockquote>
<p>老师，new CleanWebpackPlugin()不起作用。我的.&#x2F;static&#x2F;image目录下有一张图片，然后我使用CopyWebpackPlugin, new CopyWebpackPlugin({patterns: [.&#x2F;static&#x2F;image]}) 拷贝.&#x2F;static&#x2F;image，dist下确实多了一张图片，但这不是我想要的结果。然后我把patterns: [.&#x2F;static&#x2F;image]改为patterns: [.&#x2F;static]，也就是把整个image目录拷贝过去，确实也成功了。这时候问题来了，原先的那张图片并没有被CleanWebpackPlugin插件清除掉，请问怎么回事呢？</p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-2"><a href="#amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-2" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; 如果可以请提供完整的配置代码，单从你描述的情况无法定位问题的根源</p>
</blockquote>
<h5 id="飞："><a href="#飞：" class="headerlink" title="*飞："></a>*飞：</h5><blockquote>
<p>个人觉得，老师在写这段的时候compilation.assets[name] &#x3D; { noComments, noComments.length}使用Object.assign来处理一下compilation.assets[name] &#x3D; Object.assign(compilation.assets[name], { resSOurce, resSOurce.length})</p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-3"><a href="#amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-3" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; 其实原有对象信息中没有其他必要的属性了，所以按照这个方式处理没有问题</p>
</blockquote>
<h5 id="lpzh："><a href="#lpzh：" class="headerlink" title="lpzh："></a>lpzh：</h5><blockquote>
<p>new CopyWebpackPlugin([ ‘public’ &#x2F;&#x2F; 需要拷贝的目录或者路径通配符 ])这个参数格式写错了吧？还是我错了</p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-4"><a href="#amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-4" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; copy-webpack-plugin 最近更新了，最新版本的参数发生变化了，具体可以参考官方文档，文章中我已经更新过来了</p>
</blockquote>
<h5 id="园："><a href="#园：" class="headerlink" title="**园："></a>**园：</h5><blockquote>
<p>老师，自定义插件只能通过module.exports和require这种方式导出和导入吗，用ES6的export和import好像不行，为什么呢？</p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-5"><a href="#amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-5" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; 我们所编写的 Webpack 配置实际上是运行在 Node.js 环境下的，目前 Node.js 环境中还不能直接支持 ES Modules</p>
</blockquote>
<h5 id="旺："><a href="#旺：" class="headerlink" title="*旺："></a>*旺：</h5><blockquote>
<p>为啥我报：RemoveCommentsPlugin is not a constructor的错误啊，引入方式：const RemoveCommentsPlugin &#x3D; require(‘.&#x2F;remove-comments-plugin’);应该没问题吧</p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-6"><a href="#amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-6" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; 这个得看你在 .&#x2F;remove-comments-plugin.js 文件中到底导出底是个什么东西，在这个例子中需要在这个模块中以 module.exports 的方式导出一个类型</p>
</blockquote>
<h5 id="生："><a href="#生：" class="headerlink" title="**生："></a>**生：</h5><blockquote>
<p>能增加个插件的发布吗</p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-7"><a href="#amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-7" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; 插件的发布其实就是 NPM 模块的发布，并不属于我们这里的主题</p>
</blockquote>
<h5 id="龙："><a href="#龙：" class="headerlink" title="**龙："></a>**龙：</h5><blockquote>
<p>渐渐明白，一边敲，一边解决bug，还挺好玩的</p>
</blockquote>
<h5 id="9312："><a href="#9312：" class="headerlink" title="**9312："></a>**9312：</h5><blockquote>
<p>copy-webpack-plugin参数需要是一个对象</p>
</blockquote>
<h5 id="哈："><a href="#哈：" class="headerlink" title="**哈："></a>**哈：</h5><blockquote>
<p>html模板中的htmlWebpackPlugin值是怎么来的</p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-8"><a href="#amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-8" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; 插件在工作时自动作为模版数据注入进去的呀</p>
</blockquote>
<h5 id="峰："><a href="#峰：" class="headerlink" title="*峰："></a>*峰：</h5><blockquote>
<p>哈哈，没用过，后端的，直接看，也能大致懂😀</p>
</blockquote>
<h5 id="儿："><a href="#儿：" class="headerlink" title="**儿："></a>**儿：</h5><blockquote>
<p>老师真的太用心了！</p>
</blockquote>
<h5 id="wjk："><a href="#wjk：" class="headerlink" title="wjk："></a>wjk：</h5><blockquote>
<div>copy-webpack-plugin 那部分，为什么我必须得写成这样才能通过？</div><div>new CopyWebpackPlugin({patterns:['public']})</div><div><br></div>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-9"><a href="#amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-9" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; 这个得看你的项目结构是怎样的了，不同项目结构是不一样的，我们所演示的是 public 目录就在项目的根目录下，也就是 webpack.config.js 的同级目录</p>
</blockquote>
<h5 id="翻："><a href="#翻：" class="headerlink" title="*翻："></a>*翻：</h5><blockquote>
<p>老师讲的可以，我要好好学习😁😁😁</p>
</blockquote>
<h5 id="壮："><a href="#壮：" class="headerlink" title="**壮："></a>**壮：</h5><blockquote>
<p>HtmlWebpackPlugin 修改 title，对应的 template 要加上&amp;nbsp;&lt;title&gt;&lt;%&#x3D; htmlWebpackPlugin.options.title %&gt;&lt;&#x2F;title&gt; 这个才能生效</p>
</blockquote>
<h5 id="杰："><a href="#杰：" class="headerlink" title="**杰："></a>**杰：</h5><blockquote>
<p>今日学习打卡</p>
</blockquote>
<h5 id="鑫："><a href="#鑫：" class="headerlink" title="**鑫："></a>**鑫：</h5><blockquote>
<p>在remove-comments-plugin.js中，const contents &#x3D; compilation.assets[name].source()后的contents 是一个Buffer，需要toString一下才能正常运行吧？</p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-10"><a href="#amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-10" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; source 方法返回的就是一个字符串</p>
</blockquote>
<h5 id="硕："><a href="#硕：" class="headerlink" title="*硕："></a>*硕：</h5><blockquote>
<div style="color: rgb(51, 51, 51); background-color: rgb(245, 245, 245); font-family: Menlo, Monaco, &quot;Courier New&quot;, monospace; font-size: 13px; line-height: 20px; white-space: pre;"><span style="color: #7a3e9d;">module</span><span style="color: #777777;">.</span><span style="color: #7a3e9d;">exports</span> <span style="color: #777777;">=</span> <span style="color: #7a3e9d;">RemoveCommentsPlugin</span><span style="color: #777777;">;</span></div><div style="background-color: rgb(245, 245, 245); font-family: Menlo, Monaco, &quot;Courier New&quot;, monospace; font-size: 13px; line-height: 20px; white-space: pre;"><font color="#777777">没有声明对外的接口。。。没人发现吗</font></div>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-11"><a href="#amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-11" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; 哈哈，文章里面贴的当然是部分核心代码</p>
</blockquote>
<h5 id="煜："><a href="#煜：" class="headerlink" title="**煜："></a>**煜：</h5><blockquote>
<p>讲的太好了&amp;nbsp; &amp;nbsp;哇&amp;nbsp; &amp;nbsp; &amp;nbsp;第一次写评论</p>
</blockquote>
<h5 id="鹏："><a href="#鹏：" class="headerlink" title="**鹏："></a>**鹏：</h5><blockquote>
<p>老师如何调试loader与plugin</p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-12"><a href="#amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-12" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; 我一般就是通过 console 打印的方式，你也可以使用断点调试，后面有介绍，不过我不建议你这样用，成本太高</p>
</blockquote>
<h5 id="0591："><a href="#0591：" class="headerlink" title="**0591："></a>**0591：</h5><blockquote>
<p>通俗易懂，娓娓道来。</p>
</blockquote>
<h5 id="沭："><a href="#沭：" class="headerlink" title="*沭："></a>*沭：</h5><blockquote>
<p>第四讲打卡，希望能坚持打卡到最后一讲</p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-编辑回复："><a href="#amp-nbsp-amp-nbsp-amp-nbsp-编辑回复：" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 编辑回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 编辑回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; 加油呀</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/11/02/%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8%E6%8F%92%E4%BB%B6%E6%9C%BA%E5%88%B6%E6%A8%AA%E5%90%91%E6%89%A9%E5%B1%95-Webpack-%E7%9A%84%E6%9E%84%E5%BB%BA%E8%83%BD%E5%8A%9B%EF%BC%9F/" data-id="claxeera00010v8w14oij4dzl" data-title="如何利用插件机制横向扩展 Webpack 的构建能力？" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-如何通过-Loader-实现特殊资源加载？" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/11/02/%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87-Loader-%E5%AE%9E%E7%8E%B0%E7%89%B9%E6%AE%8A%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD%EF%BC%9F/" class="article-date">
  <time class="dt-published" datetime="2022-11-02T11:36:38.000Z" itemprop="datePublished">2022-11-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/11/02/%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87-Loader-%E5%AE%9E%E7%8E%B0%E7%89%B9%E6%AE%8A%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD%EF%BC%9F/">如何通过 Loader 实现特殊资源加载？</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p data-nodeid="31972" class="">今天我要跟你分享的内容是如何通过 Loader 机制实现特殊资源加载，通过开发一个 Loader 深入理解 Webpack Loader 机制的原理。</p>
<p data-nodeid="31973">正如开篇词中所讲，Webpack 想要实现的是整个前端项目的模块化，项目中的各种资源（包括 CSS 文件、图片等）都应该属于需要被管理的模块。换句话说， Webpack 不仅是 JavaScript 模块打包工具，还是整个前端项目（前端工程）的模块打包工具。也就是说，我们可以通过 Webpack 去管理前端项目中任意类型的资源文件。</p>
<p data-nodeid="31974">因为 Webpack 实现不同种类资源模块加载的核心就是 Loader，所以今天我来和你聊聊 Webpack 的 Loader 机制。</p>
<h3 data-nodeid="31975">如何加载资源模块</h3>
<p data-nodeid="31976">首先，我们尝试通过 Webpack 打包项目中的一个 CSS 文件，由此开始探索 Webpack 是如何加载资源模块的？</p>
<p data-nodeid="31977">在下面这个案例中，我们在项目的 src 目录下添加一个普通的样式文件 main.css，具体结构和样式代码如下所示：</p>
<pre class="lang-js" data-nodeid="31978"><code data-language="js"> └─ <span class="hljs-number">03</span>-webpack-loader ························ sample root dir
    ├── src ·································· source dir
+   │   └── main.css ························· main styles
    ├── package.json ························· package file
    └── webpack.config.js ···················· webpack config file
</code></pre>
<pre class="lang-js" data-nodeid="31979"><code data-language="js">/* ./src/main.css */
body &#123;
  margin: 0 auto;
  padding: 0 20px;
  max-width: 800px;
  background: #f4f8fb;
&#125;
</code></pre>
<p data-nodeid="31980">然后将 Webpack 配置中的入口文件路径指定为 main.css 的文件路径，让 Webpack 直接打包 CSS 资源文件，具体配置如下所示：</p>
<pre class="lang-js" data-nodeid="31981"><code data-language="js"><span class="hljs-built_in">module</span>.exports = &#123;
  <span class="hljs-comment">// 样式文件路径</span>
  <span class="hljs-attr">entry</span>: <span class="hljs-string">'./src/main.css'</span>,
  <span class="hljs-attr">output</span>: &#123;
    <span class="hljs-attr">filename</span>: <span class="hljs-string">'bundle.js'</span>
  &#125;
&#125;
</code></pre>
<p data-nodeid="31982">你可能会好奇：Webpack 的打包入口不是应该是一个 JS 文件吗？为什么这里配置成了一个 CSS 文件呢？</p>
<p data-nodeid="31983">其实 Webpack 并没有强制要求我们必须以 JS 文件作为打包入口，只是在绝大多数情况下，我们会用 JS 文件作为打包入口，因为 JS 文件才是程序的逻辑入口，以 JS 文件作为入口相对更合理。</p>
<p data-nodeid="31984">那么，我们这里为什么要使用 CSS 文件作为入口呢？其实就是单纯地为了尝试使用 Webpack 直接去打包 CSS 文件，关于同时打包 JS 和 CSS 的操作，待会儿会详细介绍。</p>
<p data-nodeid="31985">配置完成过后回到命令行终端再次运行 Webpack 打包命令，此时你会发现命令行报出了一个模块解析错误，如下所示：</p>
<p data-nodeid="31986"><img src="https://s0.lgstatic.com/i/image3/M01/13/A7/Ciqah16f_9iAeIxHAAEyykeZNFk556.png" alt="w1.png" data-nodeid="32148"></p>
<p data-nodeid="31987">错误信息大体的意思是说，在解析模块过程中遇到了非法字符，而且错误出现的位置就是在我们的 CSS 文件中。</p>
<p data-nodeid="31988">出现这个错误的原因是因为 Webpack 内部默认只能够处理 JS 模块代码，也就是说在打包过程中，它默认把所有遇到的文件都当作 JavaScript 代码进行解析，但是此处我们让 Webpack 处理的是 CSS 代码，而 CSS 代码是不符合 JavaScript 语法的，所以自然会报出模块解析错误。</p>
<p data-nodeid="31989">为了佐证 Webpack 默认只能够按照 JavaScript 语法解析模块，你可以尝试将 main.css 文件中的代码修改为一段 JavaScript 代码，然后重新运行 Webpack 打包来看一下结果。具体操作如下：</p>
<pre class="lang-js" data-nodeid="31990"><code data-language="js"><span class="hljs-comment">/* ./src/main.css */</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'This is a style sheet.'</span>) 
<span class="hljs-comment">/* 只是为了证明 Webpack 默认按照 JS 语法解析模块 */</span>
</code></pre>
<p data-nodeid="31991"><img src="https://s0.lgstatic.com/i/image3/M01/13/A8/Ciqah16gAIuASNDtAACtn0stBcY488.png" alt="w2.png" data-nodeid="32154"></p>
<blockquote data-nodeid="31992">
<p data-nodeid="31993">注意：这里在 CSS 中编写 JS 代码只是为了证实我们的观点，并不是真的要这样使用。</p>
</blockquote>
<p data-nodeid="31994">我们再次回到前面提到的错误描述中，如下所示：</p>
<p data-nodeid="31995"><img src="https://s0.lgstatic.com/i/image3/M01/13/A7/Ciqah16gAHWAYR9SAAEyykeZNFk323.png" alt="w3.png" data-nodeid="32159"></p>
<p data-nodeid="31996">这里有一个非常重要的提示：<em data-nodeid="32164">You may need an appropriate loader to handle this file type, currently no loaders are configured to process this file. （我们需要用适当的加载器来处理这种文件类型，而当前并没有配置一个可以用来处理此文件的加载器）。</em></p>
<p data-nodeid="31997">根据这个错误说明，我们发现 Webpack 是用 Loader（加载器）来处理每个模块的，而内部默认的 Loader 只能处理 JS 模块，如果需要加载其他类型的模块就需要配置不同的 Loader。这也就引出了我们今天的主角：Loader。</p>
<p data-nodeid="31998"><img src="https://s0.lgstatic.com/i/image3/M01/13/A8/Ciqah16gAM2AVBOyAACbAmBWOWM473.png" alt="w5.png" data-nodeid="32168"></p>
<h4 data-nodeid="31999">加载器的使用方式</h4>
<p data-nodeid="32000">需要的是一个可以加载 CSS 模块的 Loader，最常用到的是 css-loader。我们需要通过 npm 先去安装这个 Loader，然后在配置文件中添加对应的配置，具体操作和配置如下所示：</p>
<pre class="lang-js" data-nodeid="32001"><code data-language="js">$ npm install css-loader --save-dev 
# or yarn add css-loader --dev
</code></pre>
<pre class="lang-js" data-nodeid="40797"><code data-language="js"><span class="hljs-comment">// ./webpack.config.js</span>
<span class="hljs-built_in">module</span>.exports = &#123;
  <span class="hljs-attr">entry</span>: <span class="hljs-string">'./src/main.css'</span>,
  <span class="hljs-attr">output</span>: &#123;
    <span class="hljs-attr">filename</span>: <span class="hljs-string">'bundle.js'</span>
  &#125;,
  <span class="hljs-attr">module</span>: &#123;
    <span class="hljs-attr">rules</span>: [
      &#123;
        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.css$/</span>, <span class="hljs-comment">// 根据打包过程中所遇到文件路径匹配是否使用这个 loader</span>
        use: <span class="hljs-string">'css-loader'</span> <span class="hljs-comment">// 指定具体的 loader</span>
      &#125;
    ]
  &#125;
&#125;
</code></pre>
<p data-nodeid="40798">在配置对象的 module 属性中添加一个 rules 数组。这个数组就是我们针对资源模块的加载规则配置，其中的每个规则对象都需要设置两个属性：</p>
<ul data-nodeid="40799">
<li data-nodeid="40800">
<p data-nodeid="40801">首先是 test 属性，它是一个正则表达式，用来匹配打包过程中所遇到文件路径，这里我们是以 .css 结尾；</p>
</li>
<li data-nodeid="40802">
<p data-nodeid="40803">然后是 use 属性，它用来指定匹配到的文件需要使用的 loader，这里用到的是 css-loader。</p>
</li>
</ul>
<p data-nodeid="40804">配置完成过后，我们回到命令行终端重新运行打包命令，打包过程就不会再出现错误了，因为这时 CSS 文件会交给 css-loader 处理过后再由 Webpack 打包。</p>
<p data-nodeid="40805"><img src="https://s0.lgstatic.com/i/image3/M01/06/79/CgoCgV6gAQyAVv7XAAAyFU_9fDQ769.png" alt="w6.png" data-nodeid="40934"></p>
<h4 data-nodeid="40806">样式模块加载的问题</h4>
<p data-nodeid="40807">此时，如果你尝试在页面中使用这里输出的 bundle.js 文件，你会发现刚刚的这个 main.css 模块并没有工作。</p>
<p data-nodeid="40808">如果你之前有些经验，可能知道这个问题的解法，其实很简单，只需要再额外添加一个 style-loader，样式就可以正常工作了。</p>
<p data-nodeid="40809">不过只有解法没有原因不是我们的风格。下面我们来分析产生这个问题的真正原因，首先，我们找到刚刚生成的 bundle.js 文件，因为这个文件是 Webpack 打包后的结果，所有的模块都应该在这个文件中出现。</p>
<p data-nodeid="40810">由于默认打包入口在 Webpack 输出的结果中就是第一个模块，所以我们只需要看第一个模块目前是什么样的，如下图所示：</p>
<p data-nodeid="40811"><img src="https://s0.lgstatic.com/i/image3/M01/06/79/CgoCgV6gARSAXyX_AAFkFP2Qek8997.png" alt="w7.png" data-nodeid="40942"></p>
<p data-nodeid="40812">仔细阅读这个文件，你会发现 css-loader 的作用是将 CSS 模块转换为一个 JS 模块，具体的实现方法是将我们的 CSS 代码 push 到一个数组中，这个数组是由 css-loader 内部的一个模块提供的，但是整个过程并没有任何地方使用到了这个数组。</p>
<p data-nodeid="40813">因此这里样式没有生效的原因是： <strong data-nodeid="40948">css-loader 只会把 CSS 模块加载到 JS 代码中，而并不会使用这个模块。</strong></p>
<p data-nodeid="40814">所以这里我们还需要在 css-loader 的基础上再使用一个 style-loader，把 css-loader 转换后的结果通过 style 标签追加到页面上。</p>
<p data-nodeid="40815">安装完 style-loader 之后，我们将配置文件中的 use 属性修改为一个数组，将 style-loader 也放进去。这里需要注意的是，一旦配置多个 Loader，执行顺序是从后往前执行的，所以这里一定要将 css-loader 放在最后，因为必须要 css-loader 先把 CSS 代码转换为 JS 模块，才可以正常打包，具体配置如下：</p>
<pre class="lang-js" data-nodeid="45491"><code data-language="js"><span class="hljs-comment">// ./webpack.config.js</span>
<span class="hljs-built_in">module</span>.exports = &#123;
  <span class="hljs-attr">entry</span>: <span class="hljs-string">'./src/main.css'</span>,
  <span class="hljs-attr">output</span>: &#123;
    <span class="hljs-attr">filename</span>: <span class="hljs-string">'bundle.js'</span>
  &#125;,
  <span class="hljs-attr">module</span>: &#123;
    <span class="hljs-attr">rules</span>: [
      &#123;
        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.css$/</span>,
        <span class="hljs-comment">// 对同一个模块使用多个 loader，注意顺序</span>
        use: [
          <span class="hljs-string">'style-loader'</span>,
          <span class="hljs-string">'css-loader'</span>
        ]
      &#125;
    ]
  &#125;
&#125;
</code></pre>
<p data-nodeid="45492">配置完成之后，再次回到命令行重新打包，此时 bundle.js 文件中会额外多出两个模块。篇幅的关系，我们这里不再仔细解读。<strong data-nodeid="45606">style-loader 的作用总结一句话就是，将 css-loader 中所加载到的所有样式模块，通过创建 style 标签的方式添加到页面上。</strong></p>
<p data-nodeid="45493">以上就是我们对 Loader 使用的一些探索，Loader 是 Webpack 实现整个前端模块化的核心。因为只有通过不同的 Loader，Webpack 才可以实现任何类型资源的加载。</p>
<h4 data-nodeid="45494">通过 JS 加载资源模块</h4>
<p data-nodeid="45495">正如刚刚所提到的，一般 Webpack 打包的入口还是 JavaScript。因为从某种程度上来说，打包入口就是应用的运行入口，而目前前端应用中的业务是由 JS 驱动的，所以更合理的做法还是把 JS 文件作为打包的入口，然后在 JS 代码中通过 import 语句去加载 CSS 文件。</p>
<pre class="lang-js" data-nodeid="45496"><code data-language="js"> └─ <span class="hljs-number">03</span>-webpack-loader ······················· sample root dir
    ├── src ································· source dir
    │   ├── style.css ······················· style <span class="hljs-built_in">module</span>
+   │   └── main.js ························· entry <span class="hljs-built_in">module</span>
    ├── package.json ························ package file
    └── webpack.config.js ··················· webpack config file
</code></pre>
<pre class="lang-js" data-nodeid="45497"><code data-language="js"><span class="hljs-comment">// ./src/main.js</span>
<span class="hljs-keyword">import</span> <span class="hljs-string">'./style.css'</span>


<p><span class="hljs-comment">&#x2F;&#x2F; app logic…</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">‘App starts running~’</span>)<br></code></pre></p>
<p data-nodeid="45498"><img src="https://s0.lgstatic.com/i/image3/M01/06/7A/CgoCgV6gAY2AMxjdAACTY2OYqEw950.png" alt="w8.png" data-nodeid="45612"></p>
<p data-nodeid="45499">即便是通过 JS 代码去加载的 CSS 模块，css-loader 和 style-loader 仍然可以正常工作。因为 Webpack 在打包过程中会循环遍历每个模块，然后根据配置将每个遇到的模块交给对应的 Loader 去处理，最后再将处理完的结果打包到一起。</p>
<h4 data-nodeid="45500">为什么要在 JS 中加载其他资源</h4>
<p data-nodeid="45501">说到这里，你可能会产生疑惑：Webpack 为什么要在 JS 中载入 CSS 呢？不是应该将样式和行为分离么？</p>
<p data-nodeid="45502">其实 Webpack 不仅是建议我们在 JavaScript 中引入 CSS，还会建议我们在代码中引入当前业务所需要的任意资源文件。因为真正需要这个资源的并不是整个应用，而是你此时正在编写的代码。这就是 Webpack 的设计哲学。</p>
<p data-nodeid="45503">可能你乍一想好像不太容易理解，那你可以做一个假设：假设我们在开发页面上的某个局部功能时，需要用到一个样式模块和一个图片文件。如果你还是将这些资源文件单独引入到 HTML 中，然后再到 JS 中添加对应的逻辑代码。试想一下，如果后期这个局部功能不用了，你就需要同时删除 JS 中的代码和 HTML 中的资源文件引入，也就是同时需要维护这两条线。而如果你遵照 Webpack 的这种设计，所有资源的加载都是由 JS 代码控制，后期也就只需要维护 JS 代码这一条线了。</p>
<p data-nodeid="45504">所以说，通过 JavaScript 代码去引入资源文件，或者说是建立 JavaScript 和资源文件的依赖关系，具有明显的优势。因为 JavaScript 代码本身负责完成整个应用的业务功能，放大来说就是驱动了整个前端应用，而 JavaScript 代码在实现业务功能的过程中需要用到样式、图片等资源文件。如果建立这种依赖关系：</p>
<ul data-nodeid="45505">
<li data-nodeid="45506">
<p data-nodeid="45507">一来逻辑上比较合理，因为 JS 确实需要这些资源文件配合才能实现整体功能；</p>
</li>
<li data-nodeid="45508">
<p data-nodeid="45509">二来配合 Webpack 这类工具的打包，能确保在上线时，资源不会缺失，而且都是必要的。</p>
</li>
</ul>
<p data-nodeid="45510">最后说一句题外话，学习新事物不是说学会它的所有用法你就能提高，因为这些照着文档操作基本上谁都可以做到，很多时候它的思想才是突破点。能搞明白新事物为什么这样设计，基本上你就算出道了。</p>
<p data-nodeid="45511">至于其他常用的加载器，我们在理解了 Loader 的机制过后，你可以通过官方的文档自行尝试。这里我罗列了几个开发经常用到的加载器，如下表所示：</p>
<table data-nodeid="45513">
<thead data-nodeid="45514">
<tr data-nodeid="45515">
<th data-org-content="名称" data-nodeid="45517">名称</th>
<th data-org-content="链接" data-nodeid="45518">链接</th>
</tr>
</thead>
<tbody data-nodeid="45521">
<tr data-nodeid="45522">
<td data-org-content="file-loader" data-nodeid="45523">file-loader</td>
<td data-org-content="[https://webpack.js.org/loaders/file-loader](https://webpack.js.org/loaders/file-loader)" data-nodeid="45524"><a target="_blank" rel="noopener" href="https://webpack.js.org/loaders/file-loader" data-nodeid="45628">https://webpack.js.org/loaders/file-loader</a></td>
</tr>
<tr data-nodeid="45525">
<td data-org-content="url-loader" data-nodeid="45526">url-loader</td>
<td data-org-content="[https://webpack.js.org/loaders/url-loader](https://webpack.js.org/loaders/url-loader)" data-nodeid="45527"><a target="_blank" rel="noopener" href="https://webpack.js.org/loaders/url-loader" data-nodeid="45632">https://webpack.js.org/loaders/url-loader</a></td>
</tr>
<tr data-nodeid="45528">
<td data-org-content="babel-loader" data-nodeid="45529">babel-loader</td>
<td data-org-content="[https://webpack.js.org/loaders/babel-loader](https://webpack.js.org/loaders/babel-loader)" data-nodeid="45530"><a target="_blank" rel="noopener" href="https://webpack.js.org/loaders/babel-loader" data-nodeid="45636">https://webpack.js.org/loaders/babel-loader</a></td>
</tr>
<tr data-nodeid="45531">
<td data-org-content="style-loader" data-nodeid="45532">style-loader</td>
<td data-org-content="[https://webpack.js.org/loaders/style-loader](https://webpack.js.org/loaders/style-loader)" data-nodeid="45533"><a target="_blank" rel="noopener" href="https://webpack.js.org/loaders/style-loader" data-nodeid="45640">https://webpack.js.org/loaders/style-loader</a></td>
</tr>
<tr data-nodeid="45534">
<td data-org-content="css-loader" data-nodeid="45535">css-loader</td>
<td data-org-content="[https://webpack.js.org/loaders/css-loader](https://webpack.js.org/loaders/css-loader)" data-nodeid="45536"><a target="_blank" rel="noopener" href="https://webpack.js.org/loaders/css-loader" data-nodeid="45644">https://webpack.js.org/loaders/css-loader</a></td>
</tr>
<tr data-nodeid="45537">
<td data-org-content="sass-loader" data-nodeid="45538">sass-loader</td>
<td data-org-content="[https://webpack.js.org/loaders/sass-loader](https://webpack.js.org/loaders/sass-loader)" data-nodeid="45539"><a target="_blank" rel="noopener" href="https://webpack.js.org/loaders/sass-loader" data-nodeid="45648">https://webpack.js.org/loaders/sass-loader</a></td>
</tr>
<tr data-nodeid="45540">
<td data-org-content="postcss-loader" data-nodeid="45541">postcss-loader</td>
<td data-org-content="[https://webpack.js.org/loaders/postcss-loader](https://webpack.js.org/loaders/postcss-loader)" data-nodeid="45542"><a target="_blank" rel="noopener" href="https://webpack.js.org/loaders/postcss-loader" data-nodeid="45652">https://webpack.js.org/loaders/postcss-loader</a></td>
</tr>
<tr data-nodeid="45543">
<td data-org-content="eslint-loader" data-nodeid="45544">eslint-loader</td>
<td data-org-content="[https://github.com/webpack-contrib/eslint-loader](https://github.com/webpack-contrib/eslint-loader)" data-nodeid="45545"><a target="_blank" rel="noopener" href="https://github.com/webpack-contrib/eslint-loader" data-nodeid="45656">https://github.com/webpack-contrib/eslint-loader</a></td>
</tr>
<tr data-nodeid="45546">
<td data-org-content="vue-loader" data-nodeid="45547">vue-loader</td>
<td data-org-content="[https://github.com/vuejs/vue-loader](https://github.com/vuejs/vue-loader)" data-nodeid="45548"><a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-loader" data-nodeid="45660">https://github.com/vuejs/vue-loader</a></td>
</tr>
</tbody>
</table>
<p data-nodeid="45549">我每接触到一个新的加载器，核心就是搞明白这个 Loader 内部到底做了什么事情，它的目标是什么，其次才是这个 Loader 的配置用法。</p>
<h3 data-nodeid="45550">开发一个 Loader</h3>
<p data-nodeid="45551">Loader 作为 Webpack 的核心机制，内部的工作原理却非常简单。接下来我们一起来开发一个自己的 Loader，通过这个开发过程再来深入了解 Loader 的工作原理。</p>
<p data-nodeid="45552">这里我的需求是开发一个可以加载 markdown 文件的加载器，以便可以在代码中直接导入 md 文件。我们都应该知道 markdown 一般是需要转换为 html 之后再呈现到页面上的，所以我希望导入 md 文件后，直接得到 markdown 转换后的 html 字符串，如下图所示：</p>
<p data-nodeid="45553"><img src="https://s0.lgstatic.com/i/image3/M01/06/7C/CgoCgV6gAraALmckAAAtBxIjIX0476.png" alt="w9.png" data-nodeid="45667"></p>
<p data-nodeid="45554">由于这里需要直观地演示，我就不再单独创建一个 npm 模块，而是就直接在项目根目录下创建一个 markdown-loader.js 文件，完成后你可以把这个模块发布到 npm 上作为一个独立的模块使用。</p>
<p data-nodeid="45555">项目结构与核心代码如下所示：</p>
<pre class="lang-js" data-nodeid="45556"><code data-language="js"> └─ <span class="hljs-number">03</span>-webpack-loader ······················· sample root dir
    ├── src ································· source dir
    │   ├── about.md ························ markdown <span class="hljs-built_in">module</span>
    │   └── main.js ························· entry <span class="hljs-built_in">module</span>
    ├── package.json ························ package file
+   ├── markdown-loader.js ·················· markdown loader
    └── webpack.config.js ··················· webpack config file
</code></pre>
<pre class="lang-js" data-nodeid="45557"><code data-language="js">&lt;!-- ./src/about.md --&gt;
# About


<p>this is a markdown file.<br></code></pre></p>
<pre class="lang-js" data-nodeid="45558"><code data-language="js"><span class="hljs-comment">// ./src/main.js</span>
<span class="hljs-keyword">import</span> about <span class="hljs-keyword">from</span> <span class="hljs-string">'./about.md'</span>


<span class="hljs-built_in">console</span>.log(about)
<span class="hljs-comment">// 希望 about =&gt; '&lt;h1&gt;About&lt;/h1&gt;&lt;p&gt;this is a markdown file.&lt;/p&gt;'</span>
</code></pre>

<p data-nodeid="45559">每个 Webpack 的 Loader 都需要导出一个函数，这个函数就是我们这个 Loader 对资源的处理过程，它的输入就是加载到的资源文件内容，输出就是我们加工后的结果。我们通过 source 参数接收输入，通过返回值输出。这里我们先尝试打印一下 source，然后在函数的内部直接返回一个字符串 <code data-backticks="1" data-nodeid="45671">hello loader ~</code>，具体代码如下所示：</p>
<pre class="lang-js" data-nodeid="45560"><code data-language="js"><span class="hljs-comment">// ./markdown-loader.js</span>
<span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-params">source</span> =&gt;</span> &#123;
  <span class="hljs-comment">// 加载到的模块内容 =&gt; '# About\n\nthis is a markdown file.'</span>
  <span class="hljs-built_in">console</span>.log(source)
  <span class="hljs-comment">// 返回值就是最终被打包的内容</span>
  <span class="hljs-keyword">return</span> <span class="hljs-string">'hello loader ~'</span>
&#125;
</code></pre>
<p data-nodeid="45561">完成以后，我们回到 Webpack 配置文件中添加一个加载器规则，这里匹配到的扩展名是 .md，使用的加载器就是我们刚刚编写的这个 markdown-loader.js 模块，具体代码如下所示：</p>
<pre class="lang-js" data-nodeid="45562"><code data-language="js"><span class="hljs-comment">// ./webpack.config.js</span>
<span class="hljs-built_in">module</span>.exports = &#123;
  <span class="hljs-attr">entry</span>: <span class="hljs-string">'./src/main.js'</span>,
  <span class="hljs-attr">output</span>: &#123;
    <span class="hljs-attr">filename</span>: <span class="hljs-string">'bundle.js'</span>
  &#125;,
  <span class="hljs-attr">module</span>: &#123;
    <span class="hljs-attr">rules</span>: [
      &#123;
        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.md$/</span>,
        <span class="hljs-comment">// 直接使用相对路径</span>
        use: <span class="hljs-string">'./markdown-loader'</span>
      &#125;
    ]
  &#125;
&#125;
</code></pre>
<blockquote data-nodeid="45563">
<p data-nodeid="45564">TIPS：这里的 use 中不仅可以使用模块名称，还可以使用模块文件路径，这点与 Node 中的 require 函数是一样的。</p>
</blockquote>
<p data-nodeid="45565">配置完成后，我们再次打开命令行终端运行打包命令，如下图所示：</p>
<p data-nodeid="45566"><img src="https://s0.lgstatic.com/i/image3/M01/13/AC/Ciqah16gA5-AYUL-AAFjrdy2lKQ113.png" alt="w10.png" data-nodeid="45678"></p>
<p data-nodeid="45567">打包过程中命令行确实打印出来了我们所导入的 Markdown 文件内容，这就意味着 Loader 函数的参数确实是文件的内容。</p>
<p data-nodeid="45568">但同时也报出了一个解析错误，说的是： <em data-nodeid="45684">You may need an additional loader to handle the result of these loaders.（我们可能还需要一个额外的加载器来处理当前加载器的结果）。</em></p>
<p data-nodeid="45569">那这究竟是为什么呢？其实 Webpack 加载资源文件的过程类似于一个工作管道，你可以在这个过程中依次使用多个 Loader，但是最终这个管道结束过后的结果必须是一段标准的 JS 代码字符串。</p>
<p data-nodeid="45570"><img src="https://s0.lgstatic.com/i/image3/M01/06/7D/CgoCgV6gA8SAfv7-AAA9hfxlofw372.png" alt="w11.png" data-nodeid="45688"></p>
<p data-nodeid="45571">所以我们这里才会出现上面提到的错误提示，那解决的办法也就很明显了：</p>
<ul data-nodeid="45572">
<li data-nodeid="45573">
<p data-nodeid="45574"><strong data-nodeid="45693">直接在这个 Loader 的最后返回一段 JS 代码字符串；</strong></p>
</li>
<li data-nodeid="45575">
<p data-nodeid="45576"><strong data-nodeid="45697">再找一个合适的加载器，在后面接着处理我们这里得到的结果。</strong></p>
</li>
</ul>
<p data-nodeid="45577">先来尝试第一种办法。回到 markdown-loader 中，我们将返回的字符串内容修改为 console.log('hello loader~')，然后再次运行打包，此时 Webpack 就不再会报错了，代码如下所示：</p>
<pre class="lang-js" data-nodeid="45578"><code data-language="js"><span class="hljs-comment">// ./markdown-loader.js</span>
<span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-params">source</span> =&gt;</span> &#123;
  <span class="hljs-comment">// 加载到的模块内容 =&gt; '# About\n\nthis is a markdown file.'</span>
  <span class="hljs-built_in">console</span>.log(source)
  <span class="hljs-comment">// 返回值就是最终被打包的内容</span>
  <span class="hljs-comment">// return 'hello loader ~'</span>
  <span class="hljs-keyword">return</span> <span class="hljs-string">'console.log("hello loader ~")'</span>
&#125;
</code></pre>
<p data-nodeid="45579">那此时打包的结果是怎样的呢？我们打开输出的 bundle.js，找到最后一个模块（因为这个 md 文件是后引入的），如下图所示：</p>
<p data-nodeid="45580"><img src="https://s0.lgstatic.com/i/image3/M01/06/7E/CgoCgV6gA_mAVyS1AADwR_o4vW0140.png" alt="w12.png" data-nodeid="45707"></p>
<p data-nodeid="45581">这个模块里面非常简单，就是把我们刚刚返回的字符串直接拼接到了该模块中。这也解释了刚刚 Loader 管道最后必须返回 JS 代码的原因，因为如果随便返回一个内容，放到这里语法就不通过了。</p>
<h4 data-nodeid="45582">实现 Loader 的逻辑</h4>
<p data-nodeid="45583">了解了 Loader 大致的工作机制过后，我们再回到 markdown-loader.js 中，接着完成我的需求。这里需要安装一个能够将 Markdown 解析为 HTML 的模块，叫作 marked。</p>
<p data-nodeid="45584">安装完成后，我们在 markdown-loader.js 中导入这个模块，然后使用这个模块去解析我们的 source。这里解析完的结果就是一段 HTML 字符串，如果我们直接返回的话同样会面临 Webpack 无法解析模块的问题，正确的做法是把这段 HTML 字符串拼接为一段 JS 代码。</p>
<p data-nodeid="45585">此时我们希望返回的代码是通过 module.exports 导出这段 HTML 字符串，这样外界导入模块时就可以接收到这个 HTML 字符串了。如果只是简单地拼接，那 HTML 中的换行和引号就都可能会造成语法错误，所以我这里使用了一个小技巧，具体操作如下所示：</p>
<pre class="lang-js" data-nodeid="45586"><code data-language="js"><span class="hljs-comment">// ./markdown-loader.js</span>
<span class="hljs-keyword">const</span> marked = <span class="hljs-built_in">require</span>(<span class="hljs-string">'marked'</span>)


<p><span class="hljs-built_in">module</span>.exports &#x3D; <span class="hljs-function"><span class="hljs-params">source</span> &#x3D;&gt;</span> &#123;<br>  <span class="hljs-comment">&#x2F;&#x2F; 1. 将 markdown 转换为 html 字符串</span><br>  <span class="hljs-keyword">const</span> html &#x3D; marked(source)<br>  <span class="hljs-comment">&#x2F;&#x2F; html &#x3D;&gt; ‘&lt;h1&gt;About&lt;&#x2F;h1&gt;&lt;p&gt;this is a markdown file.&lt;&#x2F;p&gt;’</span><br>  <span class="hljs-comment">&#x2F;&#x2F; 2. 将 html 字符串拼接为一段导出字符串的 JS 代码</span><br>  <span class="hljs-keyword">const</span> code &#x3D; <span class="hljs-string"><code>module.exports = &lt;span class=&quot;hljs-subst&quot;&gt;$&#123;&lt;span class=&quot;hljs-built_in&quot;&gt;JSON&lt;/span&gt;.stringify(html)&#125;&lt;/span&gt;</code></span><br>  <span class="hljs-keyword">return</span> code<br>  <span class="hljs-comment">&#x2F;&#x2F; code &#x3D;&gt; ‘export default “&lt;h1&gt;About&lt;&#x2F;h1&gt;&lt;p&gt;this is a markdown file.&lt;&#x2F;p&gt;”‘</span><br>}<br></code></pre></p>
<p data-nodeid="45587">先通过 JSON.stringify() 将字段字符串转换为标准的 JSON 字符串，然后再参与拼接，这样就不会有问题了。</p>
<p data-nodeid="45588">我们回到命令行再次运行打包，打包后的结果就是我们所需要的了。</p>
<p data-nodeid="45589">除了 module.exports 这种方式，Webpack 还允许我们在返回的代码中使用 ES Modules 的方式导出，例如，我们这里将 module.exports 修改为 export default，然后运行打包，结果同样是可以的，Webpack 内部会自动转换 ES Modules 代码。</p>
<pre class="lang-js" data-nodeid="45590"><code data-language="js"><span class="hljs-comment">// ./markdown-loader.js</span>
<span class="hljs-keyword">const</span> marked = <span class="hljs-built_in">require</span>(<span class="hljs-string">'marked'</span>)


<p><span class="hljs-built_in">module</span>.exports &#x3D; <span class="hljs-function"><span class="hljs-params">source</span> &#x3D;&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> html &#x3D; marked(source)<br>  <span class="hljs-comment">&#x2F;&#x2F; const code &#x3D; <code>module.exports = $&#123;JSON.stringify(html)&#125;</code></span><br>  <span class="hljs-keyword">const</span> code &#x3D; <span class="hljs-string"><code>export default &lt;span class=&quot;hljs-subst&quot;&gt;$&#123;&lt;span class=&quot;hljs-built_in&quot;&gt;JSON&lt;/span&gt;.stringify(html)&#125;&lt;/span&gt;</code></span><br>  <span class="hljs-keyword">return</span> code<br>}<br></code></pre></p>
<h4 data-nodeid="45591">多个 Loader 的配合</h4>
<p data-nodeid="45592">我们还可以尝试一下刚刚说的第二种思路，就是在我们这个 markdown-loader 中直接返回 HTML 字符串，然后交给下一个 Loader 处理。这就涉及多个 Loader 相互配合工作的情况了。</p>
<p data-nodeid="45593">我们回到代码中，这里我们直接返回 marked 解析后的 HTML，代码如下所示：</p>
<pre class="lang-js" data-nodeid="45594"><code data-language="js"><span class="hljs-comment">// ./markdown-loader.js</span>
<span class="hljs-keyword">const</span> marked = <span class="hljs-built_in">require</span>(<span class="hljs-string">'marked'</span>)


<p><span class="hljs-built_in">module</span>.exports &#x3D; <span class="hljs-function"><span class="hljs-params">source</span> &#x3D;&gt;</span> &#123;<br>  <span class="hljs-comment">&#x2F;&#x2F; 1. 将 markdown 转换为 html 字符串</span><br>  <span class="hljs-keyword">const</span> html &#x3D; marked(source)<br>  <span class="hljs-keyword">return</span> html<br>&#125;<br></code></pre></p>
<p data-nodeid="45595">然后我们再安装一个处理 HTML 的 Loader，叫作 html-loader，代码如下所示：</p>
<pre class="lang-js" data-nodeid="45596"><code data-language="js"><span class="hljs-comment">// ./webpack.config.js</span>
<span class="hljs-built_in">module</span>.exports = &#123;
  <span class="hljs-attr">entry</span>: <span class="hljs-string">'./src/main.js'</span>,
  <span class="hljs-attr">output</span>: &#123;
    <span class="hljs-attr">filename</span>: <span class="hljs-string">'bundle.js'</span>,
  &#125;,
  <span class="hljs-attr">module</span>: &#123;
    <span class="hljs-attr">rules</span>: [
      &#123;
        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.md$/</span>,
        use: [
          <span class="hljs-string">'html-loader'</span>,
          <span class="hljs-string">'./markdown-loader'</span>
        ]
      &#125;
    ]
  &#125;
&#125;
</code></pre>
<p data-nodeid="45597">安装完成过后回到配置文件，这里同样把 use 属性修改为一个数组，以便依次使用多个 Loader。不过同样需要注意，这里的执行顺序是从后往前，也就是说我们应该把先执行的 markdown-loader 放在后面，html-loader 放在前面。</p>
<p data-nodeid="45598">完成以后我们回到命令行终端再次打包，这里的打包结果仍然是可以的。</p>
<p data-nodeid="45599">至此，我们就完成了这个 markdown-loader 模块，其实整个过程重点在于 Loader 的工作原理和实现方式。</p>
<h3 data-nodeid="45600">写在最后</h3>
<p data-nodeid="45601">总体来说，Loader 机制是 Webpack 最核心的机制，因为正是有了 Loader 机制，Webpack 才能足以支撑整个前端项目模块化的大梁，实现通过 Webpack 去加载任何你想要加载的资源。</p>

<hr>
<h3 id="精选评论"><a href="#精选评论" class="headerlink" title="精选评论"></a>精选评论</h3><h5 id="红："><a href="#红：" class="headerlink" title="**红："></a>**红：</h5><blockquote>
<p>既学到了原理细节，又学到了思想，知识讲述清晰且完整，赞👍</p>
</blockquote>
<h5 id="wjk："><a href="#wjk：" class="headerlink" title="wjk："></a>wjk：</h5><blockquote>
<p>看到这个位置，我觉得可以把我的赞奉上了😀</p>
</blockquote>
<h5 id="超："><a href="#超：" class="headerlink" title="*超："></a>*超：</h5><blockquote>
<p>很详细，期待更新！</p>
</blockquote>
<h5 id="宇："><a href="#宇：" class="headerlink" title="*宇："></a>*宇：</h5><blockquote>
<p>‘webpack文件内部去实现按需加载’，如果时一个vue项目中的某个组件，本来css文件和他就是强绑定的，这个按需加载是不是就没有意义了？是不是vue本来就实现了模块化的概念了？老师可以解释下vue项目的这个情况吗？谢谢～</p>
</blockquote>
<h5 id="栋："><a href="#栋：" class="headerlink" title="**栋："></a>**栋：</h5><blockquote>
<p>磊哥这个语速有点可爱啊 听着很不习惯 哈哈</p>
</blockquote>
<h5 id="强："><a href="#强：" class="headerlink" title="*强："></a>*强：</h5><blockquote>
<p>loader导出的模块是都要返回一段可执行的 js 代码么？</p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-讲师回复："><a href="#amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; 也不一定，比如 less-loader 返回的就是 css，再交给下一个 loader 处理，只是最后一个 loader 必须要返回 JS 代码，</p>
</blockquote>
<h5 id="根："><a href="#根：" class="headerlink" title="**根："></a>**根：</h5><blockquote>
<p>写的贼好，支持</p>
</blockquote>
<h5 id="鸣："><a href="#鸣：" class="headerlink" title="**鸣："></a>**鸣：</h5><blockquote>
<div>老师，您好。关于下面这部分：</div>`如果你还是将这些资源文件单独引入到 HTML 中，然后再到 JS 中添加对应的逻辑代码。试想一下，如果后期这个局部功能不用了，你就需要同时删除 JS 中的代码和 HTML 中的资源文件引入，也就是同时需要维护这两条线。而如果你遵照 Webpack 的这种设计，所有资源的加载都是由 JS 代码控制，后期也就只需要维护 JS 代码这一条线了。`<div>能不能举一个实际的场景说明呢？还是不太明白</div>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-1"><a href="#amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-1" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; 这种实际上就是多年开发总结下来的心得，简单来说就是降低耦合。硬是要举个例子也很简单，假设你去开发一个列表功能，在这个功能开发中肯定需要添加相关的 CSS 样式，然后再添加相应的逻辑代码。这种情况下你可以把这个样式文件单独引用到 HTML 页面上，那这时候你的逻辑代码实际上就强依赖这个引入的 CSS，而依赖的东西应该交给内部管理，而不是外部</p>
</blockquote>
<h5 id="玲："><a href="#玲：" class="headerlink" title="**玲："></a>**玲：</h5><blockquote>
<p>很厉害</p>
</blockquote>
<h5 id="发："><a href="#发：" class="headerlink" title="**发："></a>**发：</h5><blockquote>
<div>入口文件是一个css，如果想出口文件也是一个真正的css，目前我是通过MiniCssExtractPlugin去从已经转成js格式的chunk里面把css抽取出来，然后ouput出口设置的filename和<span style="font-size: 0.427rem; -webkit-text-size-adjust: 100%;">MiniCssExtractPlugin设置的一致，这样处理虽说能实现，但是会有两个chunk输出到同一个模块的提示，想请教下老师有没有其他骚操作也能处理的</span></div>😂
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-2"><a href="#amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-2" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; 自己写一个插件，把输出的 JS 删掉，偷笑～</p>
</blockquote>
<h5 id="发：-1"><a href="#发：-1" class="headerlink" title="**发："></a>**发：</h5><blockquote>
<p>入口文件是一个css，如果想出口文件也是一个真正的css怎么处理了，不能是一个伪css</p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-3"><a href="#amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-3" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; 可以用 mini-css-extract-plugin 插件提取</p>
</blockquote>
<h5 id="力："><a href="#力：" class="headerlink" title="**力："></a>**力：</h5><blockquote>
<p>请问怎么调试别人的loader（比如html-loader），我想看看他们的loader实现原理。</p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-4"><a href="#amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-4" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; 第三方 Loader 的调试方式跟自定义 Loader 一样，可以直接调试 node_modules 中的代码，也可以把源码拿出来引入</p>
</blockquote>
<h5 id="gts："><a href="#gts：" class="headerlink" title="gts："></a>gts：</h5><blockquote>
<p>老师，为什么loader是倒着执行的</p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-5"><a href="#amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-5" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; 这个没有为什么，Webpack 内部就是这么约定的</p>
</blockquote>
<h5 id="Sept："><a href="#Sept：" class="headerlink" title="Sept："></a>Sept：</h5><blockquote>
<p>方法一：const code &#x3D; <code>module.exports = $&#123;JSON.stringify(html)&#125;</code>；方法二：const code &#x3D; <code>export default $&#123;JSON.stringify(html)&#125;</code>；这两种导出的code打包后在.&#x2F;src&#x2F;about.md中log输出，方法一是个空对象，方法二是正常的html字符串；文中提到Webpack 内部会自动转换 ES Modules 代码，请问老师会什么两种导出结果不一致？关于这点不是很明白</p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-6"><a href="#amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-6" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; export default 最终转换为 commonjs 过后，具体的值是挂载在导出对象的 default 属性上</p>
</blockquote>
<h5 id="兵："><a href="#兵：" class="headerlink" title="**兵："></a>**兵：</h5><blockquote>
<p>挺棒的，通俗易懂</p>
</blockquote>
<h5 id="洋："><a href="#洋：" class="headerlink" title="*洋："></a>*洋：</h5><blockquote>
<p>通俗易懂，给个赞</p>
</blockquote>
<h5 id="宽："><a href="#宽：" class="headerlink" title="*宽："></a>*宽：</h5><blockquote>
<p>学习新事物不是说学会它的所有用法你就能提高，因为这些照着文档操作基本上谁都可以做到，很多时候它的思想才是突破点。能搞明白新事物为什么这样设计，基本上你就算出道了。汪磊老师真厉害！！！</p>
</blockquote>
<h5 id="丽："><a href="#丽：" class="headerlink" title="*丽："></a>*丽：</h5><blockquote>
<p>浅显易懂，谢谢🙏</p>
</blockquote>
<h5 id="苒："><a href="#苒：" class="headerlink" title="*苒："></a>*苒：</h5><blockquote>
<p>这是目前我看过最好的webpack教程了，真的教给了我们真正想要的东西，赞</p>
</blockquote>
<h5 id="达："><a href="#达：" class="headerlink" title="**达："></a>**达：</h5><blockquote>
<p>牛逼🐮，说得很明白</p>
</blockquote>
<h5 id="哈："><a href="#哈：" class="headerlink" title="**哈："></a>**哈：</h5><blockquote>
<p>一切皆模块！webpack默认不仅可以处理js文件，还可以处理json文件。</p>
</blockquote>
<h5 id="zhanglong："><a href="#zhanglong：" class="headerlink" title="zhanglong："></a>zhanglong：</h5><blockquote>
<p>期待下集</p>
</blockquote>
<h5 id="辉："><a href="#辉：" class="headerlink" title="*辉："></a>*辉：</h5><blockquote>
<p>期待更新</p>
</blockquote>
<h5 id="洋：-1"><a href="#洋：-1" class="headerlink" title="**洋："></a>**洋：</h5><blockquote>
<div style="color: rgb(212, 212, 212); background-color: rgb(30, 30, 30); font-family: Consolas, &quot;Courier New&quot;, monospace; font-size: 14px; line-height: 19px; white-space: pre;"><span style="color: #ce9178;">bundles.js 文件没有生成是怎么回事 </span></div>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-7"><a href="#amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-7" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; 同学，你的问题能不能再多描述一下，这样的问题我有心无力啊，啊啊啊</p>
</blockquote>
<h5 id="用户2221："><a href="#用户2221：" class="headerlink" title="**用户2221："></a>**用户2221：</h5><blockquote>
<p>对于webpack ，js 源码更像是一个“记账本”了，记录了所有资源，便于webpack查找处理，生成最后的可执行文件，万物皆模块，是因为万物皆可记录。<div><br></div><div>作者讲的真不错</div></p>
</blockquote>
<h5 id="勇："><a href="#勇：" class="headerlink" title="*勇："></a>*勇：</h5><blockquote>
<p>很棒！讲的很清晰</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/11/02/%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87-Loader-%E5%AE%9E%E7%8E%B0%E7%89%B9%E6%AE%8A%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD%EF%BC%9F/" data-id="claxeera20015v8w167bh6cy9" data-title="如何通过 Loader 实现特殊资源加载？" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-如何使用-Webpack-实现模块化打包？" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/11/02/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-Webpack-%E5%AE%9E%E7%8E%B0%E6%A8%A1%E5%9D%97%E5%8C%96%E6%89%93%E5%8C%85%EF%BC%9F/" class="article-date">
  <time class="dt-published" datetime="2022-11-02T11:35:57.000Z" itemprop="datePublished">2022-11-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/11/02/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-Webpack-%E5%AE%9E%E7%8E%B0%E6%A8%A1%E5%9D%97%E5%8C%96%E6%89%93%E5%8C%85%EF%BC%9F/">如何使用 Webpack 实现模块化打包？</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p data-nodeid="9319" class="">相信通过上一课时内容的学习，你应该对前端模块化有了更完整的认识。在上一课时的最后我们提出了对模块化打包方案或工具的设想或者说是诉求：</p>
<ul data-nodeid="9320">
<li data-nodeid="9321">
<p data-nodeid="9322">能够将散落的模块打包到一起；</p>
</li>
<li data-nodeid="9323">
<p data-nodeid="9324">能够编译代码中的新特性；</p>
</li>
<li data-nodeid="9325">
<p data-nodeid="9326">能够支持不同种类的前端资源模块。</p>
</li>
</ul>
<p data-nodeid="9327"><img src="https://s0.lgstatic.com/i/image3/M01/04/CD/CgoCgV6dE8qATeN7AAHuGzEsqjI585.png" alt="1.png" data-nodeid="9446"></p>
<p data-nodeid="9328">目前，前端领域有一些工具能够很好的满足以上这 3 个需求，其中最为主流的就是 Webpack、Parcel 和 Rollup，我们以 Webpack 为例：</p>
<ul data-nodeid="9329">
<li data-nodeid="9330">
<p data-nodeid="9331">Webpack 作为一个模块打包工具，本身就可以解决模块化代码打包的问题，将零散的 JavaScript 代码打包到一个 JS 文件中。</p>
</li>
<li data-nodeid="9332">
<p data-nodeid="9333">对于有环境兼容问题的代码，Webpack 可以在打包过程中通过 Loader 机制对其实现编译转换，然后再进行打包。</p>
</li>
<li data-nodeid="9334">
<p data-nodeid="9335">对于不同类型的前端模块类型，Webpack 支持在 JavaScript 中以模块化的方式载入任意类型的资源文件，例如，我们可以通过 Webpack 实现在 JavaScript 中加载 CSS 文件，被加载的 CSS 文件将会通过 style 标签的方式工作。</p>
</li>
</ul>
<p data-nodeid="9336">除此之外，Webpack 还具备代码拆分的能力，它能够将应用中所有的模块按照我们的需要分块打包。这样一来，就不用担心全部代码打包到一起，产生单个文件过大，导致加载慢的问题。我们可以把应用初次加载所必需的模块打包到一起，其他的模块再单独打包，等到应用工作过程中实际需要用到某个模块，再异步加载该模块，实现增量加载，或者叫作渐进式加载，非常适合现代化的大型 Web 应用。</p>
<p data-nodeid="9337">当然，除了 Webpack，其他的打包工具也都类似，总之，所有的打包工具都是以实现模块化为目标，让我们可以在开发阶段更好的享受模块化带来的优势，同时又不必担心模块化在生产环境中产生新的问题。</p>
<h3 data-nodeid="9338">Webpack 快速上手</h3>
<p data-nodeid="9339">Webpack 作为目前最主流的前端模块打包器，提供了一整套前端项目模块化方案，而不仅仅局限于对 JavaScript 的模块化。通过 Webpack，我们可以轻松的对前端项目开发过程中涉及的所有资源进行模块化。</p>
<p data-nodeid="9340">因为 Webpack 的设计思想比较先进，起初的使用过程比较烦琐，再加上文档也晦涩难懂，所以在最开始的时候，Webpack 对开发者并不友好，但是随着版本的迭代，官方文档的不断更新，目前 Webpack 对开发者已经非常友好了。此外，随着 React 和 Vue.js 这类框架的普及，Webpack 也随之受到了越来越多的关注，现阶段可以覆盖绝大多数现代 Web 应用的开发过程。</p>
<p data-nodeid="9341">接下来我将通过一个案例，带你快速了解 Webpack 的基本使用，具体操作如下所示：</p>
<pre class="lang-js" data-nodeid="9342"><code data-language="js">└─ <span class="hljs-number">02</span>-configuation
   ├── src
   │   ├── heading.js
   │   └── index.js
   └── index.html
</code></pre>
<pre class="lang-js" data-nodeid="9343"><code data-language="js"><span class="hljs-comment">// ./src/heading.js</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> () =&gt; &#123;
  <span class="hljs-keyword">const</span> element = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'h2'</span>)
  element.textContent = <span class="hljs-string">'Hello webpack'</span>
  element.addEventListener(<span class="hljs-string">'click'</span>, <span class="hljs-function">() =&gt;</span> alert(<span class="hljs-string">'Hello webpack'</span>))
  <span class="hljs-keyword">return</span> element
&#125;
</code></pre>
<pre class="lang-js" data-nodeid="9344"><code data-language="js"><span class="hljs-comment">// ./src/index.js</span>
<span class="hljs-keyword">import</span> createHeading <span class="hljs-keyword">from</span> <span class="hljs-string">'./heading.js'</span>
<span class="hljs-keyword">const</span> heading = createHeading()
<span class="hljs-built_in">document</span>.body.append(heading)
</code></pre>
<pre class="lang-js" data-nodeid="9345"><code data-language="js">&lt;!DOCTYPE html&gt;
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Webpack - 快速上手<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"module"</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"src/index.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</span></code></pre>
<blockquote data-nodeid="9346">
<p data-nodeid="9347">P.S. type="module" 这种用法是 ES Modules 中提出的标准，用来区分加载的是一个普通 JS 脚本还是一个模块。</p>
</blockquote>
<p data-nodeid="9348">在上面这个案例中，我们创建了两个 JS 文件，其中 heading.js 中以 ES Modules 的方式导出了一个创建元素的函数，然后在 index.js 中导入 heading.js 并使用了这个模块，最后在 html 文件中通过 script 标签，以模块化的方式引入了 index.js，</p>
<p data-nodeid="9349">按照 ES Modules 的标准，这里的 index.html 可以直接在浏览器中正常工作，但是对于不支持 ES Modules 标准的浏览器，直接使用就会出现错误，所以我们需要使用 Webpack 这样的工具，将我们这里按照模块化方式拆分的 JS 代码再次打包到一起。</p>
<p data-nodeid="9350">接下来我们就尝试引入 Webpack 去处理上述案例中的 JS 模块打包。由于 Webpack 是一个 npm 工具模块，所以我们先初始化一个 package.json 文件，用来管理 npm 依赖版本，完成之后，再来安装 Webpack 的核心模块以及它的 CLI 模块，具体操作如下：</p>
<pre class="lang-js" data-nodeid="9351"><code data-language="js">$ npm init --yes
$ npm i webpack webpack-cli --save-dev
</code></pre>
<blockquote data-nodeid="9352">
<p data-nodeid="9353">P.S. webpack 是 Webpack 的核心模块，webpack-cli 是 Webpack 的 CLI 程序，用来在命令行中调用 Webpack。</p>
</blockquote>
<p data-nodeid="9354">安装完成之后，webpack-cli 所提供的 CLI 程序就会出现在 node_modules/.bin 目录当中，我们可以通过 npx 快速找到 CLI 并运行它，具体操作如下：</p>
<pre class="lang-js" data-nodeid="9355"><code data-language="js">$ npx webpack --version
v4<span class="hljs-number">.42</span><span class="hljs-number">.1</span>
</code></pre>
<blockquote data-nodeid="9356">
<p data-nodeid="9357">P.S. npx 是 npm 5.2 以后新增的一个命令，可以用来更方便的执行远程模块或者项目 node_modules 中的 CLI 程序。</p>
</blockquote>
<p data-nodeid="9358">这里我们使用的 Webpack 版本是 v4.42.1，有了 Webpack 后，就可以直接运行 webpack 命令来打包 JS 模块代码，具体操作如下：</p>
<pre class="lang-js" data-nodeid="9359"><code data-language="js">$ npx webpack
</code></pre>
<p data-nodeid="9360">这个命令在执行的过程中，Webpack 会自动从 src/index.js 文件开始打包，然后根据代码中的模块导入操作，自动将所有用到的模块代码打包到一起。</p>
<p data-nodeid="9361">完成之后，控制台会提示：顺着 index.js 有两个 JS 文件被打包到了一起。与之对应的就是项目的根目录下多出了一个 dist 目录，我们的打包结果就存放在这个目录下的 main.js 文件中，具体操作如下图所示：</p>
<p data-nodeid="9362"><img src="https://s0.lgstatic.com/i/image3/M01/11/FC/Ciqah16dFAaAMNccAADOAanBuOA265.png" alt="2.png" data-nodeid="9477"></p>
<p data-nodeid="9363">这里我们回到 index.html 中修改引入文件的路径，由于打包后的代码就不会再有 import 和 export 了，所以我们可以删除 type="module"。再次回到浏览器中，查看这个页面，这时我们的代码仍然可以正常工作，index.html 的代码如下所示：</p>
<pre class="lang-js" data-nodeid="9364"><code data-language="js">&lt;!DOCTYPE html&gt;
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Webpack - 快速上手<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"dist/main.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</span></code></pre>
<p data-nodeid="9365">我们也可以将 Webpack 命令定义到 npm scripts 中，这样每次使用起来会更加方便，具体如下：</p>
<pre class="lang-js" data-nodeid="9366"><code data-language="js">&#123;
  <span class="hljs-string">"name"</span>: <span class="hljs-string">"01-getting-started"</span>,
  <span class="hljs-string">"version"</span>: <span class="hljs-string">"0.1.0"</span>,
  <span class="hljs-string">"main"</span>: <span class="hljs-string">"n/a"</span>,
  <span class="hljs-string">"author"</span>: <span class="hljs-string">"zce &lt;w@zce.me&gt; (https://zce.me)"</span>,
  <span class="hljs-string">"license"</span>: <span class="hljs-string">"MIT"</span>,
  <span class="hljs-string">"scripts"</span>: &#123;
    <span class="hljs-string">"build"</span>: <span class="hljs-string">"webpack"</span>
  &#125;,
  <span class="hljs-string">"devDependencies"</span>: &#123;
    <span class="hljs-string">"webpack"</span>: <span class="hljs-string">"^4.42.1"</span>,
    <span class="hljs-string">"webpack-cli"</span>: <span class="hljs-string">"^3.3.11"</span>
  &#125;
&#125;
</code></pre>
<p data-nodeid="9367">对于 Webpack 最基本的使用，总结下来就是：先安装 webpack 相关的 npm 包，然后使用 webpack-cli 所提供的命令行工具进行打包。</p>
<h3 data-nodeid="9368">配置 Webpack 的打包过程</h3>
<p data-nodeid="9369">Webpack 4 以后的版本支持零配置的方式直接启动打包，整个过程会按照约定将 src/index.js 作为打包入口，最终打包的结果会存放到 dist/main.js 中。</p>
<p data-nodeid="9370">但很多时候我们需要自定义这些路径约定，例如，在下面这个案例中，我需要它的打包入口是 src/main.js，那此时我们通过配置文件的方式修改 Webpack 的默认配置，在项目的根目录下添加一个 webpack.config.js，具体结构如下：</p>
<pre class="lang-js" data-nodeid="9371"><code data-language="js"> └─ <span class="hljs-number">02</span>-configuation
    ├── src
    │ ├── heading.js
    │ └── main.js
    ├── index.html
    ├── package.json
+   └── webpack.config.js ···················· Webpack 配置文件
</code></pre>
<p data-nodeid="9372">webpack.config.js 是一个运行在 Node.js 环境中的 JS 文件，也就是说我们需要按照 CommonJS 的方式编写代码，这个文件可以导出一个对象，我们可以通过所导出对象的属性完成相应的配置选项。</p>
<p data-nodeid="9373">这里先尝试添加一个 entry 属性，这个属性的作用就是指定 Webpack 打包的入口文件路径。我们将其设置为 src/main.js，具体代码如下所示：</p>
<pre class="lang-js" data-nodeid="9374"><code data-language="js"><span class="hljs-comment">// ./webpack.config.js</span>
<span class="hljs-built_in">module</span>.exports = &#123;
  <span class="hljs-attr">entry</span>: <span class="hljs-string">'./src/main.js'</span>
&#125;
</code></pre>
<p data-nodeid="9375">配置完成之后，回到命令行终端重新运行打包命令，此时 Webpack 就会从 src/main.js 文件开始打包。</p>
<p data-nodeid="9376">除了 entry 的配置以外，我们还可以通过 output 属性设置输出文件的位置。output 属性的值必须是一个对象，通过这个对象的 filename 指定输出文件的文件名称，path 指定输出的目录，具体代码如下所示：</p>
<pre class="lang-js" data-nodeid="9377"><code data-language="js"><span class="hljs-comment">// ./webpack.config.js</span>
<span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>)


<p><span class="hljs-built_in">module</span>.exports &#x3D; &#123;<br>  <span class="hljs-attr">entry</span>: <span class="hljs-string">‘.&#x2F;src&#x2F;main.js’</span>,<br>  <span class="hljs-attr">output</span>: &#123;<br>    <span class="hljs-attr">filename</span>: <span class="hljs-string">‘bundle.js’</span>,<br>    <span class="hljs-attr">path</span>: path.join(__dirname, <span class="hljs-string">‘output’</span>)<br>  &#125;<br>&#125;<br></code></pre></p>
<p data-nodeid="9378">TIPS：webpack.config.js 是运行在 Node.js 环境中的代码，所以直接可以使用 path 之类的 Node.js 内置模块。</p>
<p data-nodeid="9379">由于 Webpack 支持的配置有很多，篇幅的关系，这里我们就不一一介绍了，详细的文档你可以在 Webpack 的官网中找到：<a target="_blank" rel="noopener" href="https://webpack.js.org/configuration/#options" data-nodeid="9496">https://webpack.js.org/configuration/#options</a></p>
<h4 data-nodeid="9380">让配置文件支持智能提示</h4>
<p data-nodeid="9381">在这里，我想跟你分享我在编写 Webpack 配置文件时用过的一个小技巧，因为 Webpack 的配置项比较多，而且很多选项都支持不同类型的配置方式。如果你刚刚接触 Webpack 的配置，这些配置选项一定会让你感到头大。如果开发工具能够为 Webpack 配置文件提供智能提示的话，这种痛苦就会减小很多，配置起来，效率和准确度也会大大提高。</p>
<p data-nodeid="9382">我们知道， VSCode 对于代码的自动提示是根据成员的类型推断出来的，换句话说，如果 VSCode 知道当前变量的类型，就可以给出正确的智能提示。即便你没有使用 TypeScript 这种类型友好的语言，也可以通过类型注释的方式去标注变量的类型。</p>
<p data-nodeid="9383">默认 VSCode 并不知道 Webpack 配置对象的类型，我们通过 import 的方式导入 Webpack 模块中的 Configuration 类型，然后根据类型注释的方式将变量标注为这个类型，这样我们在编写这个对象的内部结构时就可以有正确的智能提示了，具体代码如下所示：</p>
<pre class="lang-js" data-nodeid="9384"><code data-language="js"><span class="hljs-comment">// ./webpack.config.js</span>
<span class="hljs-keyword">import</span> &#123; Configuration &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'webpack'</span>


<p><span class="hljs-comment">&#x2F;**</p>
<ul>
<li><span class="hljs-doctag">@type <span class="hljs-type">&#123;Configuration&#125;</span></span><br>*&#x2F;</span><br><span class="hljs-keyword">const</span> config &#x3D; &#123;<br>  <span class="hljs-attr">entry</span>: <span class="hljs-string">‘.&#x2F;src&#x2F;index.js’</span>,<br>  <span class="hljs-attr">output</span>: &#123;<br><span class="hljs-attr">filename</span>: <span class="hljs-string">‘bundle.js’</span><br>  &#125;<br>&#125;</li>
</ul>
<p><span class="hljs-built_in">module</span>.exports &#x3D; config<br></code></pre></p>
<p data-nodeid="9385">需要注意的是：我们添加的 import 语句只是为了导入 Webpack 配置对象的类型，这样做的目的是为了标注 config 对象的类型，从而实现智能提示。在配置完成后一定要记得注释掉这段辅助代码，因为在 Node.js 环境中默认还不支持 import 语句，如果执行这段代码会出现错误。</p>
<pre class="lang-js" data-nodeid="9386"><code data-language="js"><span class="hljs-comment">// ./webpack.config.js</span>


<p><span class="hljs-comment">&#x2F;&#x2F; 一定记得运行 Webpack 前先注释掉这里。</span><br><span class="hljs-comment">&#x2F;&#x2F; import &#123; Configuration &#125; from ‘webpack’ </span></p>
<p><span class="hljs-comment">&#x2F;**</p>
<ul>
<li><span class="hljs-doctag">@type <span class="hljs-type">&#123;Configuration&#125;</span></span><br>*&#x2F;</span><br><span class="hljs-keyword">const</span> config &#x3D; &#123;<br>  <span class="hljs-attr">entry</span>: <span class="hljs-string">‘.&#x2F;src&#x2F;index.js’</span>,<br>  <span class="hljs-attr">output</span>: &#123;<br><span class="hljs-attr">filename</span>: <span class="hljs-string">‘bundle.js’</span><br>  &#125;<br>&#125;</li>
</ul>
<p><span class="hljs-built_in">module</span>.exports &#x3D; config<br></code></pre></p>
<p data-nodeid="9387">没有智能提示的效果，如下所示：<br>
<img src="https://s0.lgstatic.com/i/image3/M01/8B/55/Cgq2xl6dX_6AS601AGOWR9tvy7w230.gif" alt="没有智能提示.gif" data-nodeid="9506"></p>
<p data-nodeid="10565">加上类型标注实现智能提示的效果，如下所示：<br>
<img src="https://s0.lgstatic.com/i/image3/M01/05/10/CgoCgV6dX8WAT4jvAJhTWS1vldA516.gif" alt="加上智能提示.gif" data-nodeid="10580"></p>
<p data-nodeid="11165">使用&nbsp;import&nbsp;语句导入&nbsp;Configuration&nbsp;类型的方式固然好理解，但是在不同的环境中还是会有各种各样的问题，例如我们这里在 Node.js 环境中，就必须要额外注释掉这个导入类型的语句，才能正常工作。</p>
<p data-nodeid="11727">所以我一般的做法是直接在类型注释中使用&nbsp;import&nbsp;动态导入类型，具体代码如下：</p>
<pre class="lang-javascript" data-nodeid="11728"><code data-language="javascript"><span class="hljs-comment">// ./webpack.config.js</span>
<span class="hljs-comment">/** <span class="hljs-doctag">@type <span class="hljs-type">&#123;import('webpack').Configuration&#125;</span> </span>*/</span>
<span class="hljs-keyword">const</span> config = &#123;
  <span class="hljs-attr">entry</span>: <span class="hljs-string">'./src/index.js'</span>,
  <span class="hljs-attr">output</span>: &#123;
    <span class="hljs-attr">filename</span>: <span class="hljs-string">'bundle.js'</span>
  &#125;
&#125;
<span class="hljs-built_in">module</span>.exports = config
</code></pre>






<p data-nodeid="12286">这种方式同样也可以实现载入类型，而且相比于在代码中通过&nbsp;import&nbsp;语句导入类型更为方便，也更为合理。</p>
<p data-nodeid="12852">不过需要注意一点，这种导入类型的方式并不是 ES Modules 中的&nbsp;<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/import#%E5%8A%A8%E6%80%81import" data-nodeid="12857">Dynamic Imports</a>，而是 TypeScript 中提供特性。虽然我们这里只是一个 JavaScript 文件，但是在 VSCode 中的类型系统都是基于 TypeScript 的，所以可以直接按照这种方式使用，详细信息你可以参考这种&nbsp;<a target="_blank" rel="noopener" href="https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html#import-types" data-nodeid="12861">import-types</a>&nbsp;的文档。</p>
<p data-nodeid="12853">其次，这种 @type 类型注释的方式是基于&nbsp;<a target="_blank" rel="noopener" href="https://jsdoc.app" data-nodeid="12866">JSDo</a><a target="_blank" rel="noopener" href="https://jsdoc.app/tags-type.html" data-nodeid="12869">c</a>&nbsp;实现的。JSDoc 中类型注释的用法还有很多，详细可以参考<a target="_blank" rel="noopener" href="https://jsdoc.app/tags-type.html" data-nodeid="12873">官方文档中对 @type 标签的介绍</a>。</p>






<h4 data-nodeid="10312">Webpack 工作模式</h4>



<p data-nodeid="9390">Webpack 4 新增了一个工作模式的用法，这种用法大大简化了 Webpack 配置的复杂程度。你可以把它理解为针对不同环境的几组预设配置：</p>
<ul data-nodeid="9391">
<li data-nodeid="9392">
<p data-nodeid="9393">production 模式下，启动内置优化插件，自动优化打包结果，打包速度偏慢；</p>
</li>
<li data-nodeid="9394">
<p data-nodeid="9395">development 模式下，自动优化打包速度，添加一些调试过程中的辅助插件；</p>
</li>
<li data-nodeid="9396">
<p data-nodeid="9397">none 模式下，运行最原始的打包，不做任何额外处理。</p>
</li>
</ul>
<p data-nodeid="9398">针对工作模式的选项，如果你没有配置一个明确的值，打包过程中命令行终端会打印一个对应的配置警告。在这种情况下 Webpack 将默认使用 production 模式去工作。</p>
<p data-nodeid="9399">production 模式下 Webpack 内部会自动启动一些优化插件，例如，自动压缩打包后的代码。这对实际生产环境是非常友好的，但是打包的结果就无法阅读了。</p>
<p data-nodeid="9400">修改 Webpack 工作模式的方式有两种：</p>
<ul data-nodeid="9401">
<li data-nodeid="9402">
<p data-nodeid="9403">通过 CLI --mode 参数传入；</p>
</li>
<li data-nodeid="9404">
<p data-nodeid="9405">通过配置文件设置 mode 属性。</p>
</li>
</ul>
<p data-nodeid="9406">上述三种 Webpack 工作模式的详细差异我们不再赘述了，你可以在官方文档中查看：<a target="_blank" rel="noopener" href="https://webpack.js.org/configuration/mode/" data-nodeid="9525">https://webpack.js.org/configuration/mode/</a></p>
<h3 data-nodeid="9407">打包结果运行原理</h3>
<p data-nodeid="9408">最后，我们来一起学习 Webpack 打包后生成的 bundle.js 文件，深入了解 Webpack 是如何把这些模块合并到一起，而且还能正常工作的。</p>
<p data-nodeid="9409">为了更好的理解打包后的代码，我们先将 Webpack 工作模式设置为 none，这样 Webpack 就会按照最原始的状态进行打包，所得到的结果更容易理解和阅读。</p>
<p data-nodeid="9410">按照 none 模式打包完成后，我们打开最终生成的 bundle.js 文件，如下图所示：</p>
<p data-nodeid="9411"><img src="https://s0.lgstatic.com/i/image3/M01/8B/13/Cgq2xl6dFMCAIUxiAAGa_XXbqjc578.png" alt="3.png" data-nodeid="9532"></p>
<p data-nodeid="9412">我们可以先把代码全部折叠起来，以便于了解整体的结构，如下图所示：</p>
<blockquote data-nodeid="9413">
<p data-nodeid="9414">TIPS：<br>
-VSCode 中折叠代码的快捷键是 Ctrl + K，Ctrl + 0 （macOS：Command + K，Command + 0）</p>
</blockquote>
<p data-nodeid="9415"><img src="https://s0.lgstatic.com/i/image3/M01/11/FD/Ciqah16dFM-AVj_BAABXnvvMgEs140.png" alt="4.png" data-nodeid="9539"></p>
<p data-nodeid="9416">整体生成的代码其实就是一个立即执行函数，这个函数是 Webpack 工作入口（webpackBootstrap），它接收一个 modules 参数，调用时传入了一个数组。</p>
<p data-nodeid="9417">展开这个数组，里面的元素均是参数列表相同的函数。这里的函数对应的就是我们源代码中的模块，也就是说每个模块最终被包裹到了这样一个函数中，从而实现模块私有作用域，如下图所示：</p>
<p data-nodeid="9418"><img src="https://s0.lgstatic.com/i/image3/M01/04/CE/CgoCgV6dFNiAE5w5AACemkpDN74095.png" alt="5.png" data-nodeid="9544"></p>
<p data-nodeid="9419">我们再来展开 Webpack 工作入口函数，如下图所示：</p>
<p data-nodeid="9420"><img src="https://s0.lgstatic.com/i/image3/M01/8B/13/Cgq2xl6dFOOASkRMAAKy8jLkXaM933.png" alt="6.png" data-nodeid="9548"></p>
<p data-nodeid="9421">这个函数内部并不复杂，而且注释也很清晰，最开始定义了一个 installedModules 对象用于存放或者缓存加载过的模块。紧接着定义了一个 require 函数，顾名思义，这个函数是用来加载模块的。再往后就是在 require 函数上挂载了一些其他的数据和工具函数，这些暂时不用关心。</p>
<p data-nodeid="9422">这个函数执行到最后调用了 require 函数，传入的模块 id 为 0，开始加载模块。模块 id 实际上就是模块数组的元素下标，也就是说这里开始加载源代码中所谓的入口模块，如下图所示：</p>
<p data-nodeid="9423"><img src="https://s0.lgstatic.com/i/image3/M01/8B/13/Cgq2xl6dFOyAHCNzAAKy8jLkXaM393.png" alt="7.png" data-nodeid="9553"></p>
<p data-nodeid="9424">为了更好的理解 bundle.js 的执行过程，你可以把它运行到浏览器中，然后通过 Chrome 的 Devtools 单步调试一下。调试过程我单独录制了一个视频，详情见视频（19分11秒）。</p>
<h3 data-nodeid="9425">写在最后</h3>
<p data-nodeid="9426">整体上对于 Webpack 的基本使用其实并不复杂，特别是在 Webpack 4 以后，很多配置都已经被简化了，在这种配置并不复杂的前提下，开发人员对它的掌握程度主要就体现在了是否能够理解它的工作机制和原理上了。</p>
<p data-nodeid="9427">就拿 Webpack 打包过后的结果来说，大多数的开发者其实根本不会关心它内部的结构是怎样的，又是如何运行起来的，总觉得不需要关心，但是当这种“不用关心”的事情越积越多，整个开发过程不可控的点也会随之增多，当出现问题时，也就很难定位问题的根源了。</p>
<p data-nodeid="9428">其实通过我们的探索你会发现，当你打开“黑盒子”后，里面的东西并没有想象的那么复杂，很多时候你离成功就只有一步之遥，而驱使你走向成功的其实是你的好奇心。在我看来，好奇心应该是一个优秀开发者的基本素质，对待未知的好奇就是我们进步的源泉，与君共勉。</p>
<h3 data-nodeid="9429">总结</h3>
<p data-nodeid="9430">最后我来总结一下本课时的重点，你也可以通过这几个重点反思一下掌握与否：</p>
<ol data-nodeid="9431">
<li data-nodeid="9432">
<p data-nodeid="9433">Webpack 是如何满足模块化打包需求的。</p>
</li>
<li data-nodeid="9434">
<p data-nodeid="9435">Webpack 打包的配置方式以及一个可以实现配置文件智能提示的小技巧。</p>
</li>
<li data-nodeid="9436">
<p data-nodeid="9437">Webpack 工作模式特性的作用。</p>
</li>
<li data-nodeid="9438">
<p data-nodeid="9439">通过 Webpack 打包后的结果是如何运行起来的？</p>
</li>
</ol>

<hr>
<h3 id="精选评论"><a href="#精选评论" class="headerlink" title="精选评论"></a>精选评论</h3><h5 id="6899："><a href="#6899：" class="headerlink" title="**6899："></a>**6899：</h5><blockquote>
<p>老师，请问下里面的课件和源码去哪下载？</p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-讲师回复："><a href="#amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; 源码可以到我的 GitHub 中搜索 webpack-demo。<a target="_blank" rel="noopener" href="https://github.com/zce">https://github.com/zce</a></p>
</blockquote>
<h5 id="钊："><a href="#钊：" class="headerlink" title="*钊："></a>*钊：</h5><blockquote>
<p>老师，请问后面那个sever . 启动服务，是使用什么插件</p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-1"><a href="#amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-1" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; 是一个叫做 serve 的包，<a target="_blank" rel="noopener" href="https://www.npmjs.com/package/serve">https://www.npmjs.com/package/serve</a></p>
</blockquote>
<h5 id="新："><a href="#新：" class="headerlink" title="*新："></a>*新：</h5><blockquote>
<p>分析工作流程这个地方很赞！</p>
</blockquote>
<h5 id="GS："><a href="#GS：" class="headerlink" title="GS："></a>GS：</h5><blockquote>
<div><span style="font-size: 16.0125px;">记录一下踩坑，最后打包成bundle.js之后，serve运行的之前，html中要修改为src="dist/bundle.js"</span></div><div><span style="font-size: 16.0125px;">不要用原来的main.js&nbsp;</span></div><div><span style="font-size: 16.0125px;">哈哈哈，老师可能觉得太简单了，没有明确说明这个，仔细看视频里面是这样写的。</span></div>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-2"><a href="#amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-2" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; 哈哈哈，666</p>
</blockquote>
<h5 id="9527："><a href="#9527：" class="headerlink" title="**9527："></a>**9527：</h5><blockquote>
<p>老师，我配置&#x2F;** @type {import(‘webpack’).Configuration} *&#x2F;了 怎么没效果啊？</p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-3"><a href="#amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-3" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; 问题不太具体哈，我猜测你可能是没有使用最新版本的 VSCode</p>
</blockquote>
<h5 id="杰："><a href="#杰：" class="headerlink" title="**杰："></a>**杰：</h5><blockquote>
<p>大多数的开发者其实根本不会关心它内部的结构是怎样的，又是如何运行起来的，总觉得不需要关心，但是当这种“不用关心”的事情越积越多，整个开发过程不可控的点也会随之增多，当出现问题时，也就很难定位问题的根源了。<div><br></div><div>看到这句话很有感觉啊</div></p>
</blockquote>
<h5 id="硕："><a href="#硕：" class="headerlink" title="*硕："></a>*硕：</h5><blockquote>
<p>调试过程单独录制的视频在哪？</p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-4"><a href="#amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-4" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; “为了更好的理解 bundle.js 的执行过程，你可以把它运行到浏览器中，然后通过 Chrome 的 Devtools 单步调试一下。调试过程我单独录制了一个视频，详情见视频（19分11秒）。”</p>
</blockquote>
<h5 id="邵："><a href="#邵：" class="headerlink" title="邵："></a>邵：</h5><blockquote>
<p>讲的不错👍，如果能实战演示就更赞了，能给新手带来更顺畅的入门体验😄</p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-编辑回复："><a href="#amp-nbsp-amp-nbsp-amp-nbsp-编辑回复：" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 编辑回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 编辑回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; 后面会有实战案例哦</p>
</blockquote>
<h5 id="勇："><a href="#勇：" class="headerlink" title="**勇："></a>**勇：</h5><blockquote>
<p>通过&#x2F;**<div>&amp;nbsp;* @type { import(‘webpack’).Configuration }</div><div>&amp;nbsp;*&#x2F;，可以方便的开发和打包，不用去注释哇。</div></p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-5"><a href="#amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-5" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; 是的，只是很多人没有接触过这种用法</p>
</blockquote>
<h5 id="添："><a href="#添：" class="headerlink" title="*添："></a>*添：</h5><blockquote>
<p>坐等第三章😁</p>
</blockquote>
<h5 id="太："><a href="#太：" class="headerlink" title="**太："></a>**太：</h5><blockquote>
<p>讲的真不错！表达能力非常强！</p>
</blockquote>
<h5 id="琼："><a href="#琼：" class="headerlink" title="**琼："></a>**琼：</h5><blockquote>
<p>感觉老师讲的真的真的很不错 ！！</p>
</blockquote>
<h5 id="宁："><a href="#宁：" class="headerlink" title="*宁："></a>*宁：</h5><blockquote>
<p>在拉钩买的第一门课，没想到质量这么高，前提一定是对前端整体都要有一定认识深度和应用经验，再来看此门课程，受益匪浅，文字总结+音频+视频同步提供的方式简直是太棒了！</p>
</blockquote>
<h5 id="鹏："><a href="#鹏：" class="headerlink" title="**鹏："></a>**鹏：</h5><blockquote>
<p>怎么我的还是在下载好serve后，需要在package.json中配置serve：“serve”，然后执行npm run serve才行？</p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-6"><a href="#amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-6" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; serve 模块安装在全局才能够直接执行，否则必须通过 yarn &#x2F; npx 启动，也可以通过 npm scripts 的方式启动。<br>建议你可以单独先补充一点 Node.js 工具层面知识储备，现在对前端太重要了</p>
</blockquote>
<h5 id="道："><a href="#道：" class="headerlink" title="*道："></a>*道：</h5><blockquote>
<p>老师,你用的vs code的皮肤是什么?</p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-7"><a href="#amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-7" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; 截图里面用的应该是 One Dark Pro，我现在使用的是 GitHub Theme</p>
</blockquote>
<h5 id="帆："><a href="#帆：" class="headerlink" title="*帆："></a>*帆：</h5><blockquote>
<p>老师，请问一下vite会取代wepake吗</p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-8"><a href="#amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-8" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; 在短期内肯定不会取代，另外其实 vite 并不是 bundleless 方案，只是开发阶段不打包，生产阶段内部使用的是 rollup。</p>
</blockquote>
<p>BTW，即便是 bundleless 工具成为主流，个人认为也不一定是 vite，有可能是更专业的工具，比如 snowpack</p>
<h5 id="啸："><a href="#啸：" class="headerlink" title="*啸："></a>*啸：</h5><blockquote>
<p>打包前和打包后直接打开index.html 浏览器抛出跨域错误 ……&#x2F;main.js’ from origin ‘null’ has been blocked by CORS policy: Cross origin requests are only supported for protocol schemes: http, data, chrome, chrome-extension, https.<div>将整个文件夹放入容器中才可正常访问，这是什么原因呢？</div></p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-9"><a href="#amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-9" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; file:&#x2F;&#x2F; 的方式访问文件有很多问题，比如 file:&#x2F;&#x2F; 下默认 AJAX 也会有这样的问题。<br>同样的道理 这里也是因为 ESM 不支持 file:&#x2F;&#x2F; 协议访问。</p>
</blockquote>
<p>BTW，实际企业开发过程中，只要是应用的开发必然使用 http 方式</p>
<h5 id="明："><a href="#明：" class="headerlink" title="**明："></a>**明：</h5><blockquote>
<div><div>import { Configuration } from 'webpack'</div><div><br></div><div>/**</div><div>&nbsp;* @type {Configuration}</div><div>&nbsp;*/</div></div><div><br></div><div>可以替换为</div><div>/**</div><div>&nbsp;* @type {&nbsp;<span style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0); font-size: 0.427rem; -webkit-text-size-adjust: 100%;">Import(</span><span style="font-size: 0.427rem; -webkit-text-size-adjust: 100%;">'webpack'</span><span style="font-size: 0.427rem; -webkit-tap-highlight-color: rgba(0, 0, 0, 0); -webkit-text-size-adjust: 100%;">).Configuration }</span></div><div><span style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0); font-size: 0.427rem; -webkit-text-size-adjust: 100%;">&nbsp;*/</span></div><br>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-10"><a href="#amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-10" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; 正解，这是 JSDoc 的用法，详细可以参考：<a target="_blank" rel="noopener" href="https://jsdoc.app/tags-type.html">https://jsdoc.app/tags-type.html</a> 以及 VSCode 官网：<a target="_blank" rel="noopener" href="https://code.visualstudio.com/docs/languages/javascript">https://code.visualstudio.com/docs/languages/javascript</a></p>
</blockquote>
<h5 id="愚："><a href="#愚：" class="headerlink" title="**愚："></a>**愚：</h5><blockquote>
<p>老师，本地按你那样引报跨域错误，js引不进来&amp;nbsp; 要怎么处理那<br></p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-11"><a href="#amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-11" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; 现在前端开发是不能用文件方式访问的，也就是必须用 http 服务访问。文件访问一堆问题，最简单的 AJAX 就会出现这种问题</p>
</blockquote>
<h5 id="俊："><a href="#俊：" class="headerlink" title="**俊："></a>**俊：</h5><blockquote>
<p>这个 bundle.js 里面的函数执行一次就不再执行了，把入口文件依赖的模块都加载到了内存中了， 那么后面和入口文件没有依赖的文件是怎么加载进来的啊？ 也就是按需加载的功能</p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-12"><a href="#amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-12" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; 往后继续吧少年，后面有详细介绍</p>
</blockquote>
<h5 id="宇："><a href="#宇：" class="headerlink" title="**宇："></a>**宇：</h5><blockquote>
<p>很容易理解，讲的很清楚，赞</p>
</blockquote>
<h5 id="浩："><a href="#浩：" class="headerlink" title="**浩："></a>**浩：</h5><blockquote>
<p>真的觉得这是我见过最好的webpack课程了。老师真的特别用心 感受的到🙌</p>
</blockquote>
<h5 id="8802："><a href="#8802：" class="headerlink" title="**8802："></a>**8802：</h5><blockquote>
<p>老师， 想问下， 项目的搭建，修改配置， 编译，到源码等，这些步骤有吗？ 想运行讲解的例子跟下代码， 但是不知道如何下手？</p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-13"><a href="#amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-13" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; 源码可以到我的 GitHub 中搜索 webpack-demo。<a target="_blank" rel="noopener" href="https://github.com/zce">https://github.com/zce</a></p>
</blockquote>
<h5 id="森："><a href="#森：" class="headerlink" title="**森："></a>**森：</h5><blockquote>
<p>为什么按照讲解的 path: path.join(_dirname,’output’)出现错误，改成 path: path.resolve(_dirname,’output’)后成功了？<br></p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-14"><a href="#amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-14" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; 具体的错误是啥呢？正常来说这种情况下 ，path.join 和 path.resolve 一样</p>
</blockquote>
<h5 id="超："><a href="#超：" class="headerlink" title="*超："></a>*超：</h5><blockquote>
<p>有没有repo可以看看或者用sandbox作为示例也很方便观看</p>
</blockquote>
<h6 id="amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-15"><a href="#amp-nbsp-amp-nbsp-amp-nbsp-讲师回复：-15" class="headerlink" title="&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复："></a>&amp;nbsp;&amp;nbsp;&amp;nbsp; 讲师回复：</h6><blockquote>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp; 源码可以到我的 GitHub 中搜索 webpack-demo。<a target="_blank" rel="noopener" href="https://github.com/zce">https://github.com/zce</a></p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/11/02/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-Webpack-%E5%AE%9E%E7%8E%B0%E6%A8%A1%E5%9D%97%E5%8C%96%E6%89%93%E5%8C%85%EF%BC%9F/" data-id="claxeer9z000yv8w19ed483ob" data-title="如何使用 Webpack 实现模块化打包？" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; 上一页</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/3/">下一页 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/11/">十一月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">十月 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/11/26/%E4%B8%BA%E4%BB%80%E4%B9%88React16%E8%A6%81%E6%9B%B4%E6%94%B9%E7%BB%84%E4%BB%B6%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-%EF%BC%88%E4%B8%8B%EF%BC%89/">为什么React16要更改组件的生命周期?（下）</a>
          </li>
        
          <li>
            <a href="/2022/11/26/%E8%A6%81%E6%9B%B4%E6%94%B9%E7%BB%84%E4%BB%B6%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%9F%EF%BC%88%E4%B8%8A%EF%BC%89/">(no title)</a>
          </li>
        
          <li>
            <a href="/2022/11/26/%E4%BB%A3%E7%A0%81%E8%BD%ACdom/">代码转dom</a>
          </li>
        
          <li>
            <a href="/2022/11/26/React%E7%9F%A5%E8%AF%86%E9%93%BE/">React知识链</a>
          </li>
        
          <li>
            <a href="/2022/11/02/%E6%8E%92%E5%BA%8F%E2%80%9C/">排序“</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 XuJiaDi<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>